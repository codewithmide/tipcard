"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/solana-native-contract.ts":
/*!*****************************************!*\
  !*** ./utils/solana-native-contract.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaNativeContract: function() { return /* binding */ SolanaNativeContract; },\n/* harmony export */   solanaNativeContract: function() { return /* binding */ solanaNativeContract; }\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var _neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @neonevm/solana-sign */ \"(app-pages-browser)/./node_modules/@neonevm/solana-sign/dist/esm/index.mjs\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _contractABI_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contractABI.json */ \"(app-pages-browser)/./utils/contractABI.json\");\n\n\n\n\n// Use the actual deployed contract ABI\nconst SOLANA_TIPCARD_ABI = _contractABI_json__WEBPACK_IMPORTED_MODULE_2__;\nconst CONTRACT_ADDRESS = \"0xCFE03c7c67456D094C0162F9030393FC2cCc40Cb\" || 0;\nconst NEON_CORE_RPC_URL = \"https://devnet.neonevm.org\" || 0;\nconst NEON_PROXY_RPC_URL = \"\".concat(NEON_CORE_RPC_URL, \"/sol\");\nconst SOLANA_RPC_URL = \"https://api.devnet.solana.com\";\nclass SolanaNativeContract {\n    /**\n   * Get Neon EVM chain ID\n   */ async getChainId() {\n        try {\n            // Use the proxy API to get chain information\n            const response = await fetch(NEON_PROXY_RPC_URL, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    id: 1,\n                    jsonrpc: \"2.0\",\n                    method: \"eth_chainId\",\n                    params: []\n                })\n            });\n            const result = await response.json();\n            return parseInt(result.result, 16) // Convert hex to decimal\n            ;\n        } catch (error) {\n            console.warn(\"Could not get chain ID, using default:\", error);\n            return 245022927 // Neon Devnet default\n            ;\n        }\n    }\n    /**\n   * Get Neon EVM program address using a temporary initialization\n   */ async getNeonEvmProgram() {\n        try {\n            var _initResult_solanaUser;\n            console.log(\"Attempting to get Neon EVM program via temporary keypair initialization...\");\n            // Create a temporary keypair just to get the program information\n            const { Keypair } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"));\n            const tempKeypair = Keypair.generate();\n            // Use the existing proxyApi to get the information\n            const initResult = await this.proxyApi.init(tempKeypair);\n            console.log(\"Temporary init result:\", initResult);\n            if ((_initResult_solanaUser = initResult.solanaUser) === null || _initResult_solanaUser === void 0 ? void 0 : _initResult_solanaUser.neonEvmProgram) {\n                return initResult.solanaUser.neonEvmProgram;\n            } else {\n                throw new Error(\"No neonEvmProgram in init result\");\n            }\n        } catch (error) {\n            console.warn(\"Temporary init failed, trying direct API call:\", error);\n            try {\n                var _result_result, _result_result1;\n                // Fallback to direct API call\n                const response = await fetch(NEON_PROXY_RPC_URL, {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        id: 1,\n                        jsonrpc: \"2.0\",\n                        method: \"neon_getEvmParams\",\n                        params: []\n                    })\n                });\n                const result = await response.json();\n                console.log(\"Direct API response:\", result);\n                // Check different possible response structures\n                let programAddress;\n                if ((_result_result = result.result) === null || _result_result === void 0 ? void 0 : _result_result.neonEvmProgram) {\n                    programAddress = result.result.neonEvmProgram;\n                } else if ((_result_result1 = result.result) === null || _result_result1 === void 0 ? void 0 : _result_result1.programId) {\n                    programAddress = result.result.programId;\n                } else if (result.result && typeof result.result === \"string\") {\n                    programAddress = result.result;\n                } else {\n                    throw new Error(\"Unexpected response structure\");\n                }\n                console.log(\"Extracted program address:\", programAddress);\n                return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(programAddress);\n            } catch (apiError) {\n                console.warn(\"Direct API call also failed, using default:\", apiError);\n                // Default Neon EVM program for devnet\n                return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(\"eeLSJgWzzxrqKv1UxtRVVH8FX3qCQWUs9QuAjJpETGSm\");\n            }\n        }\n    }\n    /**\n   * Initialize with Solana wallet using the exact same pattern as tests\n   */ async initWithSolanaWallet(walletAdapter) {\n        if (!walletAdapter.publicKey) {\n            throw new Error(\"Wallet not connected\");\n        }\n        try {\n            console.log(\"\\uD83D\\uDD27 Using exact test pattern with wallet adapter...\");\n            console.log(\"Wallet public key:\", walletAdapter.publicKey.toBase58());\n            // Create a temporary keypair for initialization, then override with wallet's public key\n            const { Keypair } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"));\n            const tempKeypair = Keypair.generate();\n            // Use the exact same initialization pattern as the test (with temp keypair)\n            console.log(\"Initializing with proxy API (same as test pattern)...\");\n            const { chainId, solanaUser: tempResult } = await this.proxyApi.init(tempKeypair);\n            // Recalculate the EVM address using the wallet's actual public key\n            // The EVM address should be derived from the wallet's public key, not the temp keypair\n            console.log(\"Recalculating EVM address for wallet public key...\");\n            const actualSolanaNeonAccount = new _neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__.SolanaNeonAccount(walletAdapter.publicKey, tempResult.neonEvmProgram, tempResult.tokenMint, chainId // Keep the same chain ID\n            );\n            // Now create the proper solanaUser object using wallet's public key\n            // but keeping all the other derived values from the temp initialization\n            const walletSolanaUser = {\n                ...tempResult,\n                publicKey: walletAdapter.publicKey,\n                neonWallet: actualSolanaNeonAccount.neonWallet,\n                balanceAddress: actualSolanaNeonAccount.balanceAddress,\n                chainId,\n                walletAdapter: walletAdapter // Add wallet adapter for signing\n            };\n            // Store the result in the same structure as tests\n            this.chainId = chainId;\n            this.solanaUser = walletSolanaUser;\n            console.log(\"✅ Wallet initialized using test pattern!\");\n            console.log(\"\\uD83D\\uDCCD Derived EVM address:\", this.solanaUser.neonWallet);\n            console.log(\"\\uD83D\\uDCB0 Balance address:\", this.solanaUser.balanceAddress.toBase58());\n            console.log(\"Neon SDK initialized with wallet adapter (using SolanaNeonAccount)\");\n            console.log(\"Chain ID:\", this.chainId);\n            console.log(\"Solana User Public Key:\", this.solanaUser.publicKey.toBase58());\n            console.log(\"Solana User Neon Wallet:\", this.solanaUser.neonWallet);\n            console.log(\"Solana User Balance Address:\", this.solanaUser.balanceAddress.toBase58());\n            // Create contract instance\n            const readOnlyProvider = new ethers__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider(NEON_CORE_RPC_URL);\n            this.contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.Contract(CONTRACT_ADDRESS, SOLANA_TIPCARD_ABI, readOnlyProvider);\n            // Verify the derived EVM address is valid\n            console.log(\"\\uD83D\\uDD0D Verifying derived EVM address...\");\n            try {\n                // Check if this EVM address has been used before (has transaction history)\n                const txCount = await readOnlyProvider.getTransactionCount(this.solanaUser.neonWallet);\n                console.log(\"\\uD83D\\uDCCA EVM address transaction count:\", txCount);\n                if (txCount > 0) {\n                    console.log(\"✅ This EVM address has transaction history - it exists on-chain!\");\n                } else {\n                    console.log(\"ℹ️ This EVM address is new (no transaction history yet)\");\n                    console.log(\"ℹ️ The address will be registered on-chain when first transaction is made\");\n                }\n            } catch (verifyError) {\n                console.log(\"⚠️ Could not verify EVM address:\", verifyError);\n            }\n            // Verify contract is deployed at this address\n            try {\n                console.log(\"Verifying contract at address:\", CONTRACT_ADDRESS);\n                const code = await readOnlyProvider.getCode(CONTRACT_ADDRESS);\n                console.log(\"Contract code length:\", code.length);\n                if (code === \"0x\") {\n                    console.warn(\"⚠️ No contract code found at address:\", CONTRACT_ADDRESS);\n                    console.log(\"This might mean the contract is not deployed or address is incorrect\");\n                } else {\n                    console.log(\"✅ Contract found at address\");\n                    // Check if user's Solana address is registered with Neon EVM\n                    console.log(\"Checking Solana user registration...\");\n                    console.log(\"User EVM address:\", this.solanaUser.neonWallet);\n                    console.log(\"User Solana address:\", this.solanaUser.publicKey.toBase58());\n                    // Get the Solana address that Neon EVM has registered for this user\n                    const registeredSolanaAddr = await this.contract.getSolanaUserAddress(this.solanaUser.neonWallet);\n                    console.log(\"Registered Solana address (from contract):\", registeredSolanaAddr);\n                    const isUserRegistered = await this.contract.isSolanaUser(this.solanaUser.neonWallet);\n                    console.log(\"Is user registered with contract:\", isUserRegistered);\n                    if (!isUserRegistered) {\n                        console.warn(\"⚠️ User is not registered as Solana user with Neon EVM\");\n                        console.log(\"This may happen if the Solana Native SDK initialization did not complete properly\");\n                        console.log(\"The SDK should automatically register the user during init() call\");\n                        console.log(\"Attempting to create balance account to complete registration...\");\n                        // Try to create the balance account which should register the user\n                        try {\n                            const account = await this.connection.getAccountInfo(this.solanaUser.balanceAddress);\n                            if (account === null) {\n                                console.log(\"Balance account does not exist, will create it on first transaction\");\n                            } else {\n                                console.log(\"Balance account exists, user should be registered\");\n                            }\n                        } catch (balanceError) {\n                            console.log(\"Could not check balance account:\", balanceError);\n                        }\n                    } else {\n                        console.log(\"✅ User is properly registered\");\n                    }\n                }\n            } catch (verifyError) {\n                console.warn(\"Failed to verify contract:\", verifyError);\n            }\n        } catch (error) {\n            console.error(\"Failed to initialize Solana Native SDK:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Create a payment link using Solana Native SDK\n   */ async createPaymentLink(suggestedAmountSOL, isFlexible, description) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        // Convert SOL to lamports (1 SOL = 1e9 lamports)\n        const amountLamports = Math.floor(suggestedAmountSOL * 1e9);\n        try {\n            var _scheduledTransaction_signers, _receipt_result, _receipt_result1, _receipt_result2, _receipt_result_logs, _receipt_result3, _receipt_result4, _receipt_result5, _receipt_result6, _receipt_result7, _receipt_result8, _receipt_result9;\n            // Get nonce\n            // Force nonce incrementation to avoid reuse\n            let chainNonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Chain nonce from getTransactionCount:\", chainNonce);\n            console.log(\"Last used nonce in session:\", this.lastUsedNonce);\n            // Always use a higher nonce than both chain and last used\n            let nonce = Math.max(chainNonce, this.lastUsedNonce + 1);\n            console.log(\"Calculated nonce:\", nonce);\n            // Track this nonce as used\n            this.lastUsedNonce = nonce;\n            console.log(\"Final nonce to use:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"createSolanaPaymentLink\", [\n                amountLamports,\n                isFlexible,\n                description\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Check if balance account exists, if not create it\n            const account = await this.connection.getAccountInfo(this.solanaUser.balanceAddress);\n            if (account === null) {\n                scheduledTransaction.instructions.unshift((0,_neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__.createBalanceAccountInstruction)(this.solanaUser.neonEvmProgram, this.solanaUser.publicKey, this.solanaUser.neonWallet, this.chainId));\n            }\n            // Sign and send transaction (exactly like working examples)\n            const { blockhash } = await this.connection.getLatestBlockhash();\n            scheduledTransaction.recentBlockhash = blockhash;\n            console.log(\"Signing with wallet adapter...\");\n            console.log(\"Signers needed:\", JSON.stringify(((_scheduledTransaction_signers = scheduledTransaction.signers) === null || _scheduledTransaction_signers === void 0 ? void 0 : _scheduledTransaction_signers.map((s)=>s.toString())) || \"none\"));\n            // Sign transaction using wallet adapter instead of keypair (like in tests)\n            // In tests: scheduledTransaction.sign({ publicKey: solanaUser.publicKey, secretKey: solanaUser.keypair.secretKey })\n            // In frontend: use wallet adapter signing\n            const signedTx = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            // Send transaction immediately after signing\n            console.log(\"Sending payment link creation transaction immediately...\");\n            await this.connection.sendRawTransaction(signedTx.serialize(), {\n                skipPreflight: false,\n                preflightCommitment: \"confirmed\"\n            });\n            // Wait for transaction execution on Neon EVM\n            const transactionStatus = await this.proxyApi.waitTransactionTreeExecution(this.solanaUser.neonWallet, nonce, 60000 // 60 second timeout\n            );\n            console.log(\"Transaction status:\", transactionStatus);\n            if (transactionStatus.length === 0) {\n                throw new Error(\"No transaction status returned - transaction may not have been processed\");\n            }\n            const txStatus = transactionStatus[0];\n            console.log(\"Transaction execution status:\", txStatus.status);\n            if (txStatus.status === \"NotStarted\") {\n                console.warn(\"⚠️ Transaction was scheduled but not yet executed by Neon operators\");\n                console.log(\"This is expected - Neon will process it eventually\");\n                console.log(\"Transaction hash:\", txStatus.transactionHash);\n                // Since we have a transaction hash, proceed with using it as the payment link ID\n                // The transaction will be processed by Neon operators eventually\n                console.log(\"✅ Using transaction hash as payment link ID - Neon will process it when ready\");\n                return {\n                    linkId: txStatus.transactionHash,\n                    txHash: txStatus.transactionHash\n                };\n            } else if (txStatus.status === \"Failed\") {\n                throw new Error(\"Transaction execution failed. Hash: \".concat(txStatus.transactionHash));\n            } else if (txStatus.status !== \"Success\") {\n                console.warn(\"Transaction finished with unexpected status:\", txStatus.status);\n                // Still try to return the transaction hash in case it's usable\n                return {\n                    linkId: txStatus.transactionHash,\n                    txHash: txStatus.transactionHash\n                };\n            }\n            const txHash = transactionStatus[0].transactionHash;\n            console.log(\"Transaction hash:\", txHash);\n            // Get the link ID from transaction receipt\n            const receipt = await this.proxyApi.getTransactionReceipt(txHash);\n            console.log(\"Full transaction receipt:\", JSON.stringify(receipt, null, 2));\n            let linkId = \"\";\n            // Check if the transaction was successful\n            if (((_receipt_result = receipt.result) === null || _receipt_result === void 0 ? void 0 : _receipt_result.status) !== \"0x1\") {\n                var _receipt_result10;\n                throw new Error(\"Transaction failed - status: \" + ((_receipt_result10 = receipt.result) === null || _receipt_result10 === void 0 ? void 0 : _receipt_result10.status));\n            }\n            // Enhanced debugging of the receipt structure\n            console.log(\"Receipt status:\", (_receipt_result1 = receipt.result) === null || _receipt_result1 === void 0 ? void 0 : _receipt_result1.status);\n            console.log(\"Receipt logs array:\", (_receipt_result2 = receipt.result) === null || _receipt_result2 === void 0 ? void 0 : _receipt_result2.logs);\n            console.log(\"Receipt logs length:\", (_receipt_result3 = receipt.result) === null || _receipt_result3 === void 0 ? void 0 : (_receipt_result_logs = _receipt_result3.logs) === null || _receipt_result_logs === void 0 ? void 0 : _receipt_result_logs.length);\n            console.log(\"Receipt logsBloom:\", (_receipt_result4 = receipt.result) === null || _receipt_result4 === void 0 ? void 0 : _receipt_result4.logsBloom);\n            console.log(\"Receipt contractAddress:\", (_receipt_result5 = receipt.result) === null || _receipt_result5 === void 0 ? void 0 : _receipt_result5.contractAddress);\n            console.log(\"Receipt gasUsed:\", (_receipt_result6 = receipt.result) === null || _receipt_result6 === void 0 ? void 0 : _receipt_result6.gasUsed);\n            console.log(\"Receipt effectiveGasPrice:\", (_receipt_result7 = receipt.result) === null || _receipt_result7 === void 0 ? void 0 : _receipt_result7.effectiveGasPrice);\n            // Check if there's a different location for logs\n            console.log(\"Raw transaction data:\", (_receipt_result8 = receipt.result) === null || _receipt_result8 === void 0 ? void 0 : _receipt_result8.neonRawTransaction);\n            // Note: getTransaction method not available on NeonProxyRpcApi\n            // Transaction details are already in the receipt\n            // Extract all neonLogs from solanaTransactions\n            const allNeonLogs = [];\n            if ((_receipt_result9 = receipt.result) === null || _receipt_result9 === void 0 ? void 0 : _receipt_result9.solanaTransactions) {\n                for (const solTx of receipt.result.solanaTransactions){\n                    if (solTx.solanaInstructions) {\n                        for (const instruction of solTx.solanaInstructions){\n                            if (instruction.neonLogs && instruction.neonLogs.length > 0) {\n                                allNeonLogs.push(...instruction.neonLogs);\n                            }\n                        }\n                    }\n                }\n            }\n            console.log(\"Found\", allNeonLogs.length, \"neonLogs to parse\");\n            // Try to parse logs for the SolanaLinkCreated event\n            if (allNeonLogs.length > 0) {\n                for (const log of allNeonLogs){\n                    try {\n                        console.log(\"Trying to parse neonLog:\", log);\n                        // Check if this log is from our contract\n                        if (log.address.toLowerCase() === CONTRACT_ADDRESS.toLowerCase()) {\n                            console.log(\"Log is from our contract, parsing...\");\n                            // Convert the log to the format expected by ethers\n                            const ethersLog = {\n                                address: log.address,\n                                data: log.data,\n                                topics: log.topics\n                            };\n                            const parsedLog = iface.parseLog(ethersLog);\n                            console.log(\"Parsed log:\", parsedLog);\n                            if ((parsedLog === null || parsedLog === void 0 ? void 0 : parsedLog.name) === \"SolanaLinkCreated\") {\n                                linkId = parsedLog.args.linkId;\n                                console.log(\"✅ Found link ID from SolanaLinkCreated event:\", linkId);\n                                break;\n                            }\n                        } else {\n                            console.log(\"Log from different contract:\", log.address);\n                        }\n                    } catch (e) {\n                        console.log(\"Failed to parse neonLog:\", e);\n                    // Skip logs that can't be parsed\n                    }\n                }\n            } else {\n                console.warn(\"No neonLogs found in transaction receipt!\");\n                console.log(\"This might indicate:\");\n                console.log(\"1. The contract call failed silently\");\n                console.log(\"2. The contract is not at the expected address\");\n                console.log(\"3. The contract function call reverted\");\n                console.log(\"4. Events are not being emitted properly\");\n                // Try calling the contract read method to see if data was actually stored\n                try {\n                    console.log(\"Attempting to read payment link using transaction hash as ID...\");\n                    const testData = await this.contract.getSolanaPaymentLink(txHash);\n                    console.log(\"Contract read result:\", testData);\n                } catch (readError) {\n                    console.log(\"Contract read failed:\", readError);\n                }\n            }\n            // If we couldn't extract from logs, investigate further\n            if (!linkId) {\n                var _receipt_result11, _receipt_result12;\n                console.error(\"Could not extract link ID from transaction events!\");\n                console.log(\"This suggests the contract call may have failed silently\");\n                // Check if the transaction actually reverted\n                console.log(\"Checking for revert data...\");\n                if ((_receipt_result11 = receipt.result) === null || _receipt_result11 === void 0 ? void 0 : _receipt_result11.neonRevertData) {\n                    console.log(\"Revert data found:\", receipt.result.neonRevertData);\n                    try {\n                        // Try to decode the revert reason\n                        const revertReason = ethers__WEBPACK_IMPORTED_MODULE_6__.toUtf8String(receipt.result.neonRevertData);\n                        console.log(\"Revert reason:\", revertReason);\n                        throw new Error(\"Contract call reverted: \".concat(revertReason));\n                    } catch (decodeError) {\n                        console.log(\"Could not decode revert reason:\", decodeError);\n                        throw new Error(\"Contract call reverted with unknown reason\");\n                    }\n                }\n                // Let's try to understand why the event wasn't emitted\n                console.log(\"Analyzing function call...\");\n                console.log(\"Contract address:\", CONTRACT_ADDRESS);\n                console.log(\"From address:\", this.solanaUser.neonWallet);\n                console.log(\"Function data in raw tx:\", (_receipt_result12 = receipt.result) === null || _receipt_result12 === void 0 ? void 0 : _receipt_result12.neonRawTransaction);\n                // Check if user is registered\n                try {\n                    const isRegistered = await this.contract.isSolanaUser(this.solanaUser.neonWallet);\n                    console.log(\"Is user registered as Solana user:\", isRegistered);\n                    if (!isRegistered) {\n                        throw new Error(\"User is not registered as a Solana user with the contract. This is required to create payment links.\");\n                    }\n                } catch (registrationError) {\n                    console.error(\"Failed to check user registration:\", registrationError);\n                    throw registrationError;\n                }\n                // If we get here, something else went wrong\n                throw new Error(\"Payment link creation failed: Contract call executed but no event was emitted. The transaction may have failed silently.\");\n            }\n            return {\n                linkId,\n                txHash\n            };\n        } catch (error) {\n            console.error(\"Error creating payment link:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Initialize read-only contract access (without wallet)\n   */ async initReadOnlyContract() {\n        if (!this.contract) {\n            // Create a simple JSON RPC provider for read operations\n            const readOnlyProvider = new ethers__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider(NEON_CORE_RPC_URL);\n            this.contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.Contract(CONTRACT_ADDRESS, SOLANA_TIPCARD_ABI, readOnlyProvider);\n        }\n    }\n    /**\n   * Get payment link details\n   */ async getPaymentLink(linkId) {\n        // Initialize contract if not already done\n        if (!this.contract) {\n            await this.initReadOnlyContract();\n        }\n        console.log(\"Getting payment link with ID:\", linkId);\n        console.log(\"Contract address:\", CONTRACT_ADDRESS);\n        try {\n            const result = await this.contract.getSolanaPaymentLink(linkId);\n            console.log(\"Raw contract result:\", result);\n            const paymentLink = {\n                evmCreator: result.evmCreator,\n                solanaCreator: result.solanaCreator,\n                amount: result.amount,\n                isFlexible: result.isFlexible,\n                isActive: result.isActive,\n                totalReceived: result.totalReceived,\n                paymentCount: Number(result.paymentCount),\n                description: result.description\n            };\n            // Check if this looks like an empty/non-existent link (transaction not processed yet)\n            if (result.evmCreator === \"0x0000000000000000000000000000000000000000\" && result.amount === BigInt(0) && !result.isActive) {\n                console.warn(\"Payment link appears to be empty/non-existent\");\n                // If this looks like a transaction hash (66 chars, starts with 0x), provide helpful info\n                if (linkId.length === 66 && linkId.startsWith(\"0x\")) {\n                    console.log(\"\\uD83D\\uDCA1 This appears to be a transaction hash - the payment link may still be processing\");\n                    console.log(\"\\uD83D\\uDCA1 Neon operators will eventually process this transaction and create the payment link\");\n                    console.log(\"\\uD83D\\uDCA1 You can bookmark this link and try again in a few minutes\");\n                    // For now, don't throw an error - let the UI handle the empty data gracefully\n                    console.log(\"Returning empty payment link data - transaction may still be processing\");\n                }\n            }\n            return paymentLink;\n        } catch (error) {\n            console.error(\"Contract call error:\", error);\n            throw new Error(\"Payment link not found or contract error\");\n        }\n    }\n    /**\n   * Get user's payment links\n   */ async getUserLinks(userEVMAddress) {\n        // Initialize contract if not already done\n        if (!this.contract) {\n            await this.initReadOnlyContract();\n        }\n        try {\n            return await this.contract.getUserSolanaLinks(userEVMAddress);\n        } catch (error) {\n            console.error(\"Error getting user links:\", error);\n            return [];\n        }\n    }\n    /**\n   * Pay a payment link using Solana Native SDK\n   */ async payLink(linkId, amountSOL) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        console.log(\"Starting payment process...\");\n        console.log(\"Link ID:\", linkId);\n        console.log(\"Amount SOL:\", amountSOL);\n        // First, get the payment link details to find the recipient\n        const linkData = await this.getPaymentLink(linkId);\n        console.log(\"Payment link data:\", linkData);\n        if (!linkData.isActive) {\n            throw new Error(\"Payment link is no longer active\");\n        }\n        // Convert SOL to lamports\n        const amountLamports = Math.floor(amountSOL * 1e9);\n        let transferSignature;\n        try {\n            var _hexString_match, _transactionStatus_, _transactionStatus_1;\n            // Step 1: Perform the actual SOL transfer first\n            console.log(\"Step 1: Performing SOL transfer...\");\n            console.log(\"From:\", this.solanaUser.publicKey.toBase58());\n            console.log(\"To recipient bytes32:\", linkData.solanaCreator);\n            console.log(\"Amount lamports:\", amountLamports);\n            // Convert recipient Solana address from bytes32 to PublicKey\n            // Remove '0x' prefix if present\n            const hexString = linkData.solanaCreator.startsWith(\"0x\") ? linkData.solanaCreator.slice(2) : linkData.solanaCreator;\n            // Convert hex string to byte array\n            const bytes = new Uint8Array(((_hexString_match = hexString.match(/.{2}/g)) === null || _hexString_match === void 0 ? void 0 : _hexString_match.map((byte)=>parseInt(byte, 16))) || []);\n            // For bytes32 from Solana addresses, we need to find the actual 32-byte public key\n            // The bytes32 should contain the 32-byte Solana public key, possibly with leading zeros\n            let recipientPubkey;\n            if (bytes.length === 32) {\n                // Direct conversion from 32 bytes\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(bytes);\n            } else if (bytes.length > 32) {\n                // Take the last 32 bytes if it's longer\n                const last32Bytes = bytes.slice(-32);\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(last32Bytes);\n            } else {\n                // Pad with leading zeros if shorter\n                const paddedBytes = new Uint8Array(32);\n                paddedBytes.set(bytes, 32 - bytes.length);\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(paddedBytes);\n            }\n            console.log(\"Recipient PublicKey:\", recipientPubkey.toBase58());\n            // Create the SOL transfer transaction\n            const { SystemProgram, Transaction } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"));\n            // Create transfer instruction\n            const transferIx = SystemProgram.transfer({\n                fromPubkey: this.solanaUser.publicKey,\n                toPubkey: recipientPubkey,\n                lamports: amountLamports\n            });\n            // Create transaction\n            const transferTx = new Transaction().add(transferIx);\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for SOL transfer...\");\n            const { blockhash, lastValidBlockHeight: transferBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh SOL transfer blockhash:\", blockhash);\n            console.log(\"Last valid block height:\", transferBlockHeight);\n            transferTx.recentBlockhash = blockhash;\n            transferTx.feePayer = this.solanaUser.publicKey;\n            // Sign and send the SOL transfer immediately\n            console.log(\"Signing and sending SOL transfer with fresh blockhash...\");\n            const signedTransferTx = await this.solanaUser.walletAdapter.signTransaction(transferTx);\n            transferSignature = await this.connection.sendRawTransaction(signedTransferTx.serialize(), {\n                skipPreflight: false,\n                preflightCommitment: \"confirmed\"\n            });\n            console.log(\"SOL transfer sent:\", transferSignature);\n            // Wait for transfer confirmation using the modern API\n            await this.connection.confirmTransaction({\n                signature: transferSignature,\n                ...await this.connection.getLatestBlockhash()\n            });\n            console.log(\"SOL transfer confirmed\");\n            // Step 2: Record the payment in the contract\n            console.log(\"Step 2: Recording payment in contract...\");\n            // Convert Solana PublicKey to bytes32\n            const payerSolanaBytes32 = (0,ethers__WEBPACK_IMPORTED_MODULE_7__.zeroPadValue)((0,ethers__WEBPACK_IMPORTED_MODULE_7__.hexlify)(this.solanaUser.publicKey.toBytes()), 32);\n            // Get nonce\n            // Force nonce incrementation to avoid reuse\n            let chainNonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Chain nonce from getTransactionCount:\", chainNonce);\n            console.log(\"Last used nonce in session:\", this.lastUsedNonce);\n            // Always use a higher nonce than both chain and last used\n            let nonce = Math.max(chainNonce, this.lastUsedNonce + 1);\n            console.log(\"Calculated nonce:\", nonce);\n            // Track this nonce as used\n            this.lastUsedNonce = nonce;\n            console.log(\"Final nonce to use:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"paySolanaLink\", [\n                linkId,\n                amountLamports,\n                payerSolanaBytes32\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for contract call...\");\n            const { blockhash: contractBlockhash, lastValidBlockHeight: contractBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh contract call blockhash:\", contractBlockhash);\n            console.log(\"Last valid block height:\", contractBlockHeight);\n            scheduledTransaction.recentBlockhash = contractBlockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            // Sign with wallet adapter instead of keypair (like in tests)\n            // In tests: scheduledTransaction.sign({ publicKey: solanaUser.publicKey, secretKey: solanaUser.keypair.secretKey })\n            // In frontend: use wallet adapter signing\n            console.log(\"Signing contract call with fresh blockhash...\");\n            const signedTx = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            // Send transaction immediately\n            console.log(\"Sending contract call transaction immediately...\");\n            await this.connection.sendRawTransaction(signedTx.serialize(), {\n                skipPreflight: false,\n                preflightCommitment: \"confirmed\"\n            });\n            // Wait for transaction execution on Neon EVM\n            const transactionStatus = await this.proxyApi.waitTransactionTreeExecution(this.solanaUser.neonWallet, nonce, 60000);\n            if (transactionStatus.length === 0 || transactionStatus[0].status !== \"Success\") {\n                console.warn(\"Contract payment recording failed, but SOL transfer succeeded\");\n                console.log(\"Transfer signature:\", transferSignature);\n            // Don't throw error - the payment went through even if recording failed\n            }\n            console.log(\"Payment completed successfully!\");\n            console.log(\"SOL transfer:\", transferSignature);\n            console.log(\"Contract record:\", (_transactionStatus_ = transactionStatus[0]) === null || _transactionStatus_ === void 0 ? void 0 : _transactionStatus_.transactionHash);\n            return {\n                txHash: ((_transactionStatus_1 = transactionStatus[0]) === null || _transactionStatus_1 === void 0 ? void 0 : _transactionStatus_1.transactionHash) || \"contract-recording-failed\",\n                transferSignature\n            };\n        } catch (error) {\n            console.error(\"Error paying link:\", error);\n            if (transferSignature) {\n                console.log(\"Note: SOL transfer may have succeeded:\", transferSignature);\n            }\n            throw error;\n        }\n    }\n    /**\n   * Deactivate a payment link\n   */ async deactivateLink(linkId) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        try {\n            // Get nonce\n            // Force nonce incrementation to avoid reuse\n            let chainNonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Chain nonce from getTransactionCount:\", chainNonce);\n            console.log(\"Last used nonce in session:\", this.lastUsedNonce);\n            // Always use a higher nonce than both chain and last used\n            let nonce = Math.max(chainNonce, this.lastUsedNonce + 1);\n            console.log(\"Calculated nonce:\", nonce);\n            // Track this nonce as used\n            this.lastUsedNonce = nonce;\n            console.log(\"Final nonce to use:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"deactivateSolanaLink\", [\n                linkId\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for deactivate transaction...\");\n            const { blockhash, lastValidBlockHeight: deactivateBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh deactivate blockhash:\", blockhash);\n            console.log(\"Last valid block height:\", deactivateBlockHeight);\n            scheduledTransaction.recentBlockhash = blockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            // Sign with wallet adapter instead of keypair (like in tests)\n            // In tests: scheduledTransaction.sign({ publicKey: solanaUser.publicKey, secretKey: solanaUser.keypair.secretKey })\n            // In frontend: use wallet adapter signing\n            console.log(\"Signing deactivate transaction with fresh blockhash...\");\n            const signedTx = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            // Send transaction immediately\n            console.log(\"Sending deactivate transaction immediately...\");\n            await this.connection.sendRawTransaction(signedTx.serialize(), {\n                skipPreflight: false,\n                preflightCommitment: \"confirmed\"\n            });\n            // Wait for transaction execution\n            const transactionStatus = await this.proxyApi.waitTransactionTreeExecution(this.solanaUser.neonWallet, nonce, 60000);\n            if (transactionStatus.length === 0 || transactionStatus[0].status !== \"Success\") {\n                throw new Error(\"Deactivation transaction failed to execute on Neon EVM\");\n            }\n            return {\n                txHash: transactionStatus[0].transactionHash\n            };\n        } catch (error) {\n            throw error;\n        }\n    }\n    /**\n   * Create a shareable URL for a payment link\n   */ createPaymentURL(linkId) {\n        return \"\".concat(window.location.origin, \"?pay=\").concat(linkId);\n    }\n    /**\n   * Extract link ID from URL\n   */ static extractLinkIdFromURL(url) {\n        try {\n            const urlObj = new URL(url);\n            return urlObj.searchParams.get(\"pay\");\n        } catch (e) {\n            return null;\n        }\n    }\n    /**\n   * Get the user's EVM address derived from Solana public key\n   */ getUserEVMAddress() {\n        var _this_solanaUser;\n        return ((_this_solanaUser = this.solanaUser) === null || _this_solanaUser === void 0 ? void 0 : _this_solanaUser.neonWallet) || null;\n    }\n    constructor(){\n        this.chainId = null;\n        this.contract = null;\n        this.lastUsedNonce = -1;\n        this.connection = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Connection(SOLANA_RPC_URL, \"confirmed\");\n        this.proxyApi = new _neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__.NeonProxyRpcApi(NEON_PROXY_RPC_URL);\n    }\n}\n// Export singleton instance\nconst solanaNativeContract = new SolanaNativeContract();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3NvbGFuYS1uYXRpdmUtY29udHJhY3QudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFnRTtBQUMwQztBQUNwRDtBQUNWO0FBRTVDLHVDQUF1QztBQUN2QyxNQUFNUyxxQkFBcUJELDhDQUFXQTtBQUV0QyxNQUFNRSxtQkFBbUJDLDRDQUFnRCxJQUFJO0FBQzdFLE1BQU1HLG9CQUFvQkgsNEJBQW9DLElBQUk7QUFDbEUsTUFBTUsscUJBQXFCLEdBQXFCLE9BQWxCRixtQkFBa0I7QUFDaEQsTUFBTUcsaUJBQWlCO0FBYWhCLE1BQU1DO0lBYVg7O0dBRUMsR0FDRCxNQUFjQyxhQUE4QjtRQUMxQyxJQUFJO1lBQ0YsNkNBQTZDO1lBQzdDLE1BQU1DLFdBQVcsTUFBTUMsTUFBTUwsb0JBQW9CO2dCQUMvQ00sUUFBUTtnQkFDUkMsU0FBUztvQkFBRSxnQkFBZ0I7Z0JBQW1CO2dCQUM5Q0MsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO29CQUNuQkMsSUFBSTtvQkFDSkMsU0FBUztvQkFDVE4sUUFBUTtvQkFDUk8sUUFBUSxFQUFFO2dCQUNaO1lBQ0Y7WUFDQSxNQUFNQyxTQUFTLE1BQU1WLFNBQVNXLElBQUk7WUFDbEMsT0FBT0MsU0FBU0YsT0FBT0EsTUFBTSxFQUFFLElBQUkseUJBQXlCOztRQUM5RCxFQUFFLE9BQU9HLE9BQU87WUFDZEMsUUFBUUMsSUFBSSxDQUFDLDBDQUEwQ0Y7WUFDdkQsT0FBTyxVQUFVLHNCQUFzQjs7UUFDekM7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBY0csb0JBQXdDO1FBQ3BELElBQUk7Z0JBV0VDO1lBVkpILFFBQVFJLEdBQUcsQ0FBQztZQUVaLGlFQUFpRTtZQUNqRSxNQUFNLEVBQUVDLE9BQU8sRUFBRSxHQUFHLE1BQU0sMExBQU87WUFDakMsTUFBTUMsY0FBY0QsUUFBUUUsUUFBUTtZQUVwQyxtREFBbUQ7WUFDbkQsTUFBTUosYUFBYSxNQUFNLElBQUksQ0FBQ0ssUUFBUSxDQUFDQyxJQUFJLENBQUNIO1lBQzVDTixRQUFRSSxHQUFHLENBQUMsMEJBQTBCRDtZQUV0QyxLQUFJQSx5QkFBQUEsV0FBV08sVUFBVSxjQUFyQlAsNkNBQUFBLHVCQUF1QlEsY0FBYyxFQUFFO2dCQUN6QyxPQUFPUixXQUFXTyxVQUFVLENBQUNDLGNBQWM7WUFDN0MsT0FBTztnQkFDTCxNQUFNLElBQUlDLE1BQU07WUFDbEI7UUFDRixFQUFFLE9BQU9iLE9BQU87WUFDZEMsUUFBUUMsSUFBSSxDQUFDLGtEQUFrREY7WUFFL0QsSUFBSTtvQkFrQkVILGdCQUVPQTtnQkFuQlgsOEJBQThCO2dCQUM5QixNQUFNVixXQUFXLE1BQU1DLE1BQU1MLG9CQUFvQjtvQkFDL0NNLFFBQVE7b0JBQ1JDLFNBQVM7d0JBQUUsZ0JBQWdCO29CQUFtQjtvQkFDOUNDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQzt3QkFDbkJDLElBQUk7d0JBQ0pDLFNBQVM7d0JBQ1ROLFFBQVE7d0JBQ1JPLFFBQVEsRUFBRTtvQkFDWjtnQkFDRjtnQkFDQSxNQUFNQyxTQUFTLE1BQU1WLFNBQVNXLElBQUk7Z0JBRWxDRyxRQUFRSSxHQUFHLENBQUMsd0JBQXdCUjtnQkFFcEMsK0NBQStDO2dCQUMvQyxJQUFJaUI7Z0JBQ0osS0FBSWpCLGlCQUFBQSxPQUFPQSxNQUFNLGNBQWJBLHFDQUFBQSxlQUFlZSxjQUFjLEVBQUU7b0JBQ2pDRSxpQkFBaUJqQixPQUFPQSxNQUFNLENBQUNlLGNBQWM7Z0JBQy9DLE9BQU8sS0FBSWYsa0JBQUFBLE9BQU9BLE1BQU0sY0FBYkEsc0NBQUFBLGdCQUFla0IsU0FBUyxFQUFFO29CQUNuQ0QsaUJBQWlCakIsT0FBT0EsTUFBTSxDQUFDa0IsU0FBUztnQkFDMUMsT0FBTyxJQUFJbEIsT0FBT0EsTUFBTSxJQUFJLE9BQU9BLE9BQU9BLE1BQU0sS0FBSyxVQUFVO29CQUM3RGlCLGlCQUFpQmpCLE9BQU9BLE1BQU07Z0JBQ2hDLE9BQU87b0JBQ0wsTUFBTSxJQUFJZ0IsTUFBTTtnQkFDbEI7Z0JBRUFaLFFBQVFJLEdBQUcsQ0FBQyw4QkFBOEJTO2dCQUMxQyxPQUFPLElBQUk5QyxzREFBU0EsQ0FBQzhDO1lBQ3ZCLEVBQUUsT0FBT0UsVUFBVTtnQkFDakJmLFFBQVFDLElBQUksQ0FBQywrQ0FBK0NjO2dCQUM1RCxzQ0FBc0M7Z0JBQ3RDLE9BQU8sSUFBSWhELHNEQUFTQSxDQUFDO1lBQ3ZCO1FBQ0Y7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBTWlELHFCQUFxQkMsYUFBa0IsRUFBaUI7UUFDNUQsSUFBSSxDQUFDQSxjQUFjQyxTQUFTLEVBQUU7WUFDNUIsTUFBTSxJQUFJTixNQUFNO1FBQ2xCO1FBRUEsSUFBSTtZQUNGWixRQUFRSSxHQUFHLENBQUM7WUFDWkosUUFBUUksR0FBRyxDQUFDLHNCQUFzQmEsY0FBY0MsU0FBUyxDQUFDQyxRQUFRO1lBRWxFLHdGQUF3RjtZQUN4RixNQUFNLEVBQUVkLE9BQU8sRUFBRSxHQUFHLE1BQU0sMExBQU87WUFDakMsTUFBTUMsY0FBY0QsUUFBUUUsUUFBUTtZQUVwQyw0RUFBNEU7WUFDNUVQLFFBQVFJLEdBQUcsQ0FBQztZQUNaLE1BQU0sRUFBRWdCLE9BQU8sRUFBRVYsWUFBWVcsVUFBVSxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUNiLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDSDtZQUVyRSxtRUFBbUU7WUFDbkUsdUZBQXVGO1lBQ3ZGTixRQUFRSSxHQUFHLENBQUM7WUFDWixNQUFNa0IsMEJBQTBCLElBQUlwRCxtRUFBaUJBLENBQ25EK0MsY0FBY0MsU0FBUyxFQUN2QkcsV0FBV1YsY0FBYyxFQUN6QlUsV0FBV0UsU0FBUyxFQUNwQkgsUUFBZ0MseUJBQXlCOztZQUczRCxvRUFBb0U7WUFDcEUsd0VBQXdFO1lBQ3hFLE1BQU1JLG1CQUFtQjtnQkFDdkIsR0FBR0gsVUFBVTtnQkFDYkgsV0FBV0QsY0FBY0MsU0FBUztnQkFDbENPLFlBQVlILHdCQUF3QkcsVUFBVTtnQkFDOUNDLGdCQUFnQkosd0JBQXdCSSxjQUFjO2dCQUN0RE47Z0JBQ0FILGVBQWVBLGNBQTBCLGlDQUFpQztZQUM1RTtZQUVBLGtEQUFrRDtZQUNsRCxJQUFJLENBQUNHLE9BQU8sR0FBR0E7WUFDZixJQUFJLENBQUNWLFVBQVUsR0FBR2M7WUFFbEJ4QixRQUFRSSxHQUFHLENBQUM7WUFDWkosUUFBUUksR0FBRyxDQUFDLHFDQUEyQixJQUFJLENBQUNNLFVBQVUsQ0FBQ2UsVUFBVTtZQUNqRXpCLFFBQVFJLEdBQUcsQ0FBQyxpQ0FBdUIsSUFBSSxDQUFDTSxVQUFVLENBQUNnQixjQUFjLENBQUNQLFFBQVE7WUFFMUVuQixRQUFRSSxHQUFHLENBQUM7WUFDWkosUUFBUUksR0FBRyxDQUFDLGFBQWEsSUFBSSxDQUFDZ0IsT0FBTztZQUNyQ3BCLFFBQVFJLEdBQUcsQ0FBQywyQkFBMkIsSUFBSSxDQUFDTSxVQUFVLENBQUNRLFNBQVMsQ0FBQ0MsUUFBUTtZQUN6RW5CLFFBQVFJLEdBQUcsQ0FBQyw0QkFBNEIsSUFBSSxDQUFDTSxVQUFVLENBQUNlLFVBQVU7WUFDbEV6QixRQUFRSSxHQUFHLENBQUMsZ0NBQWdDLElBQUksQ0FBQ00sVUFBVSxDQUFDZ0IsY0FBYyxDQUFDUCxRQUFRO1lBRW5GLDJCQUEyQjtZQUMzQixNQUFNUSxtQkFBbUIsSUFBSXhELG1EQUFzQixDQUFDUztZQUNwRCxJQUFJLENBQUNpRCxRQUFRLEdBQUcsSUFBSTFELDRDQUFlLENBQUNLLGtCQUFrQkQsb0JBQW9Cb0Q7WUFFMUUsMENBQTBDO1lBQzFDM0IsUUFBUUksR0FBRyxDQUFDO1lBQ1osSUFBSTtnQkFDRiwyRUFBMkU7Z0JBQzNFLE1BQU0yQixVQUFVLE1BQU1KLGlCQUFpQkssbUJBQW1CLENBQUMsSUFBSSxDQUFDdEIsVUFBVSxDQUFDZSxVQUFVO2dCQUNyRnpCLFFBQVFJLEdBQUcsQ0FBQywrQ0FBcUMyQjtnQkFFakQsSUFBSUEsVUFBVSxHQUFHO29CQUNmL0IsUUFBUUksR0FBRyxDQUFDO2dCQUNkLE9BQU87b0JBQ0xKLFFBQVFJLEdBQUcsQ0FBQztvQkFDWkosUUFBUUksR0FBRyxDQUFDO2dCQUNkO1lBQ0YsRUFBRSxPQUFPNkIsYUFBYTtnQkFDcEJqQyxRQUFRSSxHQUFHLENBQUMsb0NBQW9DNkI7WUFDbEQ7WUFFQSw4Q0FBOEM7WUFDOUMsSUFBSTtnQkFDRmpDLFFBQVFJLEdBQUcsQ0FBQyxrQ0FBa0M1QjtnQkFDOUMsTUFBTTBELE9BQU8sTUFBTVAsaUJBQWlCUSxPQUFPLENBQUMzRDtnQkFDNUN3QixRQUFRSSxHQUFHLENBQUMseUJBQXlCOEIsS0FBS0UsTUFBTTtnQkFDaEQsSUFBSUYsU0FBUyxNQUFNO29CQUNqQmxDLFFBQVFDLElBQUksQ0FBQyx5Q0FBeUN6QjtvQkFDdER3QixRQUFRSSxHQUFHLENBQUM7Z0JBQ2QsT0FBTztvQkFDTEosUUFBUUksR0FBRyxDQUFDO29CQUVaLDZEQUE2RDtvQkFDN0RKLFFBQVFJLEdBQUcsQ0FBQztvQkFDWkosUUFBUUksR0FBRyxDQUFDLHFCQUFxQixJQUFJLENBQUNNLFVBQVUsQ0FBQ2UsVUFBVTtvQkFDM0R6QixRQUFRSSxHQUFHLENBQUMsd0JBQXdCLElBQUksQ0FBQ00sVUFBVSxDQUFDUSxTQUFTLENBQUNDLFFBQVE7b0JBRXRFLG9FQUFvRTtvQkFDcEUsTUFBTWtCLHVCQUF1QixNQUFNLElBQUksQ0FBQ1IsUUFBUSxDQUFDUyxvQkFBb0IsQ0FBQyxJQUFJLENBQUM1QixVQUFVLENBQUNlLFVBQVU7b0JBQ2hHekIsUUFBUUksR0FBRyxDQUFDLDhDQUE4Q2lDO29CQUUxRCxNQUFNRSxtQkFBbUIsTUFBTSxJQUFJLENBQUNWLFFBQVEsQ0FBQ1csWUFBWSxDQUFDLElBQUksQ0FBQzlCLFVBQVUsQ0FBQ2UsVUFBVTtvQkFDcEZ6QixRQUFRSSxHQUFHLENBQUMscUNBQXFDbUM7b0JBRWpELElBQUksQ0FBQ0Esa0JBQWtCO3dCQUNyQnZDLFFBQVFDLElBQUksQ0FBQzt3QkFDYkQsUUFBUUksR0FBRyxDQUFDO3dCQUNaSixRQUFRSSxHQUFHLENBQUM7d0JBQ1pKLFFBQVFJLEdBQUcsQ0FBQzt3QkFFWixtRUFBbUU7d0JBQ25FLElBQUk7NEJBQ0YsTUFBTXFDLFVBQVUsTUFBTSxJQUFJLENBQUNDLFVBQVUsQ0FBQ0MsY0FBYyxDQUFDLElBQUksQ0FBQ2pDLFVBQVUsQ0FBQ2dCLGNBQWM7NEJBQ25GLElBQUllLFlBQVksTUFBTTtnQ0FDcEJ6QyxRQUFRSSxHQUFHLENBQUM7NEJBQ2QsT0FBTztnQ0FDTEosUUFBUUksR0FBRyxDQUFDOzRCQUNkO3dCQUNGLEVBQUUsT0FBT3dDLGNBQWM7NEJBQ3JCNUMsUUFBUUksR0FBRyxDQUFDLG9DQUFvQ3dDO3dCQUNsRDtvQkFDRixPQUFPO3dCQUNMNUMsUUFBUUksR0FBRyxDQUFDO29CQUNkO2dCQUNGO1lBQ0YsRUFBRSxPQUFPNkIsYUFBYTtnQkFDcEJqQyxRQUFRQyxJQUFJLENBQUMsOEJBQThCZ0M7WUFDN0M7UUFFRixFQUFFLE9BQU9sQyxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQywyQ0FBMkNBO1lBQ3pELE1BQU1BO1FBQ1I7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBTThDLGtCQUNKQyxrQkFBMEIsRUFDMUJDLFVBQW1CLEVBQ25CQyxXQUFtQixFQUMwQjtRQUM3QyxJQUFJLENBQUMsSUFBSSxDQUFDdEMsVUFBVSxJQUFJLENBQUMsSUFBSSxDQUFDbUIsUUFBUSxFQUFFO1lBQ3RDLE1BQU0sSUFBSWpCLE1BQU07UUFDbEI7UUFFQSxpREFBaUQ7UUFDakQsTUFBTXFDLGlCQUFpQkMsS0FBS0MsS0FBSyxDQUFDTCxxQkFBcUI7UUFFdkQsSUFBSTtnQkE2RDRDTSwrQkFpRTFDQyxpQkFLMkJBLGtCQUNJQSxrQkFDQ0Esc0JBQUFBLGtCQUNGQSxrQkFDTUEsa0JBQ1JBLGtCQUNVQSxrQkFHTEEsa0JBT2pDQTtZQWxKSixZQUFZO1lBQ1osNENBQTRDO1lBQzVDLElBQUlDLGFBQWFDLE9BQU8sTUFBTSxJQUFJLENBQUMvQyxRQUFRLENBQUN3QixtQkFBbUIsQ0FBQyxJQUFJLENBQUN0QixVQUFVLENBQUNlLFVBQVU7WUFDMUZ6QixRQUFRSSxHQUFHLENBQUMseUNBQXlDa0Q7WUFDckR0RCxRQUFRSSxHQUFHLENBQUMsK0JBQStCLElBQUksQ0FBQ29ELGFBQWE7WUFFN0QsMERBQTBEO1lBQzFELElBQUlDLFFBQVFQLEtBQUtRLEdBQUcsQ0FBQ0osWUFBWSxJQUFJLENBQUNFLGFBQWEsR0FBRztZQUN0RHhELFFBQVFJLEdBQUcsQ0FBQyxxQkFBcUJxRDtZQUVqQywyQkFBMkI7WUFDM0IsSUFBSSxDQUFDRCxhQUFhLEdBQUdDO1lBQ3JCekQsUUFBUUksR0FBRyxDQUFDLHVCQUF1QnFEO1lBRW5DLDZCQUE2QjtZQUM3QixNQUFNRSxRQUFRLElBQUl4Riw2Q0FBZ0IsQ0FBQ0k7WUFDbkMsTUFBTXNGLE9BQU9GLE1BQU1HLGtCQUFrQixDQUFDLDJCQUEyQjtnQkFDL0RiO2dCQUNBRjtnQkFDQUM7YUFDRDtZQUVELDBCQUEwQjtZQUMxQixNQUFNZSxrQkFBa0I7Z0JBQ3RCQyxNQUFNLElBQUksQ0FBQ3RELFVBQVUsQ0FBQ2UsVUFBVTtnQkFDaEN3QyxJQUFJekY7Z0JBQ0pxRixNQUFNQTtZQUNSO1lBRUEsZUFBZTtZQUNmLE1BQU1LLGlCQUFpQixNQUFNLElBQUksQ0FBQzFELFFBQVEsQ0FBQzJELCtCQUErQixDQUFDO2dCQUN6RUMsYUFBYSxJQUFJLENBQUMxRCxVQUFVLENBQUNRLFNBQVM7Z0JBQ3RDbUQsY0FBYztvQkFBQ047aUJBQWdCO1lBQ2pDO1lBRUEsK0JBQStCO1lBQy9CLElBQUksRUFBRVgsb0JBQW9CLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQzVDLFFBQVEsQ0FBQzhELDBCQUEwQixDQUFDO2dCQUM1RUo7Z0JBQ0FIO2dCQUNBTjtZQUNGO1lBRUEsb0RBQW9EO1lBQ3BELE1BQU1oQixVQUFVLE1BQU0sSUFBSSxDQUFDQyxVQUFVLENBQUNDLGNBQWMsQ0FBQyxJQUFJLENBQUNqQyxVQUFVLENBQUNnQixjQUFjO1lBQ25GLElBQUllLFlBQVksTUFBTTtnQkFDcEJXLHFCQUFxQm1CLFlBQVksQ0FBQ0MsT0FBTyxDQUN2Q3ZHLHFGQUErQkEsQ0FDN0IsSUFBSSxDQUFDeUMsVUFBVSxDQUFDQyxjQUFjLEVBQzlCLElBQUksQ0FBQ0QsVUFBVSxDQUFDUSxTQUFTLEVBQ3pCLElBQUksQ0FBQ1IsVUFBVSxDQUFDZSxVQUFVLEVBQzFCLElBQUksQ0FBQ0wsT0FBTztZQUdsQjtZQUVBLDREQUE0RDtZQUM1RCxNQUFNLEVBQUVxRCxTQUFTLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQy9CLFVBQVUsQ0FBQ2dDLGtCQUFrQjtZQUM5RHRCLHFCQUFxQnVCLGVBQWUsR0FBR0Y7WUFFdkN6RSxRQUFRSSxHQUFHLENBQUM7WUFDWkosUUFBUUksR0FBRyxDQUFDLG1CQUFtQmIsS0FBS0MsU0FBUyxDQUFDNEQsRUFBQUEsZ0NBQUFBLHFCQUFxQndCLE9BQU8sY0FBNUJ4QixvREFBQUEsOEJBQThCeUIsR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxRQUFRLFFBQU87WUFFdEcsMkVBQTJFO1lBQzNFLG9IQUFvSDtZQUNwSCwwQ0FBMEM7WUFDMUMsTUFBTUMsV0FBVyxNQUFNLElBQUksQ0FBQ3RFLFVBQVUsQ0FBQ08sYUFBYSxDQUFDZ0UsZUFBZSxDQUFDN0I7WUFFckUsNkNBQTZDO1lBQzdDcEQsUUFBUUksR0FBRyxDQUFDO1lBQ1osTUFBTSxJQUFJLENBQUNzQyxVQUFVLENBQUN3QyxrQkFBa0IsQ0FBQ0YsU0FBU0csU0FBUyxJQUFJO2dCQUM3REMsZUFBZTtnQkFDZkMscUJBQXFCO1lBQ3ZCO1lBRUEsNkNBQTZDO1lBQzdDLE1BQU1DLG9CQUFvQixNQUFNLElBQUksQ0FBQzlFLFFBQVEsQ0FBQytFLDRCQUE0QixDQUN4RSxJQUFJLENBQUM3RSxVQUFVLENBQUNlLFVBQVUsRUFDMUJnQyxPQUNBLE1BQU0sb0JBQW9COztZQUc1QnpELFFBQVFJLEdBQUcsQ0FBQyx1QkFBdUJrRjtZQUVuQyxJQUFJQSxrQkFBa0JsRCxNQUFNLEtBQUssR0FBRztnQkFDbEMsTUFBTSxJQUFJeEIsTUFBTTtZQUNsQjtZQUVBLE1BQU00RSxXQUFXRixpQkFBaUIsQ0FBQyxFQUFFO1lBQ3JDdEYsUUFBUUksR0FBRyxDQUFDLGlDQUFpQ29GLFNBQVNDLE1BQU07WUFFNUQsSUFBSUQsU0FBU0MsTUFBTSxLQUFLLGNBQWM7Z0JBQ3BDekYsUUFBUUMsSUFBSSxDQUFDO2dCQUNiRCxRQUFRSSxHQUFHLENBQUM7Z0JBQ1pKLFFBQVFJLEdBQUcsQ0FBQyxxQkFBcUJvRixTQUFTRSxlQUFlO2dCQUV6RCxpRkFBaUY7Z0JBQ2pGLGlFQUFpRTtnQkFDakUxRixRQUFRSSxHQUFHLENBQUM7Z0JBRVosT0FBTztvQkFDTHVGLFFBQVFILFNBQVNFLGVBQWU7b0JBQ2hDRSxRQUFRSixTQUFTRSxlQUFlO2dCQUNsQztZQUVGLE9BQU8sSUFBSUYsU0FBU0MsTUFBTSxLQUFLLFVBQVU7Z0JBQ3ZDLE1BQU0sSUFBSTdFLE1BQU0sdUNBQWdFLE9BQXpCNEUsU0FBU0UsZUFBZTtZQUNqRixPQUFPLElBQUlGLFNBQVNDLE1BQU0sS0FBSyxXQUFXO2dCQUN4Q3pGLFFBQVFDLElBQUksQ0FBQyxnREFBZ0R1RixTQUFTQyxNQUFNO2dCQUM1RSwrREFBK0Q7Z0JBQy9ELE9BQU87b0JBQ0xFLFFBQVFILFNBQVNFLGVBQWU7b0JBQ2hDRSxRQUFRSixTQUFTRSxlQUFlO2dCQUNsQztZQUNGO1lBRUEsTUFBTUUsU0FBU04saUJBQWlCLENBQUMsRUFBRSxDQUFDSSxlQUFlO1lBQ25EMUYsUUFBUUksR0FBRyxDQUFDLHFCQUFxQndGO1lBRWpDLDJDQUEyQztZQUMzQyxNQUFNdkMsVUFBVSxNQUFNLElBQUksQ0FBQzdDLFFBQVEsQ0FBQ3FGLHFCQUFxQixDQUFDRDtZQUMxRDVGLFFBQVFJLEdBQUcsQ0FBQyw2QkFBNkJiLEtBQUtDLFNBQVMsQ0FBQzZELFNBQVMsTUFBTTtZQUV2RSxJQUFJc0MsU0FBUztZQUViLDBDQUEwQztZQUMxQyxJQUFJdEMsRUFBQUEsa0JBQUFBLFFBQVF6RCxNQUFNLGNBQWR5RCxzQ0FBQUEsZ0JBQWdCb0MsTUFBTSxNQUFLLE9BQU87b0JBQ2NwQztnQkFBbEQsTUFBTSxJQUFJekMsTUFBTSxvQ0FBa0N5QyxvQkFBQUEsUUFBUXpELE1BQU0sY0FBZHlELHdDQUFBQSxrQkFBZ0JvQyxNQUFNO1lBQzFFO1lBRUEsOENBQThDO1lBQzlDekYsUUFBUUksR0FBRyxDQUFDLG9CQUFtQmlELG1CQUFBQSxRQUFRekQsTUFBTSxjQUFkeUQsdUNBQUFBLGlCQUFnQm9DLE1BQU07WUFDckR6RixRQUFRSSxHQUFHLENBQUMsd0JBQXVCaUQsbUJBQUFBLFFBQVF6RCxNQUFNLGNBQWR5RCx1Q0FBQUEsaUJBQWdCeUMsSUFBSTtZQUN2RDlGLFFBQVFJLEdBQUcsQ0FBQyx5QkFBd0JpRCxtQkFBQUEsUUFBUXpELE1BQU0sY0FBZHlELHdDQUFBQSx1QkFBQUEsaUJBQWdCeUMsSUFBSSxjQUFwQnpDLDJDQUFBQSxxQkFBc0JqQixNQUFNO1lBQ2hFcEMsUUFBUUksR0FBRyxDQUFDLHVCQUFzQmlELG1CQUFBQSxRQUFRekQsTUFBTSxjQUFkeUQsdUNBQUFBLGlCQUFnQjBDLFNBQVM7WUFDM0QvRixRQUFRSSxHQUFHLENBQUMsNkJBQTRCaUQsbUJBQUFBLFFBQVF6RCxNQUFNLGNBQWR5RCx1Q0FBQUEsaUJBQWdCMkMsZUFBZTtZQUN2RWhHLFFBQVFJLEdBQUcsQ0FBQyxxQkFBb0JpRCxtQkFBQUEsUUFBUXpELE1BQU0sY0FBZHlELHVDQUFBQSxpQkFBZ0I0QyxPQUFPO1lBQ3ZEakcsUUFBUUksR0FBRyxDQUFDLCtCQUE4QmlELG1CQUFBQSxRQUFRekQsTUFBTSxjQUFkeUQsdUNBQUFBLGlCQUFnQjZDLGlCQUFpQjtZQUUzRSxpREFBaUQ7WUFDakRsRyxRQUFRSSxHQUFHLENBQUMsMEJBQXlCaUQsbUJBQUFBLFFBQVF6RCxNQUFNLGNBQWR5RCx1Q0FBQUEsaUJBQWdCOEMsa0JBQWtCO1lBRXZFLCtEQUErRDtZQUMvRCxpREFBaUQ7WUFFakQsK0NBQStDO1lBQy9DLE1BQU1DLGNBQXFCLEVBQUU7WUFDN0IsS0FBSS9DLG1CQUFBQSxRQUFRekQsTUFBTSxjQUFkeUQsdUNBQUFBLGlCQUFnQmdELGtCQUFrQixFQUFFO2dCQUN0QyxLQUFLLE1BQU1DLFNBQVNqRCxRQUFRekQsTUFBTSxDQUFDeUcsa0JBQWtCLENBQUU7b0JBQ3JELElBQUlDLE1BQU1DLGtCQUFrQixFQUFFO3dCQUM1QixLQUFLLE1BQU1DLGVBQWVGLE1BQU1DLGtCQUFrQixDQUFFOzRCQUNsRCxJQUFJQyxZQUFZQyxRQUFRLElBQUlELFlBQVlDLFFBQVEsQ0FBQ3JFLE1BQU0sR0FBRyxHQUFHO2dDQUMzRGdFLFlBQVlNLElBQUksSUFBSUYsWUFBWUMsUUFBUTs0QkFDMUM7d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7WUFDRjtZQUVBekcsUUFBUUksR0FBRyxDQUFDLFNBQVNnRyxZQUFZaEUsTUFBTSxFQUFFO1lBRXpDLG9EQUFvRDtZQUNwRCxJQUFJZ0UsWUFBWWhFLE1BQU0sR0FBRyxHQUFHO2dCQUMxQixLQUFLLE1BQU1oQyxPQUFPZ0csWUFBYTtvQkFDN0IsSUFBSTt3QkFDRnBHLFFBQVFJLEdBQUcsQ0FBQyw0QkFBNEJBO3dCQUV4Qyx5Q0FBeUM7d0JBQ3pDLElBQUlBLElBQUl1RyxPQUFPLENBQUNDLFdBQVcsT0FBT3BJLGlCQUFpQm9JLFdBQVcsSUFBSTs0QkFDaEU1RyxRQUFRSSxHQUFHLENBQUM7NEJBRVosbURBQW1EOzRCQUNuRCxNQUFNeUcsWUFBWTtnQ0FDaEJGLFNBQVN2RyxJQUFJdUcsT0FBTztnQ0FDcEI5QyxNQUFNekQsSUFBSXlELElBQUk7Z0NBQ2RpRCxRQUFRMUcsSUFBSTBHLE1BQU07NEJBQ3BCOzRCQUVBLE1BQU1DLFlBQVlwRCxNQUFNcUQsUUFBUSxDQUFDSDs0QkFDakM3RyxRQUFRSSxHQUFHLENBQUMsZUFBZTJHOzRCQUUzQixJQUFJQSxDQUFBQSxzQkFBQUEsZ0NBQUFBLFVBQVdFLElBQUksTUFBSyxxQkFBcUI7Z0NBQzNDdEIsU0FBU29CLFVBQVVHLElBQUksQ0FBQ3ZCLE1BQU07Z0NBQzlCM0YsUUFBUUksR0FBRyxDQUFDLGlEQUFpRHVGO2dDQUM3RDs0QkFDRjt3QkFDRixPQUFPOzRCQUNMM0YsUUFBUUksR0FBRyxDQUFDLGdDQUFnQ0EsSUFBSXVHLE9BQU87d0JBQ3pEO29CQUNGLEVBQUUsT0FBT1EsR0FBRzt3QkFDVm5ILFFBQVFJLEdBQUcsQ0FBQyw0QkFBNEIrRztvQkFDeEMsaUNBQWlDO29CQUNuQztnQkFDRjtZQUNGLE9BQU87Z0JBQ0xuSCxRQUFRQyxJQUFJLENBQUM7Z0JBQ2JELFFBQVFJLEdBQUcsQ0FBQztnQkFDWkosUUFBUUksR0FBRyxDQUFDO2dCQUNaSixRQUFRSSxHQUFHLENBQUM7Z0JBQ1pKLFFBQVFJLEdBQUcsQ0FBQztnQkFDWkosUUFBUUksR0FBRyxDQUFDO2dCQUVaLDBFQUEwRTtnQkFDMUUsSUFBSTtvQkFDRkosUUFBUUksR0FBRyxDQUFDO29CQUNaLE1BQU1nSCxXQUFXLE1BQU0sSUFBSSxDQUFDdkYsUUFBUSxDQUFFd0Ysb0JBQW9CLENBQUN6QjtvQkFDM0Q1RixRQUFRSSxHQUFHLENBQUMseUJBQXlCZ0g7Z0JBQ3ZDLEVBQUUsT0FBT0UsV0FBVztvQkFDbEJ0SCxRQUFRSSxHQUFHLENBQUMseUJBQXlCa0g7Z0JBQ3ZDO1lBQ0Y7WUFFQSx3REFBd0Q7WUFDeEQsSUFBSSxDQUFDM0IsUUFBUTtvQkFNUHRDLG1CQWlCb0NBO2dCQXRCeENyRCxRQUFRRCxLQUFLLENBQUM7Z0JBQ2RDLFFBQVFJLEdBQUcsQ0FBQztnQkFFWiw2Q0FBNkM7Z0JBQzdDSixRQUFRSSxHQUFHLENBQUM7Z0JBQ1osS0FBSWlELG9CQUFBQSxRQUFRekQsTUFBTSxjQUFkeUQsd0NBQUFBLGtCQUFnQmtFLGNBQWMsRUFBRTtvQkFDbEN2SCxRQUFRSSxHQUFHLENBQUMsc0JBQXNCaUQsUUFBUXpELE1BQU0sQ0FBQzJILGNBQWM7b0JBQy9ELElBQUk7d0JBQ0Ysa0NBQWtDO3dCQUNsQyxNQUFNQyxlQUFlckosZ0RBQW1CLENBQUNrRixRQUFRekQsTUFBTSxDQUFDMkgsY0FBYzt3QkFDdEV2SCxRQUFRSSxHQUFHLENBQUMsa0JBQWtCb0g7d0JBQzlCLE1BQU0sSUFBSTVHLE1BQU0sMkJBQXdDLE9BQWI0RztvQkFDN0MsRUFBRSxPQUFPRSxhQUFhO3dCQUNwQjFILFFBQVFJLEdBQUcsQ0FBQyxtQ0FBbUNzSDt3QkFDL0MsTUFBTSxJQUFJOUcsTUFBTTtvQkFDbEI7Z0JBQ0Y7Z0JBRUEsdURBQXVEO2dCQUN2RFosUUFBUUksR0FBRyxDQUFDO2dCQUNaSixRQUFRSSxHQUFHLENBQUMscUJBQXFCNUI7Z0JBQ2pDd0IsUUFBUUksR0FBRyxDQUFDLGlCQUFpQixJQUFJLENBQUNNLFVBQVUsQ0FBQ2UsVUFBVTtnQkFDdkR6QixRQUFRSSxHQUFHLENBQUMsNkJBQTRCaUQsb0JBQUFBLFFBQVF6RCxNQUFNLGNBQWR5RCx3Q0FBQUEsa0JBQWdCOEMsa0JBQWtCO2dCQUUxRSw4QkFBOEI7Z0JBQzlCLElBQUk7b0JBQ0YsTUFBTXdCLGVBQWUsTUFBTSxJQUFJLENBQUM5RixRQUFRLENBQUVXLFlBQVksQ0FBQyxJQUFJLENBQUM5QixVQUFVLENBQUNlLFVBQVU7b0JBQ2pGekIsUUFBUUksR0FBRyxDQUFDLHNDQUFzQ3VIO29CQUVsRCxJQUFJLENBQUNBLGNBQWM7d0JBQ2pCLE1BQU0sSUFBSS9HLE1BQU07b0JBQ2xCO2dCQUNGLEVBQUUsT0FBT2dILG1CQUFtQjtvQkFDMUI1SCxRQUFRRCxLQUFLLENBQUMsc0NBQXNDNkg7b0JBQ3BELE1BQU1BO2dCQUNSO2dCQUVBLDRDQUE0QztnQkFDNUMsTUFBTSxJQUFJaEgsTUFBTTtZQUNsQjtZQUVBLE9BQU87Z0JBQ0wrRTtnQkFDQUM7WUFDRjtRQUNGLEVBQUUsT0FBTzdGLE9BQVk7WUFDbkJDLFFBQVFELEtBQUssQ0FBQyxnQ0FBZ0NBO1lBQzlDLE1BQU1BO1FBQ1I7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBYzhILHVCQUFzQztRQUNsRCxJQUFJLENBQUMsSUFBSSxDQUFDaEcsUUFBUSxFQUFFO1lBQ2xCLHdEQUF3RDtZQUN4RCxNQUFNRixtQkFBbUIsSUFBSXhELG1EQUFzQixDQUFDUztZQUNwRCxJQUFJLENBQUNpRCxRQUFRLEdBQUcsSUFBSTFELDRDQUFlLENBQUNLLGtCQUFrQkQsb0JBQW9Cb0Q7UUFDNUU7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBTW1HLGVBQWVuQyxNQUFjLEVBQXdCO1FBQ3pELDBDQUEwQztRQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDOUQsUUFBUSxFQUFFO1lBQ2xCLE1BQU0sSUFBSSxDQUFDZ0csb0JBQW9CO1FBQ2pDO1FBRUE3SCxRQUFRSSxHQUFHLENBQUMsaUNBQWlDdUY7UUFDN0MzRixRQUFRSSxHQUFHLENBQUMscUJBQXFCNUI7UUFFakMsSUFBSTtZQUNGLE1BQU1vQixTQUFTLE1BQU0sSUFBSSxDQUFDaUMsUUFBUSxDQUFFd0Ysb0JBQW9CLENBQUMxQjtZQUN6RDNGLFFBQVFJLEdBQUcsQ0FBQyx3QkFBd0JSO1lBRXBDLE1BQU1tSSxjQUFjO2dCQUNsQkMsWUFBWXBJLE9BQU9vSSxVQUFVO2dCQUM3QkMsZUFBZXJJLE9BQU9xSSxhQUFhO2dCQUNuQ0MsUUFBUXRJLE9BQU9zSSxNQUFNO2dCQUNyQm5GLFlBQVluRCxPQUFPbUQsVUFBVTtnQkFDN0JvRixVQUFVdkksT0FBT3VJLFFBQVE7Z0JBQ3pCQyxlQUFleEksT0FBT3dJLGFBQWE7Z0JBQ25DQyxjQUFjOUUsT0FBTzNELE9BQU95SSxZQUFZO2dCQUN4Q3JGLGFBQWFwRCxPQUFPb0QsV0FBVztZQUNqQztZQUVBLHNGQUFzRjtZQUN0RixJQUFJcEQsT0FBT29JLFVBQVUsS0FBSyxnREFDdEJwSSxPQUFPc0ksTUFBTSxLQUFLSSxPQUFPLE1BQ3pCLENBQUMxSSxPQUFPdUksUUFBUSxFQUFFO2dCQUNwQm5JLFFBQVFDLElBQUksQ0FBQztnQkFFYix5RkFBeUY7Z0JBQ3pGLElBQUkwRixPQUFPdkQsTUFBTSxLQUFLLE1BQU11RCxPQUFPNEMsVUFBVSxDQUFDLE9BQU87b0JBQ25EdkksUUFBUUksR0FBRyxDQUFDO29CQUNaSixRQUFRSSxHQUFHLENBQUM7b0JBQ1pKLFFBQVFJLEdBQUcsQ0FBQztvQkFFWiw4RUFBOEU7b0JBQzlFSixRQUFRSSxHQUFHLENBQUM7Z0JBQ2Q7WUFDRjtZQUVBLE9BQU8ySDtRQUNULEVBQUUsT0FBT2hJLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLHdCQUF3QkE7WUFDdEMsTUFBTSxJQUFJYSxNQUFNO1FBQ2xCO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE1BQU00SCxhQUFhQyxjQUFzQixFQUFxQjtRQUM1RCwwQ0FBMEM7UUFDMUMsSUFBSSxDQUFDLElBQUksQ0FBQzVHLFFBQVEsRUFBRTtZQUNsQixNQUFNLElBQUksQ0FBQ2dHLG9CQUFvQjtRQUNqQztRQUVBLElBQUk7WUFDRixPQUFPLE1BQU0sSUFBSSxDQUFDaEcsUUFBUSxDQUFFNkcsa0JBQWtCLENBQUNEO1FBQ2pELEVBQUUsT0FBTzFJLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLDZCQUE2QkE7WUFDM0MsT0FBTyxFQUFFO1FBQ1g7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBTTRJLFFBQ0poRCxNQUFjLEVBQ2RpRCxTQUFpQixFQUN3QztRQUN6RCxJQUFJLENBQUMsSUFBSSxDQUFDbEksVUFBVSxJQUFJLENBQUMsSUFBSSxDQUFDbUIsUUFBUSxFQUFFO1lBQ3RDLE1BQU0sSUFBSWpCLE1BQU07UUFDbEI7UUFFQVosUUFBUUksR0FBRyxDQUFDO1FBQ1pKLFFBQVFJLEdBQUcsQ0FBQyxZQUFZdUY7UUFDeEIzRixRQUFRSSxHQUFHLENBQUMsZUFBZXdJO1FBRTNCLDREQUE0RDtRQUM1RCxNQUFNQyxXQUFXLE1BQU0sSUFBSSxDQUFDZixjQUFjLENBQUNuQztRQUMzQzNGLFFBQVFJLEdBQUcsQ0FBQyxzQkFBc0J5STtRQUVsQyxJQUFJLENBQUNBLFNBQVNWLFFBQVEsRUFBRTtZQUN0QixNQUFNLElBQUl2SCxNQUFNO1FBQ2xCO1FBRUEsMEJBQTBCO1FBQzFCLE1BQU1xQyxpQkFBaUJDLEtBQUtDLEtBQUssQ0FBQ3lGLFlBQVk7UUFFOUMsSUFBSUU7UUFFSixJQUFJO2dCQWMyQkMsa0JBa0pHekQscUJBR3RCQTtZQWxLVixnREFBZ0Q7WUFDaER0RixRQUFRSSxHQUFHLENBQUM7WUFDWkosUUFBUUksR0FBRyxDQUFDLFNBQVMsSUFBSSxDQUFDTSxVQUFVLENBQUNRLFNBQVMsQ0FBQ0MsUUFBUTtZQUN2RG5CLFFBQVFJLEdBQUcsQ0FBQyx5QkFBeUJ5SSxTQUFTWixhQUFhO1lBQzNEakksUUFBUUksR0FBRyxDQUFDLG9CQUFvQjZDO1lBRWhDLDZEQUE2RDtZQUM3RCxnQ0FBZ0M7WUFDaEMsTUFBTThGLFlBQVlGLFNBQVNaLGFBQWEsQ0FBQ00sVUFBVSxDQUFDLFFBQ2hETSxTQUFTWixhQUFhLENBQUNlLEtBQUssQ0FBQyxLQUM3QkgsU0FBU1osYUFBYTtZQUUxQixtQ0FBbUM7WUFDbkMsTUFBTWdCLFFBQVEsSUFBSUMsV0FBV0gsRUFBQUEsbUJBQUFBLFVBQVVJLEtBQUssQ0FBQyxzQkFBaEJKLHVDQUFBQSxpQkFBMEJsRSxHQUFHLENBQUN1RSxDQUFBQSxPQUFRdEosU0FBU3NKLE1BQU0sU0FBUSxFQUFFO1lBRTVGLG1GQUFtRjtZQUNuRix3RkFBd0Y7WUFDeEYsSUFBSUM7WUFFSixJQUFJSixNQUFNN0csTUFBTSxLQUFLLElBQUk7Z0JBQ3ZCLGtDQUFrQztnQkFDbENpSCxrQkFBa0IsSUFBSSxDQUFDLE1BQU0sMExBQXdCLEVBQUd0TCxTQUFTLENBQUNrTDtZQUNwRSxPQUFPLElBQUlBLE1BQU03RyxNQUFNLEdBQUcsSUFBSTtnQkFDNUIsd0NBQXdDO2dCQUN4QyxNQUFNa0gsY0FBY0wsTUFBTUQsS0FBSyxDQUFDLENBQUM7Z0JBQ2pDSyxrQkFBa0IsSUFBSSxDQUFDLE1BQU0sMExBQXdCLEVBQUd0TCxTQUFTLENBQUN1TDtZQUNwRSxPQUFPO2dCQUNMLG9DQUFvQztnQkFDcEMsTUFBTUMsY0FBYyxJQUFJTCxXQUFXO2dCQUNuQ0ssWUFBWUMsR0FBRyxDQUFDUCxPQUFPLEtBQUtBLE1BQU03RyxNQUFNO2dCQUN4Q2lILGtCQUFrQixJQUFJLENBQUMsTUFBTSwwTEFBd0IsRUFBR3RMLFNBQVMsQ0FBQ3dMO1lBQ3BFO1lBRUF2SixRQUFRSSxHQUFHLENBQUMsd0JBQXdCaUosZ0JBQWdCbEksUUFBUTtZQUU1RCxzQ0FBc0M7WUFDdEMsTUFBTSxFQUFFc0ksYUFBYSxFQUFFQyxXQUFXLEVBQUUsR0FBRyxNQUFNLDBMQUFPO1lBRXBELDhCQUE4QjtZQUM5QixNQUFNQyxhQUFhRixjQUFjRyxRQUFRLENBQUM7Z0JBQ3hDQyxZQUFZLElBQUksQ0FBQ25KLFVBQVUsQ0FBQ1EsU0FBUztnQkFDckM0SSxVQUFVVDtnQkFDVlUsVUFBVTlHO1lBQ1o7WUFFQSxxQkFBcUI7WUFDckIsTUFBTStHLGFBQWEsSUFBSU4sY0FBY08sR0FBRyxDQUFDTjtZQUV6QyxrREFBa0Q7WUFDbEQzSixRQUFRSSxHQUFHLENBQUM7WUFDWixNQUFNLEVBQUVxRSxTQUFTLEVBQUV5RixzQkFBc0JDLG1CQUFtQixFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUN6SCxVQUFVLENBQUNnQyxrQkFBa0IsQ0FBQztZQUMxRzFFLFFBQVFJLEdBQUcsQ0FBQyxpQ0FBaUNxRTtZQUM3Q3pFLFFBQVFJLEdBQUcsQ0FBQyw0QkFBNEIrSjtZQUV4Q0gsV0FBV3JGLGVBQWUsR0FBR0Y7WUFDN0J1RixXQUFXSSxRQUFRLEdBQUcsSUFBSSxDQUFDMUosVUFBVSxDQUFDUSxTQUFTO1lBRS9DLDZDQUE2QztZQUM3Q2xCLFFBQVFJLEdBQUcsQ0FBQztZQUNaLE1BQU1pSyxtQkFBbUIsTUFBTSxJQUFJLENBQUMzSixVQUFVLENBQUNPLGFBQWEsQ0FBQ2dFLGVBQWUsQ0FBQytFO1lBQzdFbEIsb0JBQW9CLE1BQU0sSUFBSSxDQUFDcEcsVUFBVSxDQUFDd0Msa0JBQWtCLENBQUNtRixpQkFBaUJsRixTQUFTLElBQUk7Z0JBQ3pGQyxlQUFlO2dCQUNmQyxxQkFBcUI7WUFDdkI7WUFFQXJGLFFBQVFJLEdBQUcsQ0FBQyxzQkFBc0IwSTtZQUVsQyxzREFBc0Q7WUFDdEQsTUFBTSxJQUFJLENBQUNwRyxVQUFVLENBQUM0SCxrQkFBa0IsQ0FBQztnQkFDdkNDLFdBQVd6QjtnQkFDWCxHQUFJLE1BQU0sSUFBSSxDQUFDcEcsVUFBVSxDQUFDZ0Msa0JBQWtCLEVBQUU7WUFDaEQ7WUFDQTFFLFFBQVFJLEdBQUcsQ0FBQztZQUVaLDZDQUE2QztZQUM3Q0osUUFBUUksR0FBRyxDQUFDO1lBRVosc0NBQXNDO1lBQ3RDLE1BQU1vSyxxQkFBcUJuTSxvREFBWUEsQ0FBQ0QsK0NBQU9BLENBQUMsSUFBSSxDQUFDc0MsVUFBVSxDQUFDUSxTQUFTLENBQUN1SixPQUFPLEtBQUs7WUFFdEYsWUFBWTtZQUNaLDRDQUE0QztZQUM1QyxJQUFJbkgsYUFBYUMsT0FBTyxNQUFNLElBQUksQ0FBQy9DLFFBQVEsQ0FBQ3dCLG1CQUFtQixDQUFDLElBQUksQ0FBQ3RCLFVBQVUsQ0FBQ2UsVUFBVTtZQUMxRnpCLFFBQVFJLEdBQUcsQ0FBQyx5Q0FBeUNrRDtZQUNyRHRELFFBQVFJLEdBQUcsQ0FBQywrQkFBK0IsSUFBSSxDQUFDb0QsYUFBYTtZQUU3RCwwREFBMEQ7WUFDMUQsSUFBSUMsUUFBUVAsS0FBS1EsR0FBRyxDQUFDSixZQUFZLElBQUksQ0FBQ0UsYUFBYSxHQUFHO1lBQ3REeEQsUUFBUUksR0FBRyxDQUFDLHFCQUFxQnFEO1lBRWpDLDJCQUEyQjtZQUMzQixJQUFJLENBQUNELGFBQWEsR0FBR0M7WUFDckJ6RCxRQUFRSSxHQUFHLENBQUMsdUJBQXVCcUQ7WUFFbkMsNkJBQTZCO1lBQzdCLE1BQU1FLFFBQVEsSUFBSXhGLDZDQUFnQixDQUFDSTtZQUNuQyxNQUFNc0YsT0FBT0YsTUFBTUcsa0JBQWtCLENBQUMsaUJBQWlCO2dCQUNyRDZCO2dCQUNBMUM7Z0JBQ0F1SDthQUNEO1lBRUQsMEJBQTBCO1lBQzFCLE1BQU16RyxrQkFBa0I7Z0JBQ3RCQyxNQUFNLElBQUksQ0FBQ3RELFVBQVUsQ0FBQ2UsVUFBVTtnQkFDaEN3QyxJQUFJekY7Z0JBQ0pxRixNQUFNQTtZQUNSO1lBRUEsZUFBZTtZQUNmLE1BQU1LLGlCQUFpQixNQUFNLElBQUksQ0FBQzFELFFBQVEsQ0FBQzJELCtCQUErQixDQUFDO2dCQUN6RUMsYUFBYSxJQUFJLENBQUMxRCxVQUFVLENBQUNRLFNBQVM7Z0JBQ3RDbUQsY0FBYztvQkFBQ047aUJBQWdCO1lBQ2pDO1lBRUEsK0JBQStCO1lBQy9CLElBQUksRUFBRVgsb0JBQW9CLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQzVDLFFBQVEsQ0FBQzhELDBCQUEwQixDQUFDO2dCQUM1RUo7Z0JBQ0FIO2dCQUNBTjtZQUNGO1lBRUEsa0RBQWtEO1lBQ2xEekQsUUFBUUksR0FBRyxDQUFDO1lBQ1osTUFBTSxFQUFFcUUsV0FBV2lHLGlCQUFpQixFQUFFUixzQkFBc0JTLG1CQUFtQixFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUNqSSxVQUFVLENBQUNnQyxrQkFBa0IsQ0FBQztZQUM3SDFFLFFBQVFJLEdBQUcsQ0FBQyxrQ0FBa0NzSztZQUM5QzFLLFFBQVFJLEdBQUcsQ0FBQyw0QkFBNEJ1SztZQUV4Q3ZILHFCQUFxQnVCLGVBQWUsR0FBRytGO1lBQ3ZDdEgscUJBQXFCZ0gsUUFBUSxHQUFHLElBQUksQ0FBQzFKLFVBQVUsQ0FBQ1EsU0FBUztZQUV6RCw4REFBOEQ7WUFDOUQsb0hBQW9IO1lBQ3BILDBDQUEwQztZQUMxQ2xCLFFBQVFJLEdBQUcsQ0FBQztZQUNaLE1BQU00RSxXQUFXLE1BQU0sSUFBSSxDQUFDdEUsVUFBVSxDQUFDTyxhQUFhLENBQUNnRSxlQUFlLENBQUM3QjtZQUVyRSwrQkFBK0I7WUFDL0JwRCxRQUFRSSxHQUFHLENBQUM7WUFDWixNQUFNLElBQUksQ0FBQ3NDLFVBQVUsQ0FBQ3dDLGtCQUFrQixDQUFDRixTQUFTRyxTQUFTLElBQUk7Z0JBQzdEQyxlQUFlO2dCQUNmQyxxQkFBcUI7WUFDdkI7WUFFQSw2Q0FBNkM7WUFDN0MsTUFBTUMsb0JBQW9CLE1BQU0sSUFBSSxDQUFDOUUsUUFBUSxDQUFDK0UsNEJBQTRCLENBQ3hFLElBQUksQ0FBQzdFLFVBQVUsQ0FBQ2UsVUFBVSxFQUMxQmdDLE9BQ0E7WUFHRixJQUFJNkIsa0JBQWtCbEQsTUFBTSxLQUFLLEtBQUtrRCxpQkFBaUIsQ0FBQyxFQUFFLENBQUNHLE1BQU0sS0FBSyxXQUFXO2dCQUMvRXpGLFFBQVFDLElBQUksQ0FBQztnQkFDYkQsUUFBUUksR0FBRyxDQUFDLHVCQUF1QjBJO1lBQ25DLHdFQUF3RTtZQUMxRTtZQUVBOUksUUFBUUksR0FBRyxDQUFDO1lBQ1pKLFFBQVFJLEdBQUcsQ0FBQyxpQkFBaUIwSTtZQUM3QjlJLFFBQVFJLEdBQUcsQ0FBQyxxQkFBb0JrRixzQkFBQUEsaUJBQWlCLENBQUMsRUFBRSxjQUFwQkEsMENBQUFBLG9CQUFzQkksZUFBZTtZQUVyRSxPQUFPO2dCQUNMRSxRQUFRTixFQUFBQSx1QkFBQUEsaUJBQWlCLENBQUMsRUFBRSxjQUFwQkEsMkNBQUFBLHFCQUFzQkksZUFBZSxLQUFJO2dCQUNqRG9EO1lBQ0Y7UUFDRixFQUFFLE9BQU8vSSxPQUFZO1lBQ25CQyxRQUFRRCxLQUFLLENBQUMsc0JBQXNCQTtZQUNwQyxJQUFJK0ksbUJBQW1CO2dCQUNyQjlJLFFBQVFJLEdBQUcsQ0FBQywwQ0FBMEMwSTtZQUN4RDtZQUNBLE1BQU0vSTtRQUNSO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE1BQU02SyxlQUFlakYsTUFBYyxFQUErQjtRQUNoRSxJQUFJLENBQUMsSUFBSSxDQUFDakYsVUFBVSxJQUFJLENBQUMsSUFBSSxDQUFDbUIsUUFBUSxFQUFFO1lBQ3RDLE1BQU0sSUFBSWpCLE1BQU07UUFDbEI7UUFFQSxJQUFJO1lBQ0YsWUFBWTtZQUNaLDRDQUE0QztZQUM1QyxJQUFJMEMsYUFBYUMsT0FBTyxNQUFNLElBQUksQ0FBQy9DLFFBQVEsQ0FBQ3dCLG1CQUFtQixDQUFDLElBQUksQ0FBQ3RCLFVBQVUsQ0FBQ2UsVUFBVTtZQUMxRnpCLFFBQVFJLEdBQUcsQ0FBQyx5Q0FBeUNrRDtZQUNyRHRELFFBQVFJLEdBQUcsQ0FBQywrQkFBK0IsSUFBSSxDQUFDb0QsYUFBYTtZQUU3RCwwREFBMEQ7WUFDMUQsSUFBSUMsUUFBUVAsS0FBS1EsR0FBRyxDQUFDSixZQUFZLElBQUksQ0FBQ0UsYUFBYSxHQUFHO1lBQ3REeEQsUUFBUUksR0FBRyxDQUFDLHFCQUFxQnFEO1lBRWpDLDJCQUEyQjtZQUMzQixJQUFJLENBQUNELGFBQWEsR0FBR0M7WUFDckJ6RCxRQUFRSSxHQUFHLENBQUMsdUJBQXVCcUQ7WUFFbkMsNkJBQTZCO1lBQzdCLE1BQU1FLFFBQVEsSUFBSXhGLDZDQUFnQixDQUFDSTtZQUNuQyxNQUFNc0YsT0FBT0YsTUFBTUcsa0JBQWtCLENBQUMsd0JBQXdCO2dCQUFDNkI7YUFBTztZQUV0RSwwQkFBMEI7WUFDMUIsTUFBTTVCLGtCQUFrQjtnQkFDdEJDLE1BQU0sSUFBSSxDQUFDdEQsVUFBVSxDQUFDZSxVQUFVO2dCQUNoQ3dDLElBQUl6RjtnQkFDSnFGLE1BQU1BO1lBQ1I7WUFFQSxlQUFlO1lBQ2YsTUFBTUssaUJBQWlCLE1BQU0sSUFBSSxDQUFDMUQsUUFBUSxDQUFDMkQsK0JBQStCLENBQUM7Z0JBQ3pFQyxhQUFhLElBQUksQ0FBQzFELFVBQVUsQ0FBQ1EsU0FBUztnQkFDdENtRCxjQUFjO29CQUFDTjtpQkFBZ0I7WUFDakM7WUFFQSwrQkFBK0I7WUFDL0IsSUFBSSxFQUFFWCxvQkFBb0IsRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDNUMsUUFBUSxDQUFDOEQsMEJBQTBCLENBQUM7Z0JBQzVFSjtnQkFDQUg7Z0JBQ0FOO1lBQ0Y7WUFFQSxrREFBa0Q7WUFDbER6RCxRQUFRSSxHQUFHLENBQUM7WUFDWixNQUFNLEVBQUVxRSxTQUFTLEVBQUV5RixzQkFBc0JXLHFCQUFxQixFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUNuSSxVQUFVLENBQUNnQyxrQkFBa0IsQ0FBQztZQUM1RzFFLFFBQVFJLEdBQUcsQ0FBQywrQkFBK0JxRTtZQUMzQ3pFLFFBQVFJLEdBQUcsQ0FBQyw0QkFBNEJ5SztZQUV4Q3pILHFCQUFxQnVCLGVBQWUsR0FBR0Y7WUFDdkNyQixxQkFBcUJnSCxRQUFRLEdBQUcsSUFBSSxDQUFDMUosVUFBVSxDQUFDUSxTQUFTO1lBRXpELDhEQUE4RDtZQUM5RCxvSEFBb0g7WUFDcEgsMENBQTBDO1lBQzFDbEIsUUFBUUksR0FBRyxDQUFDO1lBQ1osTUFBTTRFLFdBQVcsTUFBTSxJQUFJLENBQUN0RSxVQUFVLENBQUNPLGFBQWEsQ0FBQ2dFLGVBQWUsQ0FBQzdCO1lBRXJFLCtCQUErQjtZQUMvQnBELFFBQVFJLEdBQUcsQ0FBQztZQUNaLE1BQU0sSUFBSSxDQUFDc0MsVUFBVSxDQUFDd0Msa0JBQWtCLENBQUNGLFNBQVNHLFNBQVMsSUFBSTtnQkFDN0RDLGVBQWU7Z0JBQ2ZDLHFCQUFxQjtZQUN2QjtZQUVBLGlDQUFpQztZQUNqQyxNQUFNQyxvQkFBb0IsTUFBTSxJQUFJLENBQUM5RSxRQUFRLENBQUMrRSw0QkFBNEIsQ0FDeEUsSUFBSSxDQUFDN0UsVUFBVSxDQUFDZSxVQUFVLEVBQzFCZ0MsT0FDQTtZQUdGLElBQUk2QixrQkFBa0JsRCxNQUFNLEtBQUssS0FBS2tELGlCQUFpQixDQUFDLEVBQUUsQ0FBQ0csTUFBTSxLQUFLLFdBQVc7Z0JBQy9FLE1BQU0sSUFBSTdFLE1BQU07WUFDbEI7WUFFQSxPQUFPO2dCQUNMZ0YsUUFBUU4saUJBQWlCLENBQUMsRUFBRSxDQUFDSSxlQUFlO1lBQzlDO1FBQ0YsRUFBRSxPQUFPM0YsT0FBWTtZQUNuQixNQUFNQTtRQUNSO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEK0ssaUJBQWlCbkYsTUFBYyxFQUFVO1FBQ3ZDLE9BQU8sR0FBaUNBLE9BQTlCb0YsT0FBT0MsUUFBUSxDQUFDQyxNQUFNLEVBQUMsU0FBYyxPQUFQdEY7SUFDMUM7SUFFQTs7R0FFQyxHQUNELE9BQU91RixxQkFBcUJDLEdBQVcsRUFBaUI7UUFDdEQsSUFBSTtZQUNGLE1BQU1DLFNBQVMsSUFBSUMsSUFBSUY7WUFDdkIsT0FBT0MsT0FBT0UsWUFBWSxDQUFDQyxHQUFHLENBQUM7UUFDakMsRUFBRSxVQUFNO1lBQ04sT0FBTztRQUNUO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEQyxvQkFBbUM7WUFDMUI7UUFBUCxPQUFPLHlCQUFJLENBQUM5SyxVQUFVLGNBQWYsd0RBQWlCZSxVQUFVLEtBQUk7SUFDeEM7SUE5M0JBZ0ssYUFBYzthQUpOckssVUFBeUI7YUFDekJTLFdBQW1DO2FBQ25DMkIsZ0JBQXdCLENBQUM7UUFHL0IsSUFBSSxDQUFDZCxVQUFVLEdBQUcsSUFBSTVFLHVEQUFVQSxDQUFDaUIsZ0JBQWdCO1FBQ2pELElBQUksQ0FBQ3lCLFFBQVEsR0FBRyxJQUFJeEMsaUVBQWVBLENBQUNjO0lBQ3RDO0FBNDNCRjtBQUVBLDRCQUE0QjtBQUNyQixNQUFNNE0sdUJBQXVCLElBQUkxTSx1QkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvc29sYW5hLW5hdGl2ZS1jb250cmFjdC50cz9kNGM2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbm5lY3Rpb24sIFB1YmxpY0tleSwgS2V5cGFpciB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcydcbmltcG9ydCB7IE5lb25Qcm94eVJwY0FwaSwgY3JlYXRlQmFsYW5jZUFjY291bnRJbnN0cnVjdGlvbiwgU29sYW5hTmVvbkFjY291bnQgfSBmcm9tICdAbmVvbmV2bS9zb2xhbmEtc2lnbidcbmltcG9ydCB7IGV0aGVycywgaGV4bGlmeSwgemVyb1BhZFZhbHVlIH0gZnJvbSAnZXRoZXJzJ1xuaW1wb3J0IENvbnRyYWN0QUJJIGZyb20gJy4vY29udHJhY3RBQkkuanNvbidcblxuLy8gVXNlIHRoZSBhY3R1YWwgZGVwbG95ZWQgY29udHJhY3QgQUJJXG5jb25zdCBTT0xBTkFfVElQQ0FSRF9BQkkgPSBDb250cmFjdEFCSVxuXG5jb25zdCBDT05UUkFDVF9BRERSRVNTID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfVElQQ0FSRF9DT05UUkFDVF9BRERSRVNTIHx8ICcweENGRTAzYzdjNjc0NTZEMDk0QzAxNjJGOTAzMDM5M0ZDMmNDYzQwQ2InXG5jb25zdCBORU9OX0NPUkVfUlBDX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX05FT05fUlBDX1VSTCB8fCAnaHR0cHM6Ly9kZXZuZXQubmVvbmV2bS5vcmcnXG5jb25zdCBORU9OX1BST1hZX1JQQ19VUkwgPSBgJHtORU9OX0NPUkVfUlBDX1VSTH0vc29sYFxuY29uc3QgU09MQU5BX1JQQ19VUkwgPSAnaHR0cHM6Ly9hcGkuZGV2bmV0LnNvbGFuYS5jb20nXG5cbmV4cG9ydCBpbnRlcmZhY2UgUGF5bWVudExpbmsge1xuICBldm1DcmVhdG9yOiBzdHJpbmdcbiAgc29sYW5hQ3JlYXRvcjogc3RyaW5nXG4gIGFtb3VudDogYmlnaW50XG4gIGlzRmxleGlibGU6IGJvb2xlYW5cbiAgaXNBY3RpdmU6IGJvb2xlYW5cbiAgdG90YWxSZWNlaXZlZDogYmlnaW50XG4gIHBheW1lbnRDb3VudDogbnVtYmVyXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcbn1cblxuZXhwb3J0IGNsYXNzIFNvbGFuYU5hdGl2ZUNvbnRyYWN0IHtcbiAgcHJpdmF0ZSBjb25uZWN0aW9uOiBDb25uZWN0aW9uXG4gIHByaXZhdGUgcHJveHlBcGk6IE5lb25Qcm94eVJwY0FwaVxuICBwcml2YXRlIHNvbGFuYVVzZXI6IGFueVxuICBwcml2YXRlIGNoYWluSWQ6IG51bWJlciB8IG51bGwgPSBudWxsXG4gIHByaXZhdGUgY29udHJhY3Q6IGV0aGVycy5Db250cmFjdCB8IG51bGwgPSBudWxsXG4gIHByaXZhdGUgbGFzdFVzZWROb25jZTogbnVtYmVyID0gLTFcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdGlvbihTT0xBTkFfUlBDX1VSTCwgJ2NvbmZpcm1lZCcpXG4gICAgdGhpcy5wcm94eUFwaSA9IG5ldyBOZW9uUHJveHlScGNBcGkoTkVPTl9QUk9YWV9SUENfVVJMKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBOZW9uIEVWTSBjaGFpbiBJRFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZXRDaGFpbklkKCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFVzZSB0aGUgcHJveHkgQVBJIHRvIGdldCBjaGFpbiBpbmZvcm1hdGlvblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChORU9OX1BST1hZX1JQQ19VUkwsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgbWV0aG9kOiAnZXRoX2NoYWluSWQnLFxuICAgICAgICAgIHBhcmFtczogW11cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgIHJldHVybiBwYXJzZUludChyZXN1bHQucmVzdWx0LCAxNikgLy8gQ29udmVydCBoZXggdG8gZGVjaW1hbFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBnZXQgY2hhaW4gSUQsIHVzaW5nIGRlZmF1bHQ6JywgZXJyb3IpXG4gICAgICByZXR1cm4gMjQ1MDIyOTI3IC8vIE5lb24gRGV2bmV0IGRlZmF1bHRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IE5lb24gRVZNIHByb2dyYW0gYWRkcmVzcyB1c2luZyBhIHRlbXBvcmFyeSBpbml0aWFsaXphdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZXROZW9uRXZtUHJvZ3JhbSgpOiBQcm9taXNlPFB1YmxpY0tleT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnQXR0ZW1wdGluZyB0byBnZXQgTmVvbiBFVk0gcHJvZ3JhbSB2aWEgdGVtcG9yYXJ5IGtleXBhaXIgaW5pdGlhbGl6YXRpb24uLi4nKVxuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSB0ZW1wb3Jhcnkga2V5cGFpciBqdXN0IHRvIGdldCB0aGUgcHJvZ3JhbSBpbmZvcm1hdGlvblxuICAgICAgY29uc3QgeyBLZXlwYWlyIH0gPSBhd2FpdCBpbXBvcnQoJ0Bzb2xhbmEvd2ViMy5qcycpXG4gICAgICBjb25zdCB0ZW1wS2V5cGFpciA9IEtleXBhaXIuZ2VuZXJhdGUoKVxuICAgICAgXG4gICAgICAvLyBVc2UgdGhlIGV4aXN0aW5nIHByb3h5QXBpIHRvIGdldCB0aGUgaW5mb3JtYXRpb25cbiAgICAgIGNvbnN0IGluaXRSZXN1bHQgPSBhd2FpdCB0aGlzLnByb3h5QXBpLmluaXQodGVtcEtleXBhaXIpXG4gICAgICBjb25zb2xlLmxvZygnVGVtcG9yYXJ5IGluaXQgcmVzdWx0OicsIGluaXRSZXN1bHQpXG4gICAgICBcbiAgICAgIGlmIChpbml0UmVzdWx0LnNvbGFuYVVzZXI/Lm5lb25Fdm1Qcm9ncmFtKSB7XG4gICAgICAgIHJldHVybiBpbml0UmVzdWx0LnNvbGFuYVVzZXIubmVvbkV2bVByb2dyYW1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gbmVvbkV2bVByb2dyYW0gaW4gaW5pdCByZXN1bHQnKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1RlbXBvcmFyeSBpbml0IGZhaWxlZCwgdHJ5aW5nIGRpcmVjdCBBUEkgY2FsbDonLCBlcnJvcilcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gZGlyZWN0IEFQSSBjYWxsXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goTkVPTl9QUk9YWV9SUENfVVJMLCB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgIG1ldGhvZDogJ25lb25fZ2V0RXZtUGFyYW1zJyxcbiAgICAgICAgICAgIHBhcmFtczogW11cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKCdEaXJlY3QgQVBJIHJlc3BvbnNlOicsIHJlc3VsdClcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGRpZmZlcmVudCBwb3NzaWJsZSByZXNwb25zZSBzdHJ1Y3R1cmVzXG4gICAgICAgIGxldCBwcm9ncmFtQWRkcmVzc1xuICAgICAgICBpZiAocmVzdWx0LnJlc3VsdD8ubmVvbkV2bVByb2dyYW0pIHtcbiAgICAgICAgICBwcm9ncmFtQWRkcmVzcyA9IHJlc3VsdC5yZXN1bHQubmVvbkV2bVByb2dyYW1cbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQucmVzdWx0Py5wcm9ncmFtSWQpIHtcbiAgICAgICAgICBwcm9ncmFtQWRkcmVzcyA9IHJlc3VsdC5yZXN1bHQucHJvZ3JhbUlkXG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LnJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0LnJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBwcm9ncmFtQWRkcmVzcyA9IHJlc3VsdC5yZXN1bHRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgcmVzcG9uc2Ugc3RydWN0dXJlJylcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coJ0V4dHJhY3RlZCBwcm9ncmFtIGFkZHJlc3M6JywgcHJvZ3JhbUFkZHJlc3MpXG4gICAgICAgIHJldHVybiBuZXcgUHVibGljS2V5KHByb2dyYW1BZGRyZXNzKVxuICAgICAgfSBjYXRjaCAoYXBpRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdEaXJlY3QgQVBJIGNhbGwgYWxzbyBmYWlsZWQsIHVzaW5nIGRlZmF1bHQ6JywgYXBpRXJyb3IpXG4gICAgICAgIC8vIERlZmF1bHQgTmVvbiBFVk0gcHJvZ3JhbSBmb3IgZGV2bmV0XG4gICAgICAgIHJldHVybiBuZXcgUHVibGljS2V5KCdlZUxTSmdXenp4cnFLdjFVeHRSVlZIOEZYM3FDUVdVczlRdUFqSnBFVEdTbScpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgd2l0aCBTb2xhbmEgd2FsbGV0IHVzaW5nIHRoZSBleGFjdCBzYW1lIHBhdHRlcm4gYXMgdGVzdHNcbiAgICovXG4gIGFzeW5jIGluaXRXaXRoU29sYW5hV2FsbGV0KHdhbGxldEFkYXB0ZXI6IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghd2FsbGV0QWRhcHRlci5wdWJsaWNLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBjb25uZWN0ZWQnKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+UpyBVc2luZyBleGFjdCB0ZXN0IHBhdHRlcm4gd2l0aCB3YWxsZXQgYWRhcHRlci4uLicpXG4gICAgICBjb25zb2xlLmxvZygnV2FsbGV0IHB1YmxpYyBrZXk6Jywgd2FsbGV0QWRhcHRlci5wdWJsaWNLZXkudG9CYXNlNTgoKSlcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IGtleXBhaXIgZm9yIGluaXRpYWxpemF0aW9uLCB0aGVuIG92ZXJyaWRlIHdpdGggd2FsbGV0J3MgcHVibGljIGtleVxuICAgICAgY29uc3QgeyBLZXlwYWlyIH0gPSBhd2FpdCBpbXBvcnQoJ0Bzb2xhbmEvd2ViMy5qcycpXG4gICAgICBjb25zdCB0ZW1wS2V5cGFpciA9IEtleXBhaXIuZ2VuZXJhdGUoKVxuICAgICAgXG4gICAgICAvLyBVc2UgdGhlIGV4YWN0IHNhbWUgaW5pdGlhbGl6YXRpb24gcGF0dGVybiBhcyB0aGUgdGVzdCAod2l0aCB0ZW1wIGtleXBhaXIpXG4gICAgICBjb25zb2xlLmxvZygnSW5pdGlhbGl6aW5nIHdpdGggcHJveHkgQVBJIChzYW1lIGFzIHRlc3QgcGF0dGVybikuLi4nKVxuICAgICAgY29uc3QgeyBjaGFpbklkLCBzb2xhbmFVc2VyOiB0ZW1wUmVzdWx0IH0gPSBhd2FpdCB0aGlzLnByb3h5QXBpLmluaXQodGVtcEtleXBhaXIpXG4gICAgICBcbiAgICAgIC8vIFJlY2FsY3VsYXRlIHRoZSBFVk0gYWRkcmVzcyB1c2luZyB0aGUgd2FsbGV0J3MgYWN0dWFsIHB1YmxpYyBrZXlcbiAgICAgIC8vIFRoZSBFVk0gYWRkcmVzcyBzaG91bGQgYmUgZGVyaXZlZCBmcm9tIHRoZSB3YWxsZXQncyBwdWJsaWMga2V5LCBub3QgdGhlIHRlbXAga2V5cGFpclxuICAgICAgY29uc29sZS5sb2coJ1JlY2FsY3VsYXRpbmcgRVZNIGFkZHJlc3MgZm9yIHdhbGxldCBwdWJsaWMga2V5Li4uJylcbiAgICAgIGNvbnN0IGFjdHVhbFNvbGFuYU5lb25BY2NvdW50ID0gbmV3IFNvbGFuYU5lb25BY2NvdW50KFxuICAgICAgICB3YWxsZXRBZGFwdGVyLnB1YmxpY0tleSwgICAgICAgIC8vIFVzZSB3YWxsZXQncyBhY3R1YWwgcHVibGljIGtleVxuICAgICAgICB0ZW1wUmVzdWx0Lm5lb25Fdm1Qcm9ncmFtLCAgICAgIC8vIEtlZXAgdGhlIHNhbWUgTmVvbiBFVk0gcHJvZ3JhbVxuICAgICAgICB0ZW1wUmVzdWx0LnRva2VuTWludCwgICAgICAgICAgIC8vIFVzZSB0aGUgdG9rZW4gbWludCBmcm9tIHRlbXAgcmVzdWx0XG4gICAgICAgIGNoYWluSWQgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCB0aGUgc2FtZSBjaGFpbiBJRFxuICAgICAgKVxuICAgICAgXG4gICAgICAvLyBOb3cgY3JlYXRlIHRoZSBwcm9wZXIgc29sYW5hVXNlciBvYmplY3QgdXNpbmcgd2FsbGV0J3MgcHVibGljIGtleVxuICAgICAgLy8gYnV0IGtlZXBpbmcgYWxsIHRoZSBvdGhlciBkZXJpdmVkIHZhbHVlcyBmcm9tIHRoZSB0ZW1wIGluaXRpYWxpemF0aW9uXG4gICAgICBjb25zdCB3YWxsZXRTb2xhbmFVc2VyID0ge1xuICAgICAgICAuLi50ZW1wUmVzdWx0LCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvcHkgYWxsIHByb3h5IEFQSSByZXN1bHRzXG4gICAgICAgIHB1YmxpY0tleTogd2FsbGV0QWRhcHRlci5wdWJsaWNLZXksICAgICAgLy8gT3ZlcnJpZGUgd2l0aCB3YWxsZXQncyBhY3R1YWwgcHVibGljIGtleVxuICAgICAgICBuZW9uV2FsbGV0OiBhY3R1YWxTb2xhbmFOZW9uQWNjb3VudC5uZW9uV2FsbGV0LCAgICAgLy8gVXNlIHJlY2FsY3VsYXRlZCBFVk0gYWRkcmVzc1xuICAgICAgICBiYWxhbmNlQWRkcmVzczogYWN0dWFsU29sYW5hTmVvbkFjY291bnQuYmFsYW5jZUFkZHJlc3MsIC8vIFVzZSByZWNhbGN1bGF0ZWQgYmFsYW5jZSBhZGRyZXNzXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIHdhbGxldEFkYXB0ZXI6IHdhbGxldEFkYXB0ZXIgICAgICAgICAgICAgLy8gQWRkIHdhbGxldCBhZGFwdGVyIGZvciBzaWduaW5nXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFN0b3JlIHRoZSByZXN1bHQgaW4gdGhlIHNhbWUgc3RydWN0dXJlIGFzIHRlc3RzXG4gICAgICB0aGlzLmNoYWluSWQgPSBjaGFpbklkXG4gICAgICB0aGlzLnNvbGFuYVVzZXIgPSB3YWxsZXRTb2xhbmFVc2VyXG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgV2FsbGV0IGluaXRpYWxpemVkIHVzaW5nIHRlc3QgcGF0dGVybiEnKVxuICAgICAgY29uc29sZS5sb2coJ/Cfk40gRGVyaXZlZCBFVk0gYWRkcmVzczonLCB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldClcbiAgICAgIGNvbnNvbGUubG9nKCfwn5KwIEJhbGFuY2UgYWRkcmVzczonLCB0aGlzLnNvbGFuYVVzZXIuYmFsYW5jZUFkZHJlc3MudG9CYXNlNTgoKSlcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ05lb24gU0RLIGluaXRpYWxpemVkIHdpdGggd2FsbGV0IGFkYXB0ZXIgKHVzaW5nIFNvbGFuYU5lb25BY2NvdW50KScpXG4gICAgICBjb25zb2xlLmxvZygnQ2hhaW4gSUQ6JywgdGhpcy5jaGFpbklkKVxuICAgICAgY29uc29sZS5sb2coJ1NvbGFuYSBVc2VyIFB1YmxpYyBLZXk6JywgdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleS50b0Jhc2U1OCgpKVxuICAgICAgY29uc29sZS5sb2coJ1NvbGFuYSBVc2VyIE5lb24gV2FsbGV0OicsIHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0KVxuICAgICAgY29uc29sZS5sb2coJ1NvbGFuYSBVc2VyIEJhbGFuY2UgQWRkcmVzczonLCB0aGlzLnNvbGFuYVVzZXIuYmFsYW5jZUFkZHJlc3MudG9CYXNlNTgoKSlcblxuICAgICAgLy8gQ3JlYXRlIGNvbnRyYWN0IGluc3RhbmNlXG4gICAgICBjb25zdCByZWFkT25seVByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoTkVPTl9DT1JFX1JQQ19VUkwpXG4gICAgICB0aGlzLmNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChDT05UUkFDVF9BRERSRVNTLCBTT0xBTkFfVElQQ0FSRF9BQkksIHJlYWRPbmx5UHJvdmlkZXIpXG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSB0aGUgZGVyaXZlZCBFVk0gYWRkcmVzcyBpcyB2YWxpZFxuICAgICAgY29uc29sZS5sb2coJ/CflI0gVmVyaWZ5aW5nIGRlcml2ZWQgRVZNIGFkZHJlc3MuLi4nKVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBFVk0gYWRkcmVzcyBoYXMgYmVlbiB1c2VkIGJlZm9yZSAoaGFzIHRyYW5zYWN0aW9uIGhpc3RvcnkpXG4gICAgICAgIGNvbnN0IHR4Q291bnQgPSBhd2FpdCByZWFkT25seVByb3ZpZGVyLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQpXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OKIEVWTSBhZGRyZXNzIHRyYW5zYWN0aW9uIGNvdW50OicsIHR4Q291bnQpXG4gICAgICAgIFxuICAgICAgICBpZiAodHhDb3VudCA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIFRoaXMgRVZNIGFkZHJlc3MgaGFzIHRyYW5zYWN0aW9uIGhpc3RvcnkgLSBpdCBleGlzdHMgb24tY2hhaW4hJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygn4oS577iPIFRoaXMgRVZNIGFkZHJlc3MgaXMgbmV3IChubyB0cmFuc2FjdGlvbiBoaXN0b3J5IHlldCknKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCfihLnvuI8gVGhlIGFkZHJlc3Mgd2lsbCBiZSByZWdpc3RlcmVkIG9uLWNoYWluIHdoZW4gZmlyc3QgdHJhbnNhY3Rpb24gaXMgbWFkZScpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHZlcmlmeUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gQ291bGQgbm90IHZlcmlmeSBFVk0gYWRkcmVzczonLCB2ZXJpZnlFcnJvcilcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IGNvbnRyYWN0IGlzIGRlcGxveWVkIGF0IHRoaXMgYWRkcmVzc1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coJ1ZlcmlmeWluZyBjb250cmFjdCBhdCBhZGRyZXNzOicsIENPTlRSQUNUX0FERFJFU1MpXG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCByZWFkT25seVByb3ZpZGVyLmdldENvZGUoQ09OVFJBQ1RfQUREUkVTUylcbiAgICAgICAgY29uc29sZS5sb2coJ0NvbnRyYWN0IGNvZGUgbGVuZ3RoOicsIGNvZGUubGVuZ3RoKVxuICAgICAgICBpZiAoY29kZSA9PT0gJzB4Jykge1xuICAgICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIE5vIGNvbnRyYWN0IGNvZGUgZm91bmQgYXQgYWRkcmVzczonLCBDT05UUkFDVF9BRERSRVNTKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCdUaGlzIG1pZ2h0IG1lYW4gdGhlIGNvbnRyYWN0IGlzIG5vdCBkZXBsb3llZCBvciBhZGRyZXNzIGlzIGluY29ycmVjdCcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBDb250cmFjdCBmb3VuZCBhdCBhZGRyZXNzJylcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBpZiB1c2VyJ3MgU29sYW5hIGFkZHJlc3MgaXMgcmVnaXN0ZXJlZCB3aXRoIE5lb24gRVZNXG4gICAgICAgICAgY29uc29sZS5sb2coJ0NoZWNraW5nIFNvbGFuYSB1c2VyIHJlZ2lzdHJhdGlvbi4uLicpXG4gICAgICAgICAgY29uc29sZS5sb2coJ1VzZXIgRVZNIGFkZHJlc3M6JywgdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQpXG4gICAgICAgICAgY29uc29sZS5sb2coJ1VzZXIgU29sYW5hIGFkZHJlc3M6JywgdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleS50b0Jhc2U1OCgpKVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdldCB0aGUgU29sYW5hIGFkZHJlc3MgdGhhdCBOZW9uIEVWTSBoYXMgcmVnaXN0ZXJlZCBmb3IgdGhpcyB1c2VyXG4gICAgICAgICAgY29uc3QgcmVnaXN0ZXJlZFNvbGFuYUFkZHIgPSBhd2FpdCB0aGlzLmNvbnRyYWN0LmdldFNvbGFuYVVzZXJBZGRyZXNzKHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0KVxuICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWdpc3RlcmVkIFNvbGFuYSBhZGRyZXNzIChmcm9tIGNvbnRyYWN0KTonLCByZWdpc3RlcmVkU29sYW5hQWRkcilcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBpc1VzZXJSZWdpc3RlcmVkID0gYXdhaXQgdGhpcy5jb250cmFjdC5pc1NvbGFuYVVzZXIodGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQpXG4gICAgICAgICAgY29uc29sZS5sb2coJ0lzIHVzZXIgcmVnaXN0ZXJlZCB3aXRoIGNvbnRyYWN0OicsIGlzVXNlclJlZ2lzdGVyZWQpXG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCFpc1VzZXJSZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBVc2VyIGlzIG5vdCByZWdpc3RlcmVkIGFzIFNvbGFuYSB1c2VyIHdpdGggTmVvbiBFVk0nKVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1RoaXMgbWF5IGhhcHBlbiBpZiB0aGUgU29sYW5hIE5hdGl2ZSBTREsgaW5pdGlhbGl6YXRpb24gZGlkIG5vdCBjb21wbGV0ZSBwcm9wZXJseScpXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVGhlIFNESyBzaG91bGQgYXV0b21hdGljYWxseSByZWdpc3RlciB0aGUgdXNlciBkdXJpbmcgaW5pdCgpIGNhbGwnKVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0F0dGVtcHRpbmcgdG8gY3JlYXRlIGJhbGFuY2UgYWNjb3VudCB0byBjb21wbGV0ZSByZWdpc3RyYXRpb24uLi4nKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBUcnkgdG8gY3JlYXRlIHRoZSBiYWxhbmNlIGFjY291bnQgd2hpY2ggc2hvdWxkIHJlZ2lzdGVyIHRoZSB1c2VyXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldEFjY291bnRJbmZvKHRoaXMuc29sYW5hVXNlci5iYWxhbmNlQWRkcmVzcylcbiAgICAgICAgICAgICAgaWYgKGFjY291bnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQmFsYW5jZSBhY2NvdW50IGRvZXMgbm90IGV4aXN0LCB3aWxsIGNyZWF0ZSBpdCBvbiBmaXJzdCB0cmFuc2FjdGlvbicpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0JhbGFuY2UgYWNjb3VudCBleGlzdHMsIHVzZXIgc2hvdWxkIGJlIHJlZ2lzdGVyZWQnKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChiYWxhbmNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0NvdWxkIG5vdCBjaGVjayBiYWxhbmNlIGFjY291bnQ6JywgYmFsYW5jZUVycm9yKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIFVzZXIgaXMgcHJvcGVybHkgcmVnaXN0ZXJlZCcpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoICh2ZXJpZnlFcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byB2ZXJpZnkgY29udHJhY3Q6JywgdmVyaWZ5RXJyb3IpXG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgU29sYW5hIE5hdGl2ZSBTREs6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBwYXltZW50IGxpbmsgdXNpbmcgU29sYW5hIE5hdGl2ZSBTREtcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVBheW1lbnRMaW5rKFxuICAgIHN1Z2dlc3RlZEFtb3VudFNPTDogbnVtYmVyLFxuICAgIGlzRmxleGlibGU6IGJvb2xlYW4sXG4gICAgZGVzY3JpcHRpb246IHN0cmluZ1xuICApOiBQcm9taXNlPHsgbGlua0lkOiBzdHJpbmc7IHR4SGFzaDogc3RyaW5nIH0+IHtcbiAgICBpZiAoIXRoaXMuc29sYW5hVXNlciB8fCAhdGhpcy5jb250cmFjdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgY29ubmVjdCB3YWxsZXQgZmlyc3QnKVxuICAgIH1cblxuICAgIC8vIENvbnZlcnQgU09MIHRvIGxhbXBvcnRzICgxIFNPTCA9IDFlOSBsYW1wb3J0cylcbiAgICBjb25zdCBhbW91bnRMYW1wb3J0cyA9IE1hdGguZmxvb3Ioc3VnZ2VzdGVkQW1vdW50U09MICogMWU5KVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBub25jZVxuICAgICAgLy8gRm9yY2Ugbm9uY2UgaW5jcmVtZW50YXRpb24gdG8gYXZvaWQgcmV1c2VcbiAgICAgIGxldCBjaGFpbk5vbmNlID0gTnVtYmVyKGF3YWl0IHRoaXMucHJveHlBcGkuZ2V0VHJhbnNhY3Rpb25Db3VudCh0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCkpXG4gICAgICBjb25zb2xlLmxvZygnQ2hhaW4gbm9uY2UgZnJvbSBnZXRUcmFuc2FjdGlvbkNvdW50OicsIGNoYWluTm9uY2UpXG4gICAgICBjb25zb2xlLmxvZygnTGFzdCB1c2VkIG5vbmNlIGluIHNlc3Npb246JywgdGhpcy5sYXN0VXNlZE5vbmNlKVxuICAgICAgXG4gICAgICAvLyBBbHdheXMgdXNlIGEgaGlnaGVyIG5vbmNlIHRoYW4gYm90aCBjaGFpbiBhbmQgbGFzdCB1c2VkXG4gICAgICBsZXQgbm9uY2UgPSBNYXRoLm1heChjaGFpbk5vbmNlLCB0aGlzLmxhc3RVc2VkTm9uY2UgKyAxKVxuICAgICAgY29uc29sZS5sb2coJ0NhbGN1bGF0ZWQgbm9uY2U6Jywgbm9uY2UpXG4gICAgICBcbiAgICAgIC8vIFRyYWNrIHRoaXMgbm9uY2UgYXMgdXNlZFxuICAgICAgdGhpcy5sYXN0VXNlZE5vbmNlID0gbm9uY2VcbiAgICAgIGNvbnNvbGUubG9nKCdGaW5hbCBub25jZSB0byB1c2U6Jywgbm9uY2UpXG5cbiAgICAgIC8vIFByZXBhcmUgY29udHJhY3QgY2FsbCBkYXRhXG4gICAgICBjb25zdCBpZmFjZSA9IG5ldyBldGhlcnMuSW50ZXJmYWNlKFNPTEFOQV9USVBDQVJEX0FCSSlcbiAgICAgIGNvbnN0IGRhdGEgPSBpZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoJ2NyZWF0ZVNvbGFuYVBheW1lbnRMaW5rJywgW1xuICAgICAgICBhbW91bnRMYW1wb3J0cyxcbiAgICAgICAgaXNGbGV4aWJsZSxcbiAgICAgICAgZGVzY3JpcHRpb25cbiAgICAgIF0pXG5cbiAgICAgIC8vIENyZWF0ZSB0cmFuc2FjdGlvbiBkYXRhXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkRhdGEgPSB7XG4gICAgICAgIGZyb206IHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0LFxuICAgICAgICB0bzogQ09OVFJBQ1RfQUREUkVTUyxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfVxuXG4gICAgICAvLyBFc3RpbWF0ZSBnYXNcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uR2FzID0gYXdhaXQgdGhpcy5wcm94eUFwaS5lc3RpbWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uR2FzKHtcbiAgICAgICAgc29sYW5hUGF5ZXI6IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXksXG4gICAgICAgIHRyYW5zYWN0aW9uczogW3RyYW5zYWN0aW9uRGF0YV0sXG4gICAgICB9KVxuXG4gICAgICAvLyBDcmVhdGUgc2NoZWR1bGVkIHRyYW5zYWN0aW9uXG4gICAgICBsZXQgeyBzY2hlZHVsZWRUcmFuc2FjdGlvbiB9ID0gYXdhaXQgdGhpcy5wcm94eUFwaS5jcmVhdGVTY2hlZHVsZWRUcmFuc2FjdGlvbih7XG4gICAgICAgIHRyYW5zYWN0aW9uR2FzLFxuICAgICAgICB0cmFuc2FjdGlvbkRhdGEsXG4gICAgICAgIG5vbmNlXG4gICAgICB9KVxuXG4gICAgICAvLyBDaGVjayBpZiBiYWxhbmNlIGFjY291bnQgZXhpc3RzLCBpZiBub3QgY3JlYXRlIGl0XG4gICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldEFjY291bnRJbmZvKHRoaXMuc29sYW5hVXNlci5iYWxhbmNlQWRkcmVzcylcbiAgICAgIGlmIChhY2NvdW50ID09PSBudWxsKSB7XG4gICAgICAgIHNjaGVkdWxlZFRyYW5zYWN0aW9uLmluc3RydWN0aW9ucy51bnNoaWZ0KFxuICAgICAgICAgIGNyZWF0ZUJhbGFuY2VBY2NvdW50SW5zdHJ1Y3Rpb24oXG4gICAgICAgICAgICB0aGlzLnNvbGFuYVVzZXIubmVvbkV2bVByb2dyYW0sXG4gICAgICAgICAgICB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LFxuICAgICAgICAgICAgdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsXG4gICAgICAgICAgICB0aGlzLmNoYWluSWQhXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIFNpZ24gYW5kIHNlbmQgdHJhbnNhY3Rpb24gKGV4YWN0bHkgbGlrZSB3b3JraW5nIGV4YW1wbGVzKVxuICAgICAgY29uc3QgeyBibG9ja2hhc2ggfSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goKVxuICAgICAgc2NoZWR1bGVkVHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoXG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdTaWduaW5nIHdpdGggd2FsbGV0IGFkYXB0ZXIuLi4nKVxuICAgICAgY29uc29sZS5sb2coJ1NpZ25lcnMgbmVlZGVkOicsIEpTT04uc3RyaW5naWZ5KHNjaGVkdWxlZFRyYW5zYWN0aW9uLnNpZ25lcnM/Lm1hcChzID0+IHMudG9TdHJpbmcoKSkgfHwgJ25vbmUnKSlcbiAgICAgIFxuICAgICAgLy8gU2lnbiB0cmFuc2FjdGlvbiB1c2luZyB3YWxsZXQgYWRhcHRlciBpbnN0ZWFkIG9mIGtleXBhaXIgKGxpa2UgaW4gdGVzdHMpXG4gICAgICAvLyBJbiB0ZXN0czogc2NoZWR1bGVkVHJhbnNhY3Rpb24uc2lnbih7IHB1YmxpY0tleTogc29sYW5hVXNlci5wdWJsaWNLZXksIHNlY3JldEtleTogc29sYW5hVXNlci5rZXlwYWlyLnNlY3JldEtleSB9KVxuICAgICAgLy8gSW4gZnJvbnRlbmQ6IHVzZSB3YWxsZXQgYWRhcHRlciBzaWduaW5nXG4gICAgICBjb25zdCBzaWduZWRUeCA9IGF3YWl0IHRoaXMuc29sYW5hVXNlci53YWxsZXRBZGFwdGVyLnNpZ25UcmFuc2FjdGlvbihzY2hlZHVsZWRUcmFuc2FjdGlvbilcbiAgICAgIFxuICAgICAgLy8gU2VuZCB0cmFuc2FjdGlvbiBpbW1lZGlhdGVseSBhZnRlciBzaWduaW5nXG4gICAgICBjb25zb2xlLmxvZygnU2VuZGluZyBwYXltZW50IGxpbmsgY3JlYXRpb24gdHJhbnNhY3Rpb24gaW1tZWRpYXRlbHkuLi4nKVxuICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihzaWduZWRUeC5zZXJpYWxpemUoKSwge1xuICAgICAgICBza2lwUHJlZmxpZ2h0OiBmYWxzZSxcbiAgICAgICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogJ2NvbmZpcm1lZCdcbiAgICAgIH0pXG5cbiAgICAgIC8vIFdhaXQgZm9yIHRyYW5zYWN0aW9uIGV4ZWN1dGlvbiBvbiBOZW9uIEVWTVxuICAgICAgY29uc3QgdHJhbnNhY3Rpb25TdGF0dXMgPSBhd2FpdCB0aGlzLnByb3h5QXBpLndhaXRUcmFuc2FjdGlvblRyZWVFeGVjdXRpb24oXG4gICAgICAgIHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0LCBcbiAgICAgICAgbm9uY2UsIFxuICAgICAgICA2MDAwMCAvLyA2MCBzZWNvbmQgdGltZW91dFxuICAgICAgKVxuXG4gICAgICBjb25zb2xlLmxvZygnVHJhbnNhY3Rpb24gc3RhdHVzOicsIHRyYW5zYWN0aW9uU3RhdHVzKVxuXG4gICAgICBpZiAodHJhbnNhY3Rpb25TdGF0dXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdHJhbnNhY3Rpb24gc3RhdHVzIHJldHVybmVkIC0gdHJhbnNhY3Rpb24gbWF5IG5vdCBoYXZlIGJlZW4gcHJvY2Vzc2VkJylcbiAgICAgIH1cblxuICAgICAgY29uc3QgdHhTdGF0dXMgPSB0cmFuc2FjdGlvblN0YXR1c1swXVxuICAgICAgY29uc29sZS5sb2coJ1RyYW5zYWN0aW9uIGV4ZWN1dGlvbiBzdGF0dXM6JywgdHhTdGF0dXMuc3RhdHVzKVxuICAgICAgXG4gICAgICBpZiAodHhTdGF0dXMuc3RhdHVzID09PSAnTm90U3RhcnRlZCcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gVHJhbnNhY3Rpb24gd2FzIHNjaGVkdWxlZCBidXQgbm90IHlldCBleGVjdXRlZCBieSBOZW9uIG9wZXJhdG9ycycpXG4gICAgICAgIGNvbnNvbGUubG9nKCdUaGlzIGlzIGV4cGVjdGVkIC0gTmVvbiB3aWxsIHByb2Nlc3MgaXQgZXZlbnR1YWxseScpXG4gICAgICAgIGNvbnNvbGUubG9nKCdUcmFuc2FjdGlvbiBoYXNoOicsIHR4U3RhdHVzLnRyYW5zYWN0aW9uSGFzaClcbiAgICAgICAgXG4gICAgICAgIC8vIFNpbmNlIHdlIGhhdmUgYSB0cmFuc2FjdGlvbiBoYXNoLCBwcm9jZWVkIHdpdGggdXNpbmcgaXQgYXMgdGhlIHBheW1lbnQgbGluayBJRFxuICAgICAgICAvLyBUaGUgdHJhbnNhY3Rpb24gd2lsbCBiZSBwcm9jZXNzZWQgYnkgTmVvbiBvcGVyYXRvcnMgZXZlbnR1YWxseVxuICAgICAgICBjb25zb2xlLmxvZygn4pyFIFVzaW5nIHRyYW5zYWN0aW9uIGhhc2ggYXMgcGF5bWVudCBsaW5rIElEIC0gTmVvbiB3aWxsIHByb2Nlc3MgaXQgd2hlbiByZWFkeScpXG4gICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmtJZDogdHhTdGF0dXMudHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgIHR4SGFzaDogdHhTdGF0dXMudHJhbnNhY3Rpb25IYXNoXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICB9IGVsc2UgaWYgKHR4U3RhdHVzLnN0YXR1cyA9PT0gJ0ZhaWxlZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiBleGVjdXRpb24gZmFpbGVkLiBIYXNoOiAke3R4U3RhdHVzLnRyYW5zYWN0aW9uSGFzaH1gKVxuICAgICAgfSBlbHNlIGlmICh0eFN0YXR1cy5zdGF0dXMgIT09ICdTdWNjZXNzJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RyYW5zYWN0aW9uIGZpbmlzaGVkIHdpdGggdW5leHBlY3RlZCBzdGF0dXM6JywgdHhTdGF0dXMuc3RhdHVzKVxuICAgICAgICAvLyBTdGlsbCB0cnkgdG8gcmV0dXJuIHRoZSB0cmFuc2FjdGlvbiBoYXNoIGluIGNhc2UgaXQncyB1c2FibGVcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsaW5rSWQ6IHR4U3RhdHVzLnRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICB0eEhhc2g6IHR4U3RhdHVzLnRyYW5zYWN0aW9uSGFzaFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHR4SGFzaCA9IHRyYW5zYWN0aW9uU3RhdHVzWzBdLnRyYW5zYWN0aW9uSGFzaFxuICAgICAgY29uc29sZS5sb2coJ1RyYW5zYWN0aW9uIGhhc2g6JywgdHhIYXNoKVxuXG4gICAgICAvLyBHZXQgdGhlIGxpbmsgSUQgZnJvbSB0cmFuc2FjdGlvbiByZWNlaXB0XG4gICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5wcm94eUFwaS5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKVxuICAgICAgY29uc29sZS5sb2coJ0Z1bGwgdHJhbnNhY3Rpb24gcmVjZWlwdDonLCBKU09OLnN0cmluZ2lmeShyZWNlaXB0LCBudWxsLCAyKSlcbiAgICAgIFxuICAgICAgbGV0IGxpbmtJZCA9ICcnXG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRoZSB0cmFuc2FjdGlvbiB3YXMgc3VjY2Vzc2Z1bFxuICAgICAgaWYgKHJlY2VpcHQucmVzdWx0Py5zdGF0dXMgIT09ICcweDEnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gZmFpbGVkIC0gc3RhdHVzOiAnICsgcmVjZWlwdC5yZXN1bHQ/LnN0YXR1cylcbiAgICAgIH1cblxuICAgICAgLy8gRW5oYW5jZWQgZGVidWdnaW5nIG9mIHRoZSByZWNlaXB0IHN0cnVjdHVyZVxuICAgICAgY29uc29sZS5sb2coJ1JlY2VpcHQgc3RhdHVzOicsIHJlY2VpcHQucmVzdWx0Py5zdGF0dXMpXG4gICAgICBjb25zb2xlLmxvZygnUmVjZWlwdCBsb2dzIGFycmF5OicsIHJlY2VpcHQucmVzdWx0Py5sb2dzKVxuICAgICAgY29uc29sZS5sb2coJ1JlY2VpcHQgbG9ncyBsZW5ndGg6JywgcmVjZWlwdC5yZXN1bHQ/LmxvZ3M/Lmxlbmd0aClcbiAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXB0IGxvZ3NCbG9vbTonLCByZWNlaXB0LnJlc3VsdD8ubG9nc0Jsb29tKVxuICAgICAgY29uc29sZS5sb2coJ1JlY2VpcHQgY29udHJhY3RBZGRyZXNzOicsIHJlY2VpcHQucmVzdWx0Py5jb250cmFjdEFkZHJlc3MpXG4gICAgICBjb25zb2xlLmxvZygnUmVjZWlwdCBnYXNVc2VkOicsIHJlY2VpcHQucmVzdWx0Py5nYXNVc2VkKVxuICAgICAgY29uc29sZS5sb2coJ1JlY2VpcHQgZWZmZWN0aXZlR2FzUHJpY2U6JywgcmVjZWlwdC5yZXN1bHQ/LmVmZmVjdGl2ZUdhc1ByaWNlKVxuXG4gICAgICAvLyBDaGVjayBpZiB0aGVyZSdzIGEgZGlmZmVyZW50IGxvY2F0aW9uIGZvciBsb2dzXG4gICAgICBjb25zb2xlLmxvZygnUmF3IHRyYW5zYWN0aW9uIGRhdGE6JywgcmVjZWlwdC5yZXN1bHQ/Lm5lb25SYXdUcmFuc2FjdGlvbilcbiAgICAgIFxuICAgICAgLy8gTm90ZTogZ2V0VHJhbnNhY3Rpb24gbWV0aG9kIG5vdCBhdmFpbGFibGUgb24gTmVvblByb3h5UnBjQXBpXG4gICAgICAvLyBUcmFuc2FjdGlvbiBkZXRhaWxzIGFyZSBhbHJlYWR5IGluIHRoZSByZWNlaXB0XG5cbiAgICAgIC8vIEV4dHJhY3QgYWxsIG5lb25Mb2dzIGZyb20gc29sYW5hVHJhbnNhY3Rpb25zXG4gICAgICBjb25zdCBhbGxOZW9uTG9nczogYW55W10gPSBbXVxuICAgICAgaWYgKHJlY2VpcHQucmVzdWx0Py5zb2xhbmFUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBzb2xUeCBvZiByZWNlaXB0LnJlc3VsdC5zb2xhbmFUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICBpZiAoc29sVHguc29sYW5hSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIHNvbFR4LnNvbGFuYUluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24ubmVvbkxvZ3MgJiYgaW5zdHJ1Y3Rpb24ubmVvbkxvZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGFsbE5lb25Mb2dzLnB1c2goLi4uaW5zdHJ1Y3Rpb24ubmVvbkxvZ3MpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ0ZvdW5kJywgYWxsTmVvbkxvZ3MubGVuZ3RoLCAnbmVvbkxvZ3MgdG8gcGFyc2UnKVxuXG4gICAgICAvLyBUcnkgdG8gcGFyc2UgbG9ncyBmb3IgdGhlIFNvbGFuYUxpbmtDcmVhdGVkIGV2ZW50XG4gICAgICBpZiAoYWxsTmVvbkxvZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IGxvZyBvZiBhbGxOZW9uTG9ncykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVHJ5aW5nIHRvIHBhcnNlIG5lb25Mb2c6JywgbG9nKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGxvZyBpcyBmcm9tIG91ciBjb250cmFjdFxuICAgICAgICAgICAgaWYgKGxvZy5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IENPTlRSQUNUX0FERFJFU1MudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTG9nIGlzIGZyb20gb3VyIGNvbnRyYWN0LCBwYXJzaW5nLi4uJylcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGxvZyB0byB0aGUgZm9ybWF0IGV4cGVjdGVkIGJ5IGV0aGVyc1xuICAgICAgICAgICAgICBjb25zdCBldGhlcnNMb2cgPSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogbG9nLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgZGF0YTogbG9nLmRhdGEsXG4gICAgICAgICAgICAgICAgdG9waWNzOiBsb2cudG9waWNzXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGNvbnN0IHBhcnNlZExvZyA9IGlmYWNlLnBhcnNlTG9nKGV0aGVyc0xvZylcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BhcnNlZCBsb2c6JywgcGFyc2VkTG9nKVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKHBhcnNlZExvZz8ubmFtZSA9PT0gJ1NvbGFuYUxpbmtDcmVhdGVkJykge1xuICAgICAgICAgICAgICAgIGxpbmtJZCA9IHBhcnNlZExvZy5hcmdzLmxpbmtJZFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgRm91bmQgbGluayBJRCBmcm9tIFNvbGFuYUxpbmtDcmVhdGVkIGV2ZW50OicsIGxpbmtJZClcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTG9nIGZyb20gZGlmZmVyZW50IGNvbnRyYWN0OicsIGxvZy5hZGRyZXNzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgdG8gcGFyc2UgbmVvbkxvZzonLCBlKVxuICAgICAgICAgICAgLy8gU2tpcCBsb2dzIHRoYXQgY2FuJ3QgYmUgcGFyc2VkXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ05vIG5lb25Mb2dzIGZvdW5kIGluIHRyYW5zYWN0aW9uIHJlY2VpcHQhJylcbiAgICAgICAgY29uc29sZS5sb2coJ1RoaXMgbWlnaHQgaW5kaWNhdGU6JylcbiAgICAgICAgY29uc29sZS5sb2coJzEuIFRoZSBjb250cmFjdCBjYWxsIGZhaWxlZCBzaWxlbnRseScpXG4gICAgICAgIGNvbnNvbGUubG9nKCcyLiBUaGUgY29udHJhY3QgaXMgbm90IGF0IHRoZSBleHBlY3RlZCBhZGRyZXNzJylcbiAgICAgICAgY29uc29sZS5sb2coJzMuIFRoZSBjb250cmFjdCBmdW5jdGlvbiBjYWxsIHJldmVydGVkJylcbiAgICAgICAgY29uc29sZS5sb2coJzQuIEV2ZW50cyBhcmUgbm90IGJlaW5nIGVtaXR0ZWQgcHJvcGVybHknKVxuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IGNhbGxpbmcgdGhlIGNvbnRyYWN0IHJlYWQgbWV0aG9kIHRvIHNlZSBpZiBkYXRhIHdhcyBhY3R1YWxseSBzdG9yZWRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnQXR0ZW1wdGluZyB0byByZWFkIHBheW1lbnQgbGluayB1c2luZyB0cmFuc2FjdGlvbiBoYXNoIGFzIElELi4uJylcbiAgICAgICAgICBjb25zdCB0ZXN0RGF0YSA9IGF3YWl0IHRoaXMuY29udHJhY3QhLmdldFNvbGFuYVBheW1lbnRMaW5rKHR4SGFzaClcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ29udHJhY3QgcmVhZCByZXN1bHQ6JywgdGVzdERhdGEpXG4gICAgICAgIH0gY2F0Y2ggKHJlYWRFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdDb250cmFjdCByZWFkIGZhaWxlZDonLCByZWFkRXJyb3IpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgY291bGRuJ3QgZXh0cmFjdCBmcm9tIGxvZ3MsIGludmVzdGlnYXRlIGZ1cnRoZXJcbiAgICAgIGlmICghbGlua0lkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NvdWxkIG5vdCBleHRyYWN0IGxpbmsgSUQgZnJvbSB0cmFuc2FjdGlvbiBldmVudHMhJylcbiAgICAgICAgY29uc29sZS5sb2coJ1RoaXMgc3VnZ2VzdHMgdGhlIGNvbnRyYWN0IGNhbGwgbWF5IGhhdmUgZmFpbGVkIHNpbGVudGx5JylcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSB0cmFuc2FjdGlvbiBhY3R1YWxseSByZXZlcnRlZFxuICAgICAgICBjb25zb2xlLmxvZygnQ2hlY2tpbmcgZm9yIHJldmVydCBkYXRhLi4uJylcbiAgICAgICAgaWYgKHJlY2VpcHQucmVzdWx0Py5uZW9uUmV2ZXJ0RGF0YSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdSZXZlcnQgZGF0YSBmb3VuZDonLCByZWNlaXB0LnJlc3VsdC5uZW9uUmV2ZXJ0RGF0YSlcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIGRlY29kZSB0aGUgcmV2ZXJ0IHJlYXNvblxuICAgICAgICAgICAgY29uc3QgcmV2ZXJ0UmVhc29uID0gZXRoZXJzLnRvVXRmOFN0cmluZyhyZWNlaXB0LnJlc3VsdC5uZW9uUmV2ZXJ0RGF0YSlcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZXZlcnQgcmVhc29uOicsIHJldmVydFJlYXNvbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udHJhY3QgY2FsbCByZXZlcnRlZDogJHtyZXZlcnRSZWFzb259YClcbiAgICAgICAgICB9IGNhdGNoIChkZWNvZGVFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0NvdWxkIG5vdCBkZWNvZGUgcmV2ZXJ0IHJlYXNvbjonLCBkZWNvZGVFcnJvcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udHJhY3QgY2FsbCByZXZlcnRlZCB3aXRoIHVua25vd24gcmVhc29uJylcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIExldCdzIHRyeSB0byB1bmRlcnN0YW5kIHdoeSB0aGUgZXZlbnQgd2Fzbid0IGVtaXR0ZWRcbiAgICAgICAgY29uc29sZS5sb2coJ0FuYWx5emluZyBmdW5jdGlvbiBjYWxsLi4uJylcbiAgICAgICAgY29uc29sZS5sb2coJ0NvbnRyYWN0IGFkZHJlc3M6JywgQ09OVFJBQ1RfQUREUkVTUylcbiAgICAgICAgY29uc29sZS5sb2coJ0Zyb20gYWRkcmVzczonLCB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldClcbiAgICAgICAgY29uc29sZS5sb2coJ0Z1bmN0aW9uIGRhdGEgaW4gcmF3IHR4OicsIHJlY2VpcHQucmVzdWx0Py5uZW9uUmF3VHJhbnNhY3Rpb24pXG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB1c2VyIGlzIHJlZ2lzdGVyZWRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBpc1JlZ2lzdGVyZWQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0IS5pc1NvbGFuYVVzZXIodGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQpXG4gICAgICAgICAgY29uc29sZS5sb2coJ0lzIHVzZXIgcmVnaXN0ZXJlZCBhcyBTb2xhbmEgdXNlcjonLCBpc1JlZ2lzdGVyZWQpXG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCFpc1JlZ2lzdGVyZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVXNlciBpcyBub3QgcmVnaXN0ZXJlZCBhcyBhIFNvbGFuYSB1c2VyIHdpdGggdGhlIGNvbnRyYWN0LiBUaGlzIGlzIHJlcXVpcmVkIHRvIGNyZWF0ZSBwYXltZW50IGxpbmtzLicpXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChyZWdpc3RyYXRpb25FcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjaGVjayB1c2VyIHJlZ2lzdHJhdGlvbjonLCByZWdpc3RyYXRpb25FcnJvcilcbiAgICAgICAgICB0aHJvdyByZWdpc3RyYXRpb25FcnJvclxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgc29tZXRoaW5nIGVsc2Ugd2VudCB3cm9uZ1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BheW1lbnQgbGluayBjcmVhdGlvbiBmYWlsZWQ6IENvbnRyYWN0IGNhbGwgZXhlY3V0ZWQgYnV0IG5vIGV2ZW50IHdhcyBlbWl0dGVkLiBUaGUgdHJhbnNhY3Rpb24gbWF5IGhhdmUgZmFpbGVkIHNpbGVudGx5LicpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmtJZCxcbiAgICAgICAgdHhIYXNoXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgcGF5bWVudCBsaW5rOicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSByZWFkLW9ubHkgY29udHJhY3QgYWNjZXNzICh3aXRob3V0IHdhbGxldClcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW5pdFJlYWRPbmx5Q29udHJhY3QoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLmNvbnRyYWN0KSB7XG4gICAgICAvLyBDcmVhdGUgYSBzaW1wbGUgSlNPTiBSUEMgcHJvdmlkZXIgZm9yIHJlYWQgb3BlcmF0aW9uc1xuICAgICAgY29uc3QgcmVhZE9ubHlQcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKE5FT05fQ09SRV9SUENfVVJMKVxuICAgICAgdGhpcy5jb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoQ09OVFJBQ1RfQUREUkVTUywgU09MQU5BX1RJUENBUkRfQUJJLCByZWFkT25seVByb3ZpZGVyKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcGF5bWVudCBsaW5rIGRldGFpbHNcbiAgICovXG4gIGFzeW5jIGdldFBheW1lbnRMaW5rKGxpbmtJZDogc3RyaW5nKTogUHJvbWlzZTxQYXltZW50TGluaz4ge1xuICAgIC8vIEluaXRpYWxpemUgY29udHJhY3QgaWYgbm90IGFscmVhZHkgZG9uZVxuICAgIGlmICghdGhpcy5jb250cmFjdCkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0UmVhZE9ubHlDb250cmFjdCgpXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ0dldHRpbmcgcGF5bWVudCBsaW5rIHdpdGggSUQ6JywgbGlua0lkKVxuICAgIGNvbnNvbGUubG9nKCdDb250cmFjdCBhZGRyZXNzOicsIENPTlRSQUNUX0FERFJFU1MpXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jb250cmFjdCEuZ2V0U29sYW5hUGF5bWVudExpbmsobGlua0lkKVxuICAgICAgY29uc29sZS5sb2coJ1JhdyBjb250cmFjdCByZXN1bHQ6JywgcmVzdWx0KVxuICAgICAgXG4gICAgICBjb25zdCBwYXltZW50TGluayA9IHtcbiAgICAgICAgZXZtQ3JlYXRvcjogcmVzdWx0LmV2bUNyZWF0b3IsXG4gICAgICAgIHNvbGFuYUNyZWF0b3I6IHJlc3VsdC5zb2xhbmFDcmVhdG9yLFxuICAgICAgICBhbW91bnQ6IHJlc3VsdC5hbW91bnQsXG4gICAgICAgIGlzRmxleGlibGU6IHJlc3VsdC5pc0ZsZXhpYmxlLFxuICAgICAgICBpc0FjdGl2ZTogcmVzdWx0LmlzQWN0aXZlLFxuICAgICAgICB0b3RhbFJlY2VpdmVkOiByZXN1bHQudG90YWxSZWNlaXZlZCxcbiAgICAgICAgcGF5bWVudENvdW50OiBOdW1iZXIocmVzdWx0LnBheW1lbnRDb3VudCksXG4gICAgICAgIGRlc2NyaXB0aW9uOiByZXN1bHQuZGVzY3JpcHRpb25cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBsb29rcyBsaWtlIGFuIGVtcHR5L25vbi1leGlzdGVudCBsaW5rICh0cmFuc2FjdGlvbiBub3QgcHJvY2Vzc2VkIHlldClcbiAgICAgIGlmIChyZXN1bHQuZXZtQ3JlYXRvciA9PT0gJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcgJiYgXG4gICAgICAgICAgcmVzdWx0LmFtb3VudCA9PT0gQmlnSW50KDApICYmIFxuICAgICAgICAgICFyZXN1bHQuaXNBY3RpdmUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdQYXltZW50IGxpbmsgYXBwZWFycyB0byBiZSBlbXB0eS9ub24tZXhpc3RlbnQnKVxuICAgICAgICBcbiAgICAgICAgLy8gSWYgdGhpcyBsb29rcyBsaWtlIGEgdHJhbnNhY3Rpb24gaGFzaCAoNjYgY2hhcnMsIHN0YXJ0cyB3aXRoIDB4KSwgcHJvdmlkZSBoZWxwZnVsIGluZm9cbiAgICAgICAgaWYgKGxpbmtJZC5sZW5ndGggPT09IDY2ICYmIGxpbmtJZC5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ/CfkqEgVGhpcyBhcHBlYXJzIHRvIGJlIGEgdHJhbnNhY3Rpb24gaGFzaCAtIHRoZSBwYXltZW50IGxpbmsgbWF5IHN0aWxsIGJlIHByb2Nlc3NpbmcnKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5KhIE5lb24gb3BlcmF0b3JzIHdpbGwgZXZlbnR1YWxseSBwcm9jZXNzIHRoaXMgdHJhbnNhY3Rpb24gYW5kIGNyZWF0ZSB0aGUgcGF5bWVudCBsaW5rJylcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+SoSBZb3UgY2FuIGJvb2ttYXJrIHRoaXMgbGluayBhbmQgdHJ5IGFnYWluIGluIGEgZmV3IG1pbnV0ZXMnKVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZvciBub3csIGRvbid0IHRocm93IGFuIGVycm9yIC0gbGV0IHRoZSBVSSBoYW5kbGUgdGhlIGVtcHR5IGRhdGEgZ3JhY2VmdWxseVxuICAgICAgICAgIGNvbnNvbGUubG9nKCdSZXR1cm5pbmcgZW1wdHkgcGF5bWVudCBsaW5rIGRhdGEgLSB0cmFuc2FjdGlvbiBtYXkgc3RpbGwgYmUgcHJvY2Vzc2luZycpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHBheW1lbnRMaW5rXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0NvbnRyYWN0IGNhbGwgZXJyb3I6JywgZXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BheW1lbnQgbGluayBub3QgZm91bmQgb3IgY29udHJhY3QgZXJyb3InKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdXNlcidzIHBheW1lbnQgbGlua3NcbiAgICovXG4gIGFzeW5jIGdldFVzZXJMaW5rcyh1c2VyRVZNQWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIC8vIEluaXRpYWxpemUgY29udHJhY3QgaWYgbm90IGFscmVhZHkgZG9uZVxuICAgIGlmICghdGhpcy5jb250cmFjdCkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0UmVhZE9ubHlDb250cmFjdCgpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbnRyYWN0IS5nZXRVc2VyU29sYW5hTGlua3ModXNlckVWTUFkZHJlc3MpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdXNlciBsaW5rczonLCBlcnJvcilcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXkgYSBwYXltZW50IGxpbmsgdXNpbmcgU29sYW5hIE5hdGl2ZSBTREtcbiAgICovXG4gIGFzeW5jIHBheUxpbmsoXG4gICAgbGlua0lkOiBzdHJpbmcsXG4gICAgYW1vdW50U09MOiBudW1iZXJcbiAgKTogUHJvbWlzZTx7IHR4SGFzaDogc3RyaW5nOyB0cmFuc2ZlclNpZ25hdHVyZT86IHN0cmluZyB9PiB7XG4gICAgaWYgKCF0aGlzLnNvbGFuYVVzZXIgfHwgIXRoaXMuY29udHJhY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIGNvbm5lY3Qgd2FsbGV0IGZpcnN0JylcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgcGF5bWVudCBwcm9jZXNzLi4uJylcbiAgICBjb25zb2xlLmxvZygnTGluayBJRDonLCBsaW5rSWQpXG4gICAgY29uc29sZS5sb2coJ0Ftb3VudCBTT0w6JywgYW1vdW50U09MKVxuXG4gICAgLy8gRmlyc3QsIGdldCB0aGUgcGF5bWVudCBsaW5rIGRldGFpbHMgdG8gZmluZCB0aGUgcmVjaXBpZW50XG4gICAgY29uc3QgbGlua0RhdGEgPSBhd2FpdCB0aGlzLmdldFBheW1lbnRMaW5rKGxpbmtJZClcbiAgICBjb25zb2xlLmxvZygnUGF5bWVudCBsaW5rIGRhdGE6JywgbGlua0RhdGEpXG5cbiAgICBpZiAoIWxpbmtEYXRhLmlzQWN0aXZlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BheW1lbnQgbGluayBpcyBubyBsb25nZXIgYWN0aXZlJylcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IFNPTCB0byBsYW1wb3J0c1xuICAgIGNvbnN0IGFtb3VudExhbXBvcnRzID0gTWF0aC5mbG9vcihhbW91bnRTT0wgKiAxZTkpXG4gICAgXG4gICAgbGV0IHRyYW5zZmVyU2lnbmF0dXJlOiBzdHJpbmcgfCB1bmRlZmluZWRcblxuICAgIHRyeSB7XG4gICAgICAvLyBTdGVwIDE6IFBlcmZvcm0gdGhlIGFjdHVhbCBTT0wgdHJhbnNmZXIgZmlyc3RcbiAgICAgIGNvbnNvbGUubG9nKCdTdGVwIDE6IFBlcmZvcm1pbmcgU09MIHRyYW5zZmVyLi4uJylcbiAgICAgIGNvbnNvbGUubG9nKCdGcm9tOicsIHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXkudG9CYXNlNTgoKSlcbiAgICAgIGNvbnNvbGUubG9nKCdUbyByZWNpcGllbnQgYnl0ZXMzMjonLCBsaW5rRGF0YS5zb2xhbmFDcmVhdG9yKVxuICAgICAgY29uc29sZS5sb2coJ0Ftb3VudCBsYW1wb3J0czonLCBhbW91bnRMYW1wb3J0cylcblxuICAgICAgLy8gQ29udmVydCByZWNpcGllbnQgU29sYW5hIGFkZHJlc3MgZnJvbSBieXRlczMyIHRvIFB1YmxpY0tleVxuICAgICAgLy8gUmVtb3ZlICcweCcgcHJlZml4IGlmIHByZXNlbnRcbiAgICAgIGNvbnN0IGhleFN0cmluZyA9IGxpbmtEYXRhLnNvbGFuYUNyZWF0b3Iuc3RhcnRzV2l0aCgnMHgnKSBcbiAgICAgICAgPyBsaW5rRGF0YS5zb2xhbmFDcmVhdG9yLnNsaWNlKDIpIFxuICAgICAgICA6IGxpbmtEYXRhLnNvbGFuYUNyZWF0b3JcbiAgICAgIFxuICAgICAgLy8gQ29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbiAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoaGV4U3RyaW5nLm1hdGNoKC8uezJ9L2cpPy5tYXAoYnl0ZSA9PiBwYXJzZUludChieXRlLCAxNikpIHx8IFtdKVxuICAgICAgXG4gICAgICAvLyBGb3IgYnl0ZXMzMiBmcm9tIFNvbGFuYSBhZGRyZXNzZXMsIHdlIG5lZWQgdG8gZmluZCB0aGUgYWN0dWFsIDMyLWJ5dGUgcHVibGljIGtleVxuICAgICAgLy8gVGhlIGJ5dGVzMzIgc2hvdWxkIGNvbnRhaW4gdGhlIDMyLWJ5dGUgU29sYW5hIHB1YmxpYyBrZXksIHBvc3NpYmx5IHdpdGggbGVhZGluZyB6ZXJvc1xuICAgICAgbGV0IHJlY2lwaWVudFB1YmtleVxuICAgICAgXG4gICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAzMikge1xuICAgICAgICAvLyBEaXJlY3QgY29udmVyc2lvbiBmcm9tIDMyIGJ5dGVzXG4gICAgICAgIHJlY2lwaWVudFB1YmtleSA9IG5ldyAoYXdhaXQgaW1wb3J0KCdAc29sYW5hL3dlYjMuanMnKSkuUHVibGljS2V5KGJ5dGVzKVxuICAgICAgfSBlbHNlIGlmIChieXRlcy5sZW5ndGggPiAzMikge1xuICAgICAgICAvLyBUYWtlIHRoZSBsYXN0IDMyIGJ5dGVzIGlmIGl0J3MgbG9uZ2VyXG4gICAgICAgIGNvbnN0IGxhc3QzMkJ5dGVzID0gYnl0ZXMuc2xpY2UoLTMyKVxuICAgICAgICByZWNpcGllbnRQdWJrZXkgPSBuZXcgKGF3YWl0IGltcG9ydCgnQHNvbGFuYS93ZWIzLmpzJykpLlB1YmxpY0tleShsYXN0MzJCeXRlcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFBhZCB3aXRoIGxlYWRpbmcgemVyb3MgaWYgc2hvcnRlclxuICAgICAgICBjb25zdCBwYWRkZWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KDMyKVxuICAgICAgICBwYWRkZWRCeXRlcy5zZXQoYnl0ZXMsIDMyIC0gYnl0ZXMubGVuZ3RoKVxuICAgICAgICByZWNpcGllbnRQdWJrZXkgPSBuZXcgKGF3YWl0IGltcG9ydCgnQHNvbGFuYS93ZWIzLmpzJykpLlB1YmxpY0tleShwYWRkZWRCeXRlcylcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ1JlY2lwaWVudCBQdWJsaWNLZXk6JywgcmVjaXBpZW50UHVia2V5LnRvQmFzZTU4KCkpXG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgU09MIHRyYW5zZmVyIHRyYW5zYWN0aW9uXG4gICAgICBjb25zdCB7IFN5c3RlbVByb2dyYW0sIFRyYW5zYWN0aW9uIH0gPSBhd2FpdCBpbXBvcnQoJ0Bzb2xhbmEvd2ViMy5qcycpXG5cbiAgICAgIC8vIENyZWF0ZSB0cmFuc2ZlciBpbnN0cnVjdGlvblxuICAgICAgY29uc3QgdHJhbnNmZXJJeCA9IFN5c3RlbVByb2dyYW0udHJhbnNmZXIoe1xuICAgICAgICBmcm9tUHVia2V5OiB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LFxuICAgICAgICB0b1B1YmtleTogcmVjaXBpZW50UHVia2V5LFxuICAgICAgICBsYW1wb3J0czogYW1vdW50TGFtcG9ydHNcbiAgICAgIH0pXG5cbiAgICAgIC8vIENyZWF0ZSB0cmFuc2FjdGlvblxuICAgICAgY29uc3QgdHJhbnNmZXJUeCA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZCh0cmFuc2Zlckl4KVxuICAgICAgXG4gICAgICAvLyBHZXQgZnJlc2ggcmVjZW50IGJsb2NraGFzaCByaWdodCBiZWZvcmUgc2lnbmluZ1xuICAgICAgY29uc29sZS5sb2coJ0dldHRpbmcgZnJlc2ggYmxvY2toYXNoIGZvciBTT0wgdHJhbnNmZXIuLi4nKVxuICAgICAgY29uc3QgeyBibG9ja2hhc2gsIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiB0cmFuc2ZlckJsb2NrSGVpZ2h0IH0gPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCdjb25maXJtZWQnKVxuICAgICAgY29uc29sZS5sb2coJ0ZyZXNoIFNPTCB0cmFuc2ZlciBibG9ja2hhc2g6JywgYmxvY2toYXNoKVxuICAgICAgY29uc29sZS5sb2coJ0xhc3QgdmFsaWQgYmxvY2sgaGVpZ2h0OicsIHRyYW5zZmVyQmxvY2tIZWlnaHQpXG4gICAgICBcbiAgICAgIHRyYW5zZmVyVHgucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoXG4gICAgICB0cmFuc2ZlclR4LmZlZVBheWVyID0gdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleVxuXG4gICAgICAvLyBTaWduIGFuZCBzZW5kIHRoZSBTT0wgdHJhbnNmZXIgaW1tZWRpYXRlbHlcbiAgICAgIGNvbnNvbGUubG9nKCdTaWduaW5nIGFuZCBzZW5kaW5nIFNPTCB0cmFuc2ZlciB3aXRoIGZyZXNoIGJsb2NraGFzaC4uLicpXG4gICAgICBjb25zdCBzaWduZWRUcmFuc2ZlclR4ID0gYXdhaXQgdGhpcy5zb2xhbmFVc2VyLndhbGxldEFkYXB0ZXIuc2lnblRyYW5zYWN0aW9uKHRyYW5zZmVyVHgpXG4gICAgICB0cmFuc2ZlclNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNmZXJUeC5zZXJpYWxpemUoKSwge1xuICAgICAgICBza2lwUHJlZmxpZ2h0OiBmYWxzZSxcbiAgICAgICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogJ2NvbmZpcm1lZCdcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdTT0wgdHJhbnNmZXIgc2VudDonLCB0cmFuc2ZlclNpZ25hdHVyZSlcbiAgICAgIFxuICAgICAgLy8gV2FpdCBmb3IgdHJhbnNmZXIgY29uZmlybWF0aW9uIHVzaW5nIHRoZSBtb2Rlcm4gQVBJXG4gICAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHtcbiAgICAgICAgc2lnbmF0dXJlOiB0cmFuc2ZlclNpZ25hdHVyZSxcbiAgICAgICAgLi4uKGF3YWl0IHRoaXMuY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goKSlcbiAgICAgIH0pXG4gICAgICBjb25zb2xlLmxvZygnU09MIHRyYW5zZmVyIGNvbmZpcm1lZCcpXG5cbiAgICAgIC8vIFN0ZXAgMjogUmVjb3JkIHRoZSBwYXltZW50IGluIHRoZSBjb250cmFjdFxuICAgICAgY29uc29sZS5sb2coJ1N0ZXAgMjogUmVjb3JkaW5nIHBheW1lbnQgaW4gY29udHJhY3QuLi4nKVxuICAgICAgXG4gICAgICAvLyBDb252ZXJ0IFNvbGFuYSBQdWJsaWNLZXkgdG8gYnl0ZXMzMlxuICAgICAgY29uc3QgcGF5ZXJTb2xhbmFCeXRlczMyID0gemVyb1BhZFZhbHVlKGhleGxpZnkodGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleS50b0J5dGVzKCkpLCAzMilcblxuICAgICAgLy8gR2V0IG5vbmNlXG4gICAgICAvLyBGb3JjZSBub25jZSBpbmNyZW1lbnRhdGlvbiB0byBhdm9pZCByZXVzZVxuICAgICAgbGV0IGNoYWluTm9uY2UgPSBOdW1iZXIoYXdhaXQgdGhpcy5wcm94eUFwaS5nZXRUcmFuc2FjdGlvbkNvdW50KHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0KSlcbiAgICAgIGNvbnNvbGUubG9nKCdDaGFpbiBub25jZSBmcm9tIGdldFRyYW5zYWN0aW9uQ291bnQ6JywgY2hhaW5Ob25jZSlcbiAgICAgIGNvbnNvbGUubG9nKCdMYXN0IHVzZWQgbm9uY2UgaW4gc2Vzc2lvbjonLCB0aGlzLmxhc3RVc2VkTm9uY2UpXG4gICAgICBcbiAgICAgIC8vIEFsd2F5cyB1c2UgYSBoaWdoZXIgbm9uY2UgdGhhbiBib3RoIGNoYWluIGFuZCBsYXN0IHVzZWRcbiAgICAgIGxldCBub25jZSA9IE1hdGgubWF4KGNoYWluTm9uY2UsIHRoaXMubGFzdFVzZWROb25jZSArIDEpXG4gICAgICBjb25zb2xlLmxvZygnQ2FsY3VsYXRlZCBub25jZTonLCBub25jZSlcbiAgICAgIFxuICAgICAgLy8gVHJhY2sgdGhpcyBub25jZSBhcyB1c2VkXG4gICAgICB0aGlzLmxhc3RVc2VkTm9uY2UgPSBub25jZVxuICAgICAgY29uc29sZS5sb2coJ0ZpbmFsIG5vbmNlIHRvIHVzZTonLCBub25jZSlcblxuICAgICAgLy8gUHJlcGFyZSBjb250cmFjdCBjYWxsIGRhdGFcbiAgICAgIGNvbnN0IGlmYWNlID0gbmV3IGV0aGVycy5JbnRlcmZhY2UoU09MQU5BX1RJUENBUkRfQUJJKVxuICAgICAgY29uc3QgZGF0YSA9IGlmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YSgncGF5U29sYW5hTGluaycsIFtcbiAgICAgICAgbGlua0lkLFxuICAgICAgICBhbW91bnRMYW1wb3J0cyxcbiAgICAgICAgcGF5ZXJTb2xhbmFCeXRlczMyXG4gICAgICBdKVxuXG4gICAgICAvLyBDcmVhdGUgdHJhbnNhY3Rpb24gZGF0YVxuICAgICAgY29uc3QgdHJhbnNhY3Rpb25EYXRhID0ge1xuICAgICAgICBmcm9tOiB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCxcbiAgICAgICAgdG86IENPTlRSQUNUX0FERFJFU1MsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH1cblxuICAgICAgLy8gRXN0aW1hdGUgZ2FzXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkdhcyA9IGF3YWl0IHRoaXMucHJveHlBcGkuZXN0aW1hdGVTY2hlZHVsZWRUcmFuc2FjdGlvbkdhcyh7XG4gICAgICAgIHNvbGFuYVBheWVyOiB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LFxuICAgICAgICB0cmFuc2FjdGlvbnM6IFt0cmFuc2FjdGlvbkRhdGFdLFxuICAgICAgfSlcblxuICAgICAgLy8gQ3JlYXRlIHNjaGVkdWxlZCB0cmFuc2FjdGlvblxuICAgICAgbGV0IHsgc2NoZWR1bGVkVHJhbnNhY3Rpb24gfSA9IGF3YWl0IHRoaXMucHJveHlBcGkuY3JlYXRlU2NoZWR1bGVkVHJhbnNhY3Rpb24oe1xuICAgICAgICB0cmFuc2FjdGlvbkdhcyxcbiAgICAgICAgdHJhbnNhY3Rpb25EYXRhLFxuICAgICAgICBub25jZVxuICAgICAgfSlcblxuICAgICAgLy8gR2V0IGZyZXNoIHJlY2VudCBibG9ja2hhc2ggcmlnaHQgYmVmb3JlIHNpZ25pbmdcbiAgICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIGZyZXNoIGJsb2NraGFzaCBmb3IgY29udHJhY3QgY2FsbC4uLicpXG4gICAgICBjb25zdCB7IGJsb2NraGFzaDogY29udHJhY3RCbG9ja2hhc2gsIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiBjb250cmFjdEJsb2NrSGVpZ2h0IH0gPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCdjb25maXJtZWQnKVxuICAgICAgY29uc29sZS5sb2coJ0ZyZXNoIGNvbnRyYWN0IGNhbGwgYmxvY2toYXNoOicsIGNvbnRyYWN0QmxvY2toYXNoKVxuICAgICAgY29uc29sZS5sb2coJ0xhc3QgdmFsaWQgYmxvY2sgaGVpZ2h0OicsIGNvbnRyYWN0QmxvY2tIZWlnaHQpXG4gICAgICBcbiAgICAgIHNjaGVkdWxlZFRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGNvbnRyYWN0QmxvY2toYXNoXG4gICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5mZWVQYXllciA9IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXlcblxuICAgICAgLy8gU2lnbiB3aXRoIHdhbGxldCBhZGFwdGVyIGluc3RlYWQgb2Yga2V5cGFpciAobGlrZSBpbiB0ZXN0cylcbiAgICAgIC8vIEluIHRlc3RzOiBzY2hlZHVsZWRUcmFuc2FjdGlvbi5zaWduKHsgcHVibGljS2V5OiBzb2xhbmFVc2VyLnB1YmxpY0tleSwgc2VjcmV0S2V5OiBzb2xhbmFVc2VyLmtleXBhaXIuc2VjcmV0S2V5IH0pXG4gICAgICAvLyBJbiBmcm9udGVuZDogdXNlIHdhbGxldCBhZGFwdGVyIHNpZ25pbmdcbiAgICAgIGNvbnNvbGUubG9nKCdTaWduaW5nIGNvbnRyYWN0IGNhbGwgd2l0aCBmcmVzaCBibG9ja2hhc2guLi4nKVxuICAgICAgY29uc3Qgc2lnbmVkVHggPSBhd2FpdCB0aGlzLnNvbGFuYVVzZXIud2FsbGV0QWRhcHRlci5zaWduVHJhbnNhY3Rpb24oc2NoZWR1bGVkVHJhbnNhY3Rpb24pXG4gICAgICBcbiAgICAgIC8vIFNlbmQgdHJhbnNhY3Rpb24gaW1tZWRpYXRlbHlcbiAgICAgIGNvbnNvbGUubG9nKCdTZW5kaW5nIGNvbnRyYWN0IGNhbGwgdHJhbnNhY3Rpb24gaW1tZWRpYXRlbHkuLi4nKVxuICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihzaWduZWRUeC5zZXJpYWxpemUoKSwge1xuICAgICAgICBza2lwUHJlZmxpZ2h0OiBmYWxzZSxcbiAgICAgICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogJ2NvbmZpcm1lZCdcbiAgICAgIH0pXG5cbiAgICAgIC8vIFdhaXQgZm9yIHRyYW5zYWN0aW9uIGV4ZWN1dGlvbiBvbiBOZW9uIEVWTVxuICAgICAgY29uc3QgdHJhbnNhY3Rpb25TdGF0dXMgPSBhd2FpdCB0aGlzLnByb3h5QXBpLndhaXRUcmFuc2FjdGlvblRyZWVFeGVjdXRpb24oXG4gICAgICAgIHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0LCBcbiAgICAgICAgbm9uY2UsIFxuICAgICAgICA2MDAwMFxuICAgICAgKVxuXG4gICAgICBpZiAodHJhbnNhY3Rpb25TdGF0dXMubGVuZ3RoID09PSAwIHx8IHRyYW5zYWN0aW9uU3RhdHVzWzBdLnN0YXR1cyAhPT0gJ1N1Y2Nlc3MnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ29udHJhY3QgcGF5bWVudCByZWNvcmRpbmcgZmFpbGVkLCBidXQgU09MIHRyYW5zZmVyIHN1Y2NlZWRlZCcpXG4gICAgICAgIGNvbnNvbGUubG9nKCdUcmFuc2ZlciBzaWduYXR1cmU6JywgdHJhbnNmZXJTaWduYXR1cmUpXG4gICAgICAgIC8vIERvbid0IHRocm93IGVycm9yIC0gdGhlIHBheW1lbnQgd2VudCB0aHJvdWdoIGV2ZW4gaWYgcmVjb3JkaW5nIGZhaWxlZFxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnUGF5bWVudCBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5IScpXG4gICAgICBjb25zb2xlLmxvZygnU09MIHRyYW5zZmVyOicsIHRyYW5zZmVyU2lnbmF0dXJlKVxuICAgICAgY29uc29sZS5sb2coJ0NvbnRyYWN0IHJlY29yZDonLCB0cmFuc2FjdGlvblN0YXR1c1swXT8udHJhbnNhY3Rpb25IYXNoKVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eEhhc2g6IHRyYW5zYWN0aW9uU3RhdHVzWzBdPy50cmFuc2FjdGlvbkhhc2ggfHwgJ2NvbnRyYWN0LXJlY29yZGluZy1mYWlsZWQnLFxuICAgICAgICB0cmFuc2ZlclNpZ25hdHVyZVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBheWluZyBsaW5rOicsIGVycm9yKVxuICAgICAgaWYgKHRyYW5zZmVyU2lnbmF0dXJlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdOb3RlOiBTT0wgdHJhbnNmZXIgbWF5IGhhdmUgc3VjY2VlZGVkOicsIHRyYW5zZmVyU2lnbmF0dXJlKVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVhY3RpdmF0ZSBhIHBheW1lbnQgbGlua1xuICAgKi9cbiAgYXN5bmMgZGVhY3RpdmF0ZUxpbmsobGlua0lkOiBzdHJpbmcpOiBQcm9taXNlPHsgdHhIYXNoOiBzdHJpbmcgfT4ge1xuICAgIGlmICghdGhpcy5zb2xhbmFVc2VyIHx8ICF0aGlzLmNvbnRyYWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBjb25uZWN0IHdhbGxldCBmaXJzdCcpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBub25jZVxuICAgICAgLy8gRm9yY2Ugbm9uY2UgaW5jcmVtZW50YXRpb24gdG8gYXZvaWQgcmV1c2VcbiAgICAgIGxldCBjaGFpbk5vbmNlID0gTnVtYmVyKGF3YWl0IHRoaXMucHJveHlBcGkuZ2V0VHJhbnNhY3Rpb25Db3VudCh0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCkpXG4gICAgICBjb25zb2xlLmxvZygnQ2hhaW4gbm9uY2UgZnJvbSBnZXRUcmFuc2FjdGlvbkNvdW50OicsIGNoYWluTm9uY2UpXG4gICAgICBjb25zb2xlLmxvZygnTGFzdCB1c2VkIG5vbmNlIGluIHNlc3Npb246JywgdGhpcy5sYXN0VXNlZE5vbmNlKVxuICAgICAgXG4gICAgICAvLyBBbHdheXMgdXNlIGEgaGlnaGVyIG5vbmNlIHRoYW4gYm90aCBjaGFpbiBhbmQgbGFzdCB1c2VkXG4gICAgICBsZXQgbm9uY2UgPSBNYXRoLm1heChjaGFpbk5vbmNlLCB0aGlzLmxhc3RVc2VkTm9uY2UgKyAxKVxuICAgICAgY29uc29sZS5sb2coJ0NhbGN1bGF0ZWQgbm9uY2U6Jywgbm9uY2UpXG4gICAgICBcbiAgICAgIC8vIFRyYWNrIHRoaXMgbm9uY2UgYXMgdXNlZFxuICAgICAgdGhpcy5sYXN0VXNlZE5vbmNlID0gbm9uY2VcbiAgICAgIGNvbnNvbGUubG9nKCdGaW5hbCBub25jZSB0byB1c2U6Jywgbm9uY2UpXG5cbiAgICAgIC8vIFByZXBhcmUgY29udHJhY3QgY2FsbCBkYXRhXG4gICAgICBjb25zdCBpZmFjZSA9IG5ldyBldGhlcnMuSW50ZXJmYWNlKFNPTEFOQV9USVBDQVJEX0FCSSlcbiAgICAgIGNvbnN0IGRhdGEgPSBpZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoJ2RlYWN0aXZhdGVTb2xhbmFMaW5rJywgW2xpbmtJZF0pXG5cbiAgICAgIC8vIENyZWF0ZSB0cmFuc2FjdGlvbiBkYXRhXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkRhdGEgPSB7XG4gICAgICAgIGZyb206IHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0LFxuICAgICAgICB0bzogQ09OVFJBQ1RfQUREUkVTUyxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfVxuXG4gICAgICAvLyBFc3RpbWF0ZSBnYXNcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uR2FzID0gYXdhaXQgdGhpcy5wcm94eUFwaS5lc3RpbWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uR2FzKHtcbiAgICAgICAgc29sYW5hUGF5ZXI6IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXksXG4gICAgICAgIHRyYW5zYWN0aW9uczogW3RyYW5zYWN0aW9uRGF0YV0sXG4gICAgICB9KVxuXG4gICAgICAvLyBDcmVhdGUgc2NoZWR1bGVkIHRyYW5zYWN0aW9uXG4gICAgICBsZXQgeyBzY2hlZHVsZWRUcmFuc2FjdGlvbiB9ID0gYXdhaXQgdGhpcy5wcm94eUFwaS5jcmVhdGVTY2hlZHVsZWRUcmFuc2FjdGlvbih7XG4gICAgICAgIHRyYW5zYWN0aW9uR2FzLFxuICAgICAgICB0cmFuc2FjdGlvbkRhdGEsXG4gICAgICAgIG5vbmNlXG4gICAgICB9KVxuXG4gICAgICAvLyBHZXQgZnJlc2ggcmVjZW50IGJsb2NraGFzaCByaWdodCBiZWZvcmUgc2lnbmluZ1xuICAgICAgY29uc29sZS5sb2coJ0dldHRpbmcgZnJlc2ggYmxvY2toYXNoIGZvciBkZWFjdGl2YXRlIHRyYW5zYWN0aW9uLi4uJylcbiAgICAgIGNvbnN0IHsgYmxvY2toYXNoLCBsYXN0VmFsaWRCbG9ja0hlaWdodDogZGVhY3RpdmF0ZUJsb2NrSGVpZ2h0IH0gPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCdjb25maXJtZWQnKVxuICAgICAgY29uc29sZS5sb2coJ0ZyZXNoIGRlYWN0aXZhdGUgYmxvY2toYXNoOicsIGJsb2NraGFzaClcbiAgICAgIGNvbnNvbGUubG9nKCdMYXN0IHZhbGlkIGJsb2NrIGhlaWdodDonLCBkZWFjdGl2YXRlQmxvY2tIZWlnaHQpXG4gICAgICBcbiAgICAgIHNjaGVkdWxlZFRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGJsb2NraGFzaFxuICAgICAgc2NoZWR1bGVkVHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5XG5cbiAgICAgIC8vIFNpZ24gd2l0aCB3YWxsZXQgYWRhcHRlciBpbnN0ZWFkIG9mIGtleXBhaXIgKGxpa2UgaW4gdGVzdHMpXG4gICAgICAvLyBJbiB0ZXN0czogc2NoZWR1bGVkVHJhbnNhY3Rpb24uc2lnbih7IHB1YmxpY0tleTogc29sYW5hVXNlci5wdWJsaWNLZXksIHNlY3JldEtleTogc29sYW5hVXNlci5rZXlwYWlyLnNlY3JldEtleSB9KVxuICAgICAgLy8gSW4gZnJvbnRlbmQ6IHVzZSB3YWxsZXQgYWRhcHRlciBzaWduaW5nXG4gICAgICBjb25zb2xlLmxvZygnU2lnbmluZyBkZWFjdGl2YXRlIHRyYW5zYWN0aW9uIHdpdGggZnJlc2ggYmxvY2toYXNoLi4uJylcbiAgICAgIGNvbnN0IHNpZ25lZFR4ID0gYXdhaXQgdGhpcy5zb2xhbmFVc2VyLndhbGxldEFkYXB0ZXIuc2lnblRyYW5zYWN0aW9uKHNjaGVkdWxlZFRyYW5zYWN0aW9uKVxuICAgICAgXG4gICAgICAvLyBTZW5kIHRyYW5zYWN0aW9uIGltbWVkaWF0ZWx5XG4gICAgICBjb25zb2xlLmxvZygnU2VuZGluZyBkZWFjdGl2YXRlIHRyYW5zYWN0aW9uIGltbWVkaWF0ZWx5Li4uJylcbiAgICAgIGF3YWl0IHRoaXMuY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24oc2lnbmVkVHguc2VyaWFsaXplKCksIHtcbiAgICAgICAgc2tpcFByZWZsaWdodDogZmFsc2UsXG4gICAgICAgIHByZWZsaWdodENvbW1pdG1lbnQ6ICdjb25maXJtZWQnXG4gICAgICB9KVxuXG4gICAgICAvLyBXYWl0IGZvciB0cmFuc2FjdGlvbiBleGVjdXRpb25cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uU3RhdHVzID0gYXdhaXQgdGhpcy5wcm94eUFwaS53YWl0VHJhbnNhY3Rpb25UcmVlRXhlY3V0aW9uKFxuICAgICAgICB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCwgXG4gICAgICAgIG5vbmNlLCBcbiAgICAgICAgNjAwMDBcbiAgICAgIClcblxuICAgICAgaWYgKHRyYW5zYWN0aW9uU3RhdHVzLmxlbmd0aCA9PT0gMCB8fCB0cmFuc2FjdGlvblN0YXR1c1swXS5zdGF0dXMgIT09ICdTdWNjZXNzJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlYWN0aXZhdGlvbiB0cmFuc2FjdGlvbiBmYWlsZWQgdG8gZXhlY3V0ZSBvbiBOZW9uIEVWTScpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR4SGFzaDogdHJhbnNhY3Rpb25TdGF0dXNbMF0udHJhbnNhY3Rpb25IYXNoXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgc2hhcmVhYmxlIFVSTCBmb3IgYSBwYXltZW50IGxpbmtcbiAgICovXG4gIGNyZWF0ZVBheW1lbnRVUkwobGlua0lkOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt3aW5kb3cubG9jYXRpb24ub3JpZ2lufT9wYXk9JHtsaW5rSWR9YFxuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgbGluayBJRCBmcm9tIFVSTFxuICAgKi9cbiAgc3RhdGljIGV4dHJhY3RMaW5rSWRGcm9tVVJMKHVybDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodXJsKVxuICAgICAgcmV0dXJuIHVybE9iai5zZWFyY2hQYXJhbXMuZ2V0KCdwYXknKVxuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB1c2VyJ3MgRVZNIGFkZHJlc3MgZGVyaXZlZCBmcm9tIFNvbGFuYSBwdWJsaWMga2V5XG4gICAqL1xuICBnZXRVc2VyRVZNQWRkcmVzcygpOiBzdHJpbmcgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5zb2xhbmFVc2VyPy5uZW9uV2FsbGV0IHx8IG51bGxcbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3Qgc29sYW5hTmF0aXZlQ29udHJhY3QgPSBuZXcgU29sYW5hTmF0aXZlQ29udHJhY3QoKSJdLCJuYW1lcyI6WyJDb25uZWN0aW9uIiwiUHVibGljS2V5IiwiTmVvblByb3h5UnBjQXBpIiwiY3JlYXRlQmFsYW5jZUFjY291bnRJbnN0cnVjdGlvbiIsIlNvbGFuYU5lb25BY2NvdW50IiwiZXRoZXJzIiwiaGV4bGlmeSIsInplcm9QYWRWYWx1ZSIsIkNvbnRyYWN0QUJJIiwiU09MQU5BX1RJUENBUkRfQUJJIiwiQ09OVFJBQ1RfQUREUkVTUyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19USVBDQVJEX0NPTlRSQUNUX0FERFJFU1MiLCJORU9OX0NPUkVfUlBDX1VSTCIsIk5FWFRfUFVCTElDX05FT05fUlBDX1VSTCIsIk5FT05fUFJPWFlfUlBDX1VSTCIsIlNPTEFOQV9SUENfVVJMIiwiU29sYW5hTmF0aXZlQ29udHJhY3QiLCJnZXRDaGFpbklkIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImlkIiwianNvbnJwYyIsInBhcmFtcyIsInJlc3VsdCIsImpzb24iLCJwYXJzZUludCIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJnZXROZW9uRXZtUHJvZ3JhbSIsImluaXRSZXN1bHQiLCJsb2ciLCJLZXlwYWlyIiwidGVtcEtleXBhaXIiLCJnZW5lcmF0ZSIsInByb3h5QXBpIiwiaW5pdCIsInNvbGFuYVVzZXIiLCJuZW9uRXZtUHJvZ3JhbSIsIkVycm9yIiwicHJvZ3JhbUFkZHJlc3MiLCJwcm9ncmFtSWQiLCJhcGlFcnJvciIsImluaXRXaXRoU29sYW5hV2FsbGV0Iiwid2FsbGV0QWRhcHRlciIsInB1YmxpY0tleSIsInRvQmFzZTU4IiwiY2hhaW5JZCIsInRlbXBSZXN1bHQiLCJhY3R1YWxTb2xhbmFOZW9uQWNjb3VudCIsInRva2VuTWludCIsIndhbGxldFNvbGFuYVVzZXIiLCJuZW9uV2FsbGV0IiwiYmFsYW5jZUFkZHJlc3MiLCJyZWFkT25seVByb3ZpZGVyIiwiSnNvblJwY1Byb3ZpZGVyIiwiY29udHJhY3QiLCJDb250cmFjdCIsInR4Q291bnQiLCJnZXRUcmFuc2FjdGlvbkNvdW50IiwidmVyaWZ5RXJyb3IiLCJjb2RlIiwiZ2V0Q29kZSIsImxlbmd0aCIsInJlZ2lzdGVyZWRTb2xhbmFBZGRyIiwiZ2V0U29sYW5hVXNlckFkZHJlc3MiLCJpc1VzZXJSZWdpc3RlcmVkIiwiaXNTb2xhbmFVc2VyIiwiYWNjb3VudCIsImNvbm5lY3Rpb24iLCJnZXRBY2NvdW50SW5mbyIsImJhbGFuY2VFcnJvciIsImNyZWF0ZVBheW1lbnRMaW5rIiwic3VnZ2VzdGVkQW1vdW50U09MIiwiaXNGbGV4aWJsZSIsImRlc2NyaXB0aW9uIiwiYW1vdW50TGFtcG9ydHMiLCJNYXRoIiwiZmxvb3IiLCJzY2hlZHVsZWRUcmFuc2FjdGlvbiIsInJlY2VpcHQiLCJjaGFpbk5vbmNlIiwiTnVtYmVyIiwibGFzdFVzZWROb25jZSIsIm5vbmNlIiwibWF4IiwiaWZhY2UiLCJJbnRlcmZhY2UiLCJkYXRhIiwiZW5jb2RlRnVuY3Rpb25EYXRhIiwidHJhbnNhY3Rpb25EYXRhIiwiZnJvbSIsInRvIiwidHJhbnNhY3Rpb25HYXMiLCJlc3RpbWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uR2FzIiwic29sYW5hUGF5ZXIiLCJ0cmFuc2FjdGlvbnMiLCJjcmVhdGVTY2hlZHVsZWRUcmFuc2FjdGlvbiIsImluc3RydWN0aW9ucyIsInVuc2hpZnQiLCJibG9ja2hhc2giLCJnZXRMYXRlc3RCbG9ja2hhc2giLCJyZWNlbnRCbG9ja2hhc2giLCJzaWduZXJzIiwibWFwIiwicyIsInRvU3RyaW5nIiwic2lnbmVkVHgiLCJzaWduVHJhbnNhY3Rpb24iLCJzZW5kUmF3VHJhbnNhY3Rpb24iLCJzZXJpYWxpemUiLCJza2lwUHJlZmxpZ2h0IiwicHJlZmxpZ2h0Q29tbWl0bWVudCIsInRyYW5zYWN0aW9uU3RhdHVzIiwid2FpdFRyYW5zYWN0aW9uVHJlZUV4ZWN1dGlvbiIsInR4U3RhdHVzIiwic3RhdHVzIiwidHJhbnNhY3Rpb25IYXNoIiwibGlua0lkIiwidHhIYXNoIiwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0IiwibG9ncyIsImxvZ3NCbG9vbSIsImNvbnRyYWN0QWRkcmVzcyIsImdhc1VzZWQiLCJlZmZlY3RpdmVHYXNQcmljZSIsIm5lb25SYXdUcmFuc2FjdGlvbiIsImFsbE5lb25Mb2dzIiwic29sYW5hVHJhbnNhY3Rpb25zIiwic29sVHgiLCJzb2xhbmFJbnN0cnVjdGlvbnMiLCJpbnN0cnVjdGlvbiIsIm5lb25Mb2dzIiwicHVzaCIsImFkZHJlc3MiLCJ0b0xvd2VyQ2FzZSIsImV0aGVyc0xvZyIsInRvcGljcyIsInBhcnNlZExvZyIsInBhcnNlTG9nIiwibmFtZSIsImFyZ3MiLCJlIiwidGVzdERhdGEiLCJnZXRTb2xhbmFQYXltZW50TGluayIsInJlYWRFcnJvciIsIm5lb25SZXZlcnREYXRhIiwicmV2ZXJ0UmVhc29uIiwidG9VdGY4U3RyaW5nIiwiZGVjb2RlRXJyb3IiLCJpc1JlZ2lzdGVyZWQiLCJyZWdpc3RyYXRpb25FcnJvciIsImluaXRSZWFkT25seUNvbnRyYWN0IiwiZ2V0UGF5bWVudExpbmsiLCJwYXltZW50TGluayIsImV2bUNyZWF0b3IiLCJzb2xhbmFDcmVhdG9yIiwiYW1vdW50IiwiaXNBY3RpdmUiLCJ0b3RhbFJlY2VpdmVkIiwicGF5bWVudENvdW50IiwiQmlnSW50Iiwic3RhcnRzV2l0aCIsImdldFVzZXJMaW5rcyIsInVzZXJFVk1BZGRyZXNzIiwiZ2V0VXNlclNvbGFuYUxpbmtzIiwicGF5TGluayIsImFtb3VudFNPTCIsImxpbmtEYXRhIiwidHJhbnNmZXJTaWduYXR1cmUiLCJoZXhTdHJpbmciLCJzbGljZSIsImJ5dGVzIiwiVWludDhBcnJheSIsIm1hdGNoIiwiYnl0ZSIsInJlY2lwaWVudFB1YmtleSIsImxhc3QzMkJ5dGVzIiwicGFkZGVkQnl0ZXMiLCJzZXQiLCJTeXN0ZW1Qcm9ncmFtIiwiVHJhbnNhY3Rpb24iLCJ0cmFuc2Zlckl4IiwidHJhbnNmZXIiLCJmcm9tUHVia2V5IiwidG9QdWJrZXkiLCJsYW1wb3J0cyIsInRyYW5zZmVyVHgiLCJhZGQiLCJsYXN0VmFsaWRCbG9ja0hlaWdodCIsInRyYW5zZmVyQmxvY2tIZWlnaHQiLCJmZWVQYXllciIsInNpZ25lZFRyYW5zZmVyVHgiLCJjb25maXJtVHJhbnNhY3Rpb24iLCJzaWduYXR1cmUiLCJwYXllclNvbGFuYUJ5dGVzMzIiLCJ0b0J5dGVzIiwiY29udHJhY3RCbG9ja2hhc2giLCJjb250cmFjdEJsb2NrSGVpZ2h0IiwiZGVhY3RpdmF0ZUxpbmsiLCJkZWFjdGl2YXRlQmxvY2tIZWlnaHQiLCJjcmVhdGVQYXltZW50VVJMIiwid2luZG93IiwibG9jYXRpb24iLCJvcmlnaW4iLCJleHRyYWN0TGlua0lkRnJvbVVSTCIsInVybCIsInVybE9iaiIsIlVSTCIsInNlYXJjaFBhcmFtcyIsImdldCIsImdldFVzZXJFVk1BZGRyZXNzIiwiY29uc3RydWN0b3IiLCJzb2xhbmFOYXRpdmVDb250cmFjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/solana-native-contract.ts\n"));

/***/ })

});