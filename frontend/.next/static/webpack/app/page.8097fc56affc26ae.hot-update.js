"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/solana-native-contract.ts":
/*!*****************************************!*\
  !*** ./utils/solana-native-contract.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaNativeContract: function() { return /* binding */ SolanaNativeContract; },\n/* harmony export */   solanaNativeContract: function() { return /* binding */ solanaNativeContract; }\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var _neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @neonevm/solana-sign */ \"(app-pages-browser)/./node_modules/@neonevm/solana-sign/dist/esm/index.mjs\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _contractABI_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contractABI.json */ \"(app-pages-browser)/./utils/contractABI.json\");\n\n\n\n\n// Use the actual deployed contract ABI\nconst SOLANA_TIPCARD_ABI = _contractABI_json__WEBPACK_IMPORTED_MODULE_2__;\nconst CONTRACT_ADDRESS = \"0xCFE03c7c67456D094C0162F9030393FC2cCc40Cb\" || 0;\nconst NEON_CORE_RPC_URL = \"https://devnet.neonevm.org\" || 0;\nconst NEON_PROXY_RPC_URL = \"\".concat(NEON_CORE_RPC_URL, \"/sol\");\nconst SOLANA_RPC_URL = \"https://api.devnet.solana.com\";\nclass SolanaNativeContract {\n    /**\n   * Initialize with Solana wallet using the recommended SolanaNeonAccount approach\n   */ async initWithSolanaWallet(walletAdapter) {\n        if (!walletAdapter.publicKey) {\n            throw new Error(\"Wallet not connected\");\n        }\n        try {\n            var _this_solanaUser_balanceAddress, _this_solanaUser_balanceAddress1;\n            console.log(\"\\uD83D\\uDD27 Using recommended SolanaNeonAccount approach...\");\n            console.log(\"Wallet public key:\", walletAdapter.publicKey.toBase58());\n            // Use proxyApi.init with just the public key (like demo)\n            const { provider, chainId, solanaUser, tokenMintAddress, programAddress } = await this.proxyApi.init(walletAdapter.publicKey);\n            console.log(\"- Chain ID:\", chainId);\n            console.log(\"- Neon EVM Program:\", programAddress.toBase58());\n            // Store the result with wallet adapter for signing\n            this.chainId = chainId;\n            this.solanaUser = {\n                ...solanaUser,\n                walletAdapter: walletAdapter // Add wallet adapter for signing\n            };\n            // Create balance address if it doesn't exist (using SolanaNeonAccount approach)\n            if (!this.solanaUser.balanceAddress) {\n                const account = new _neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__.SolanaNeonAccount(this.solanaUser.publicKey, this.solanaUser.neonEvmProgram, this.solanaUser.tokenMint, this.solanaUser.chainId);\n                this.solanaUser.balanceAddress = account.balanceAddress;\n            }\n            console.log(\"✅ Wallet initialized using SolanaNeonAccount approach!\");\n            console.log(\"\\uD83D\\uDCCD Connected wallet public key:\", walletAdapter.publicKey.toBase58());\n            console.log(\"\\uD83D\\uDCCD Solana user public key:\", this.solanaUser.publicKey.toBase58());\n            console.log(\"\\uD83D\\uDCCD Derived EVM address:\", this.solanaUser.neonWallet);\n            console.log(\"\\uD83D\\uDCB0 Balance address:\", ((_this_solanaUser_balanceAddress = this.solanaUser.balanceAddress) === null || _this_solanaUser_balanceAddress === void 0 ? void 0 : _this_solanaUser_balanceAddress.toBase58()) || \"Not available\");\n            console.log(\"\\uD83D\\uDD0D Full solanaUser object:\", this.solanaUser);\n            // Verify they match\n            if (walletAdapter.publicKey.toBase58() === this.solanaUser.publicKey.toBase58()) {\n                console.log(\"✅ Wallet public keys match correctly!\");\n            } else {\n                console.error(\"❌ MISMATCH: Wallet adapter and solana user have different public keys!\");\n                console.error(\"Wallet adapter:\", walletAdapter.publicKey.toBase58());\n                console.error(\"Solana user:\", this.solanaUser.publicKey.toBase58());\n            }\n            console.log(\"\\uD83D\\uDCB0 Final balance address:\", ((_this_solanaUser_balanceAddress1 = this.solanaUser.balanceAddress) === null || _this_solanaUser_balanceAddress1 === void 0 ? void 0 : _this_solanaUser_balanceAddress1.toBase58()) || \"Still not available\");\n            // Create contract instance\n            const readOnlyProvider = new ethers__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider(NEON_CORE_RPC_URL);\n            this.contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.Contract(CONTRACT_ADDRESS, SOLANA_TIPCARD_ABI, readOnlyProvider);\n            // Verify the derived EVM address is valid\n            console.log(\"\\uD83D\\uDD0D Verifying derived EVM address...\");\n            try {\n                // Check if this EVM address has been used before (has transaction history)\n                const txCount = await readOnlyProvider.getTransactionCount(this.solanaUser.neonWallet);\n                console.log(\"\\uD83D\\uDCCA EVM address transaction count:\", txCount);\n                if (txCount > 0) {\n                    console.log(\"✅ This EVM address has transaction history - it exists on-chain!\");\n                } else {\n                    console.log(\"ℹ️ This EVM address is new (no transaction history yet)\");\n                    console.log(\"ℹ️ The address will be registered on-chain when first transaction is made\");\n                }\n            } catch (verifyError) {\n                console.log(\"⚠️ Could not verify EVM address:\", verifyError);\n            }\n            // Verify contract is deployed at this address\n            try {\n                console.log(\"Verifying contract at address:\", CONTRACT_ADDRESS);\n                const code = await readOnlyProvider.getCode(CONTRACT_ADDRESS);\n                console.log(\"Contract code length:\", code.length);\n                if (code === \"0x\") {\n                    console.warn(\"⚠️ No contract code found at address:\", CONTRACT_ADDRESS);\n                    console.log(\"This might mean the contract is not deployed or address is incorrect\");\n                } else {\n                    console.log(\"✅ Contract found at address\");\n                    console.log(\"✅ Contract found and ready for transactions\");\n                }\n            } catch (verifyError) {\n                console.warn(\"Failed to verify contract:\", verifyError);\n            }\n        } catch (error) {\n            console.error(\"Failed to initialize Solana Native SDK:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Create a payment link using Solana Native SDK\n   */ async createPaymentLink(suggestedAmountSOL, isFlexible, description) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        // Convert SOL to lamports (1 SOL = 1e9 lamports)\n        const amountLamports = Math.floor(suggestedAmountSOL * 1e9);\n        try {\n            var _this_solanaUser_walletAdapter_publicKey, _scheduledTransaction_feePayer, _this_solanaUser_walletAdapter_publicKey1;\n            // Get current nonce (exactly like working examples)\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Current nonce:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"createSolanaPaymentLink\", [\n                amountLamports,\n                isFlexible,\n                description\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Debug: Check what solanaPayer we're using\n            console.log(\"\\uD83D\\uDD0D Transaction creation debug:\");\n            console.log(\"- solanaPayer for gas estimation:\", this.solanaUser.publicKey.toBase58());\n            console.log(\"- from address in transactionData:\", transactionData.from);\n            console.log(\"- nonce:\", nonce);\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            console.log(\"Gas estimation completed\");\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            console.log(\"Scheduled transaction created\");\n            // Check if balance account exists, if not create it\n            const account = await this.connection.getAccountInfo(this.solanaUser.balanceAddress);\n            if (account === null) {\n                scheduledTransaction.instructions.unshift((0,_neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__.createBalanceAccountInstruction)(this.solanaUser.neonEvmProgram, this.solanaUser.publicKey, this.solanaUser.neonWallet, this.chainId));\n            }\n            // Sign and send transaction using demo pattern\n            const { blockhash, lastValidBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            scheduledTransaction.recentBlockhash = blockhash;\n            scheduledTransaction.lastValidBlockHeight = lastValidBlockHeight;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            console.log(\"\\uD83D\\uDD0D Pre-signing debug:\");\n            console.log(\"- Connected wallet:\", (_this_solanaUser_walletAdapter_publicKey = this.solanaUser.walletAdapter.publicKey) === null || _this_solanaUser_walletAdapter_publicKey === void 0 ? void 0 : _this_solanaUser_walletAdapter_publicKey.toBase58());\n            console.log(\"- Solana user:\", this.solanaUser.publicKey.toBase58());\n            console.log(\"- Transaction feePayer:\", (_scheduledTransaction_feePayer = scheduledTransaction.feePayer) === null || _scheduledTransaction_feePayer === void 0 ? void 0 : _scheduledTransaction_feePayer.toBase58());\n            console.log(\"- Are they the same?\", ((_this_solanaUser_walletAdapter_publicKey1 = this.solanaUser.walletAdapter.publicKey) === null || _this_solanaUser_walletAdapter_publicKey1 === void 0 ? void 0 : _this_solanaUser_walletAdapter_publicKey1.toBase58()) === this.solanaUser.publicKey.toBase58());\n            // Sign with wallet adapter (demo pattern)\n            console.log(\"\\uD83D\\uDCDD Signing transaction with wallet adapter...\");\n            const signedTransaction = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            console.log(\"Submitting transaction...\");\n            const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n            // Confirm transaction (demo pattern)\n            await this.connection.confirmTransaction({\n                blockhash,\n                lastValidBlockHeight,\n                signature\n            }, \"confirmed\");\n            console.log(\"✅ Transaction submitted!\");\n            console.log(\"\\uD83D\\uDD17 Signature:\", signature);\n            // Wait for confirmation\n            console.log(\"   Waiting for payment confirmation...\");\n            await new Promise((resolve)=>setTimeout(resolve, 5000));\n            // Check transaction status\n            try {\n                var _confirmation_value;\n                const confirmation = await this.connection.getSignatureStatus(signature);\n                if ((_confirmation_value = confirmation.value) === null || _confirmation_value === void 0 ? void 0 : _confirmation_value.confirmationStatus) {\n                    console.log(\"✅ Payment status: \".concat(confirmation.value.confirmationStatus));\n                }\n                // Try to get payment details\n                try {\n                    console.log(\"   Getting payment transaction details...\");\n                    const neonTxResponse = await fetch(\"https://devnet.neonevm.org/sol\", {\n                        method: \"POST\",\n                        headers: {\n                            \"Content-Type\": \"application/json\"\n                        },\n                        body: JSON.stringify({\n                            method: \"neon_getTransactionBySenderNonce\",\n                            params: [\n                                this.solanaUser.neonWallet,\n                                nonce\n                            ],\n                            id: 1,\n                            jsonrpc: \"2.0\"\n                        })\n                    });\n                    const neonTxResult = await neonTxResponse.json();\n                    if (neonTxResult.result && neonTxResult.result.hash) {\n                        console.log(\"✅ Neon EVM payment hash: \".concat(neonTxResult.result.hash));\n                        return {\n                            linkId: neonTxResult.result.hash,\n                            txHash: neonTxResult.result.hash\n                        };\n                    } else {\n                        console.log(\"ℹ️ Neon EVM payment transaction not found yet (may still be processing)\");\n                    }\n                } catch (neonError) {\n                    console.log(\"ℹ️ Could not get Neon payment details: \".concat(neonError.message));\n                }\n            } catch (confirmError) {\n                console.log(\"ℹ️ Payment confirmation check: \".concat(confirmError.message));\n            }\n            console.log(\"\\uD83C\\uDF89 Payment transaction completed!\");\n            // Return signature as fallback\n            return {\n                linkId: signature,\n                txHash: signature\n            };\n        } catch (error) {\n            console.error(\"Error creating payment link:\", error);\n            throw error;\n        }\n    }\n    /**\n      const receipt = await this.proxyApi.getTransactionReceipt(txHash)\n      console.log('Full transaction receipt:', JSON.stringify(receipt, null, 2))\n      \n      let linkId = ''\n      \n      // Check if the transaction was successful\n      if (receipt.result?.status !== '0x1') {\n        throw new Error('Transaction failed - status: ' + receipt.result?.status)\n      }\n\n      // Enhanced debugging of the receipt structure\n      console.log('Receipt status:', receipt.result?.status)\n      console.log('Receipt logs array:', receipt.result?.logs)\n      console.log('Receipt logs length:', receipt.result?.logs?.length)\n      console.log('Receipt logsBloom:', receipt.result?.logsBloom)\n      console.log('Receipt contractAddress:', receipt.result?.contractAddress)\n      console.log('Receipt gasUsed:', receipt.result?.gasUsed)\n      console.log('Receipt effectiveGasPrice:', receipt.result?.effectiveGasPrice)\n\n      // Check if there's a different location for logs\n      console.log('Raw transaction data:', receipt.result?.neonRawTransaction)\n      \n      // Note: getTransaction method not available on NeonProxyRpcApi\n      // Transaction details are already in the receipt\n\n      // Extract all neonLogs from solanaTransactions\n      const allNeonLogs: any[] = []\n      if (receipt.result?.solanaTransactions) {\n        for (const solTx of receipt.result.solanaTransactions) {\n          if (solTx.solanaInstructions) {\n            for (const instruction of solTx.solanaInstructions) {\n              if (instruction.neonLogs && instruction.neonLogs.length > 0) {\n                allNeonLogs.push(...instruction.neonLogs)\n              }\n            }\n          }\n        }\n      }\n\n      console.log('Found', allNeonLogs.length, 'neonLogs to parse')\n\n      // Try to parse logs for the SolanaLinkCreated event\n      if (allNeonLogs.length > 0) {\n        for (const log of allNeonLogs) {\n          try {\n            console.log('Trying to parse neonLog:', log)\n            \n            // Check if this log is from our contract\n            if (log.address.toLowerCase() === CONTRACT_ADDRESS.toLowerCase()) {\n              console.log('Log is from our contract, parsing...')\n              \n              // Convert the log to the format expected by ethers\n              const ethersLog = {\n                address: log.address,\n                data: log.data,\n                topics: log.topics\n              }\n              \n              const parsedLog = iface.parseLog(ethersLog)\n              console.log('Parsed log:', parsedLog)\n              \n              if (parsedLog?.name === 'SolanaLinkCreated') {\n                linkId = parsedLog.args.linkId\n                console.log('✅ Found link ID from SolanaLinkCreated event:', linkId)\n                break\n              }\n            } else {\n              console.log('Log from different contract:', log.address)\n            }\n          } catch (e) {\n            console.log('Failed to parse neonLog:', e)\n            // Skip logs that can't be parsed\n          }\n        }\n      } else {\n        console.warn('No neonLogs found in transaction receipt!')\n        console.log('This might indicate:')\n        console.log('1. The contract call failed silently')\n        console.log('2. The contract is not at the expected address')\n        console.log('3. The contract function call reverted')\n        console.log('4. Events are not being emitted properly')\n        \n        // Try calling the contract read method to see if data was actually stored\n        try {\n          console.log('Attempting to read payment link using transaction hash as ID...')\n          const testData = await this.contract!.getSolanaPaymentLink(txHash)\n          console.log('Contract read result:', testData)\n        } catch (readError) {\n          console.log('Contract read failed:', readError)\n        }\n      }\n\n      // If we couldn't extract from logs, investigate further\n      if (!linkId) {\n        console.error('Could not extract link ID from transaction events!')\n        console.log('This suggests the contract call may have failed silently')\n        \n        // Check if the transaction actually reverted\n        console.log('Checking for revert data...')\n        if (receipt.result?.neonRevertData) {\n          console.log('Revert data found:', receipt.result.neonRevertData)\n          try {\n            // Try to decode the revert reason\n            const revertReason = ethers.toUtf8String(receipt.result.neonRevertData)\n            console.log('Revert reason:', revertReason)\n            throw new Error(`Contract call reverted: ${revertReason}`)\n          } catch (decodeError) {\n            console.log('Could not decode revert reason:', decodeError)\n            throw new Error('Contract call reverted with unknown reason')\n          }\n        }\n        \n        // Let's try to understand why the event wasn't emitted\n        console.log('Analyzing function call...')\n        console.log('Contract address:', CONTRACT_ADDRESS)\n        console.log('From address:', this.solanaUser.neonWallet)\n        console.log('Function data in raw tx:', receipt.result?.neonRawTransaction)\n        \n        // Check if user is registered\n        try {\n          const isRegistered = await this.contract!.isSolanaUser(this.solanaUser.neonWallet)\n          console.log('Is user registered as Solana user:', isRegistered)\n          \n          if (!isRegistered) {\n            throw new Error('User is not registered as a Solana user with the contract. This is required to create payment links.')\n          }\n        } catch (registrationError) {\n          console.error('Failed to check user registration:', registrationError)\n          throw registrationError\n        }\n        \n        // If we get here, something else went wrong\n        throw new Error('Payment link creation failed: Contract call executed but no event was emitted. The transaction may have failed silently.')\n      }\n\n      return {\n        linkId,\n        txHash\n      }\n    } catch (error: any) {\n      console.error('Error creating payment link:', error)\n      throw error\n    }\n  }\n\n  /**\n   * Initialize read-only contract access (without wallet)\n   */ async initReadOnlyContract() {\n        if (!this.contract) {\n            // Create a simple JSON RPC provider for read operations\n            const readOnlyProvider = new ethers__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider(NEON_CORE_RPC_URL);\n            this.contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.Contract(CONTRACT_ADDRESS, SOLANA_TIPCARD_ABI, readOnlyProvider);\n        }\n    }\n    /**\n   * Get payment link details\n   */ async getPaymentLink(linkId) {\n        // Initialize contract if not already done\n        if (!this.contract) {\n            await this.initReadOnlyContract();\n        }\n        console.log(\"Getting payment link with ID:\", linkId);\n        console.log(\"Contract address:\", CONTRACT_ADDRESS);\n        try {\n            const result = await this.contract.getSolanaPaymentLink(linkId);\n            console.log(\"Raw contract result:\", result);\n            const paymentLink = {\n                evmCreator: result.evmCreator,\n                solanaCreator: result.solanaCreator,\n                amount: result.amount,\n                isFlexible: result.isFlexible,\n                isActive: result.isActive,\n                totalReceived: result.totalReceived,\n                paymentCount: Number(result.paymentCount),\n                description: result.description\n            };\n            // Check if this looks like an empty/non-existent link (transaction not processed yet)\n            if (result.evmCreator === \"0x0000000000000000000000000000000000000000\" && result.amount === BigInt(0) && !result.isActive) {\n                console.warn(\"Payment link appears to be empty/non-existent\");\n                // If this looks like a transaction hash (66 chars, starts with 0x), provide helpful info\n                if (linkId.length === 66 && linkId.startsWith(\"0x\")) {\n                    console.log(\"\\uD83D\\uDCA1 This appears to be a transaction hash - the payment link may still be processing\");\n                    console.log(\"\\uD83D\\uDCA1 Neon operators will eventually process this transaction and create the payment link\");\n                    console.log(\"\\uD83D\\uDCA1 You can bookmark this link and try again in a few minutes\");\n                    // For now, don't throw an error - let the UI handle the empty data gracefully\n                    console.log(\"Returning empty payment link data - transaction may still be processing\");\n                }\n            }\n            return paymentLink;\n        } catch (error) {\n            console.error(\"Contract call error:\", error);\n            throw new Error(\"Payment link not found or contract error\");\n        }\n    }\n    /**\n   * Get user's payment links\n   */ async getUserLinks(userEVMAddress) {\n        // Initialize contract if not already done\n        if (!this.contract) {\n            await this.initReadOnlyContract();\n        }\n        try {\n            return await this.contract.getUserSolanaLinks(userEVMAddress);\n        } catch (error) {\n            console.error(\"Error getting user links:\", error);\n            return [];\n        }\n    }\n    /**\n   * Pay a payment link using Solana Native SDK\n   */ async payLink(linkId, amountSOL) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        console.log(\"Starting payment process...\");\n        console.log(\"Link ID:\", linkId);\n        console.log(\"Amount SOL:\", amountSOL);\n        // First, get the payment link details to find the recipient\n        const linkData = await this.getPaymentLink(linkId);\n        console.log(\"Payment link data:\", linkData);\n        if (!linkData.isActive) {\n            throw new Error(\"Payment link is no longer active\");\n        }\n        // Convert SOL to lamports\n        const amountLamports = Math.floor(amountSOL * 1e9);\n        let transferSignature;\n        try {\n            var _hexString_match, _transactionStatus_, _transactionStatus_1;\n            // Step 1: Perform the actual SOL transfer first\n            console.log(\"Step 1: Performing SOL transfer...\");\n            console.log(\"From:\", this.solanaUser.publicKey.toBase58());\n            console.log(\"To recipient bytes32:\", linkData.solanaCreator);\n            console.log(\"Amount lamports:\", amountLamports);\n            // Convert recipient Solana address from bytes32 to PublicKey\n            // Remove '0x' prefix if present\n            const hexString = linkData.solanaCreator.startsWith(\"0x\") ? linkData.solanaCreator.slice(2) : linkData.solanaCreator;\n            // Convert hex string to byte array\n            const bytes = new Uint8Array(((_hexString_match = hexString.match(/.{2}/g)) === null || _hexString_match === void 0 ? void 0 : _hexString_match.map((byte)=>parseInt(byte, 16))) || []);\n            // For bytes32 from Solana addresses, we need to find the actual 32-byte public key\n            // The bytes32 should contain the 32-byte Solana public key, possibly with leading zeros\n            let recipientPubkey;\n            if (bytes.length === 32) {\n                // Direct conversion from 32 bytes\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(bytes);\n            } else if (bytes.length > 32) {\n                // Take the last 32 bytes if it's longer\n                const last32Bytes = bytes.slice(-32);\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(last32Bytes);\n            } else {\n                // Pad with leading zeros if shorter\n                const paddedBytes = new Uint8Array(32);\n                paddedBytes.set(bytes, 32 - bytes.length);\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(paddedBytes);\n            }\n            console.log(\"Recipient PublicKey:\", recipientPubkey.toBase58());\n            // Create the SOL transfer transaction\n            const { SystemProgram, Transaction } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"));\n            // Create transfer instruction\n            const transferIx = SystemProgram.transfer({\n                fromPubkey: this.solanaUser.publicKey,\n                toPubkey: recipientPubkey,\n                lamports: amountLamports\n            });\n            // Create transaction\n            const transferTx = new Transaction().add(transferIx);\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for SOL transfer...\");\n            const { blockhash, lastValidBlockHeight: transferBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh SOL transfer blockhash:\", blockhash);\n            console.log(\"Last valid block height:\", transferBlockHeight);\n            transferTx.recentBlockhash = blockhash;\n            transferTx.feePayer = this.solanaUser.publicKey;\n            // Sign and send the SOL transfer immediately\n            console.log(\"Signing and sending SOL transfer with fresh blockhash...\");\n            const signedTransferTx = await this.solanaUser.walletAdapter.signTransaction(transferTx);\n            transferSignature = await this.connection.sendRawTransaction(signedTransferTx.serialize());\n            console.log(\"SOL transfer sent:\", transferSignature);\n            // Wait for transfer confirmation using the modern API\n            await this.connection.confirmTransaction({\n                signature: transferSignature,\n                ...await this.connection.getLatestBlockhash()\n            });\n            console.log(\"SOL transfer confirmed\");\n            // Step 2: Record the payment in the contract\n            console.log(\"Step 2: Recording payment in contract...\");\n            // Convert Solana PublicKey to bytes32\n            const payerSolanaBytes32 = (0,ethers__WEBPACK_IMPORTED_MODULE_6__.zeroPadValue)((0,ethers__WEBPACK_IMPORTED_MODULE_6__.hexlify)(this.solanaUser.publicKey.toBytes()), 32);\n            // Get current nonce\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Current nonce:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"paySolanaLink\", [\n                linkId,\n                amountLamports,\n                payerSolanaBytes32\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for contract call...\");\n            const { blockhash: contractBlockhash, lastValidBlockHeight: contractBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh contract call blockhash:\", contractBlockhash);\n            console.log(\"Last valid block height:\", contractBlockHeight);\n            scheduledTransaction.recentBlockhash = contractBlockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            // Sign with wallet adapter instead of keypair (like in tests)\n            // In tests: scheduledTransaction.sign({ publicKey: solanaUser.publicKey, secretKey: solanaUser.keypair.secretKey })\n            // In frontend: use wallet adapter signing\n            console.log(\"Signing contract call with fresh blockhash...\");\n            const signedTx = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            // Send transaction immediately\n            console.log(\"Sending contract call transaction immediately...\");\n            await this.connection.sendRawTransaction(signedTx.serialize());\n            // Wait for transaction execution on Neon EVM\n            const transactionStatus = await this.proxyApi.waitTransactionTreeExecution(this.solanaUser.neonWallet, nonce, 60000);\n            if (transactionStatus.length === 0 || transactionStatus[0].status !== \"Success\") {\n                console.warn(\"Contract payment recording failed, but SOL transfer succeeded\");\n                console.log(\"Transfer signature:\", transferSignature);\n            // Don't throw error - the payment went through even if recording failed\n            }\n            console.log(\"Payment completed successfully!\");\n            console.log(\"SOL transfer:\", transferSignature);\n            console.log(\"Contract record:\", (_transactionStatus_ = transactionStatus[0]) === null || _transactionStatus_ === void 0 ? void 0 : _transactionStatus_.transactionHash);\n            return {\n                txHash: ((_transactionStatus_1 = transactionStatus[0]) === null || _transactionStatus_1 === void 0 ? void 0 : _transactionStatus_1.transactionHash) || \"contract-recording-failed\",\n                transferSignature\n            };\n        } catch (error) {\n            console.error(\"Error paying link:\", error);\n            if (transferSignature) {\n                console.log(\"Note: SOL transfer may have succeeded:\", transferSignature);\n            }\n            throw error;\n        }\n    }\n    /**\n   * Deactivate a payment link\n   */ async deactivateLink(linkId) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        try {\n            // Get current nonce\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Current nonce:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"deactivateSolanaLink\", [\n                linkId\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for deactivate transaction...\");\n            const { blockhash, lastValidBlockHeight: deactivateBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh deactivate blockhash:\", blockhash);\n            console.log(\"Last valid block height:\", deactivateBlockHeight);\n            scheduledTransaction.recentBlockhash = blockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            // Sign with wallet adapter instead of keypair (like in tests)\n            // In tests: scheduledTransaction.sign({ publicKey: solanaUser.publicKey, secretKey: solanaUser.keypair.secretKey })\n            // In frontend: use wallet adapter signing\n            console.log(\"Signing deactivate transaction with fresh blockhash...\");\n            const signedTx = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            // Send transaction immediately\n            console.log(\"Sending deactivate transaction immediately...\");\n            await this.connection.sendRawTransaction(signedTx.serialize());\n            // Wait for transaction execution\n            const transactionStatus = await this.proxyApi.waitTransactionTreeExecution(this.solanaUser.neonWallet, nonce, 60000);\n            if (transactionStatus.length === 0 || transactionStatus[0].status !== \"Success\") {\n                throw new Error(\"Deactivation transaction failed to execute on Neon EVM\");\n            }\n            return {\n                txHash: transactionStatus[0].transactionHash\n            };\n        } catch (error) {\n            throw error;\n        }\n    }\n    /**\n   * Create a shareable URL for a payment link\n   */ createPaymentURL(linkId) {\n        return \"\".concat(window.location.origin, \"?pay=\").concat(linkId);\n    }\n    /**\n   * Extract link ID from URL\n   */ static extractLinkIdFromURL(url) {\n        try {\n            const urlObj = new URL(url);\n            return urlObj.searchParams.get(\"pay\");\n        } catch (e) {\n            return null;\n        }\n    }\n    /**\n   * Get the user's EVM address derived from Solana public key\n   */ getUserEVMAddress() {\n        var _this_solanaUser;\n        return ((_this_solanaUser = this.solanaUser) === null || _this_solanaUser === void 0 ? void 0 : _this_solanaUser.neonWallet) || null;\n    }\n    constructor(){\n        this.chainId = null;\n        this.contract = null;\n        this.connection = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Connection(SOLANA_RPC_URL, \"confirmed\");\n        this.proxyApi = new _neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__.NeonProxyRpcApi(NEON_PROXY_RPC_URL);\n    }\n}\n// Export singleton instance\nconst solanaNativeContract = new SolanaNativeContract();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3NvbGFuYS1uYXRpdmUtY29udHJhY3QudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQWdFO0FBQzBDO0FBQ3BEO0FBQ1Y7QUFFNUMsdUNBQXVDO0FBQ3ZDLE1BQU1RLHFCQUFxQkQsOENBQVdBO0FBRXRDLE1BQU1FLG1CQUFtQkMsNENBQWdELElBQUk7QUFDN0UsTUFBTUcsb0JBQW9CSCw0QkFBb0MsSUFBSTtBQUNsRSxNQUFNSyxxQkFBcUIsR0FBcUIsT0FBbEJGLG1CQUFrQjtBQUNoRCxNQUFNRyxpQkFBaUI7QUFhaEIsTUFBTUM7SUFhWDs7R0FFQyxHQUNELE1BQU1DLHFCQUFxQkMsYUFBa0IsRUFBaUI7UUFDNUQsSUFBSSxDQUFDQSxjQUFjQyxTQUFTLEVBQUU7WUFDNUIsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBRUEsSUFBSTtnQkFzQ2lDLGlDQVdNO1lBaER6Q0MsUUFBUUMsR0FBRyxDQUFDO1lBQ1pELFFBQVFDLEdBQUcsQ0FBQyxzQkFBc0JKLGNBQWNDLFNBQVMsQ0FBQ0ksUUFBUTtZQUVsRSx5REFBeUQ7WUFDekQsTUFBTSxFQUNKQyxRQUFRLEVBQ1JDLE9BQU8sRUFDUEMsVUFBVSxFQUNWQyxnQkFBZ0IsRUFDaEJDLGNBQWMsRUFDZixHQUFHLE1BQU0sSUFBSSxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ1osY0FBY0MsU0FBUztZQUVwREUsUUFBUUMsR0FBRyxDQUFDLGVBQWVHO1lBQzNCSixRQUFRQyxHQUFHLENBQUMsdUJBQXVCTSxlQUFlTCxRQUFRO1lBRTFELG1EQUFtRDtZQUNuRCxJQUFJLENBQUNFLE9BQU8sR0FBR0E7WUFDZixJQUFJLENBQUNDLFVBQVUsR0FBRztnQkFDaEIsR0FBR0EsVUFBVTtnQkFDYlIsZUFBZUEsY0FBYyxpQ0FBaUM7WUFDaEU7WUFFQSxnRkFBZ0Y7WUFDaEYsSUFBSSxDQUFDLElBQUksQ0FBQ1EsVUFBVSxDQUFDSyxjQUFjLEVBQUU7Z0JBQ25DLE1BQU1D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d0IsaUJBQWlCLENBQUMsRUFBRSxDQUFDK0IsZUFBZTtZQUM5QztRQUNGLEVBQUUsT0FBTzlILE9BQVk7WUFDbkIsTUFBTUE7UUFDUjtJQUNGO0lBRUE7O0dBRUMsR0FDRGlJLGlCQUFpQjNELE1BQWMsRUFBVTtRQUN2QyxPQUFPLEdBQWlDQSxPQUE5QjRELE9BQU9DLFFBQVEsQ0FBQ0MsTUFBTSxFQUFDLFNBQWMsT0FBUDlEO0lBQzFDO0lBRUE7O0dBRUMsR0FDRCxPQUFPK0QscUJBQXFCQyxHQUFXLEVBQWlCO1FBQ3RELElBQUk7WUFDRixNQUFNQyxTQUFTLElBQUlDLElBQUlGO1lBQ3ZCLE9BQU9DLE9BQU9FLFlBQVksQ0FBQ0MsR0FBRyxDQUFDO1FBQ2pDLEVBQUUsVUFBTTtZQUNOLE9BQU87UUFDVDtJQUNGO0lBRUE7O0dBRUMsR0FDREMsb0JBQW1DO1lBQzFCO1FBQVAsT0FBTyx5QkFBSSxDQUFDckosVUFBVSxjQUFmLHdEQUFpQlMsVUFBVSxLQUFJO0lBQ3hDO0lBNXdCQTZJLGFBQWM7YUFITnZKLFVBQXlCO2FBQ3pCYyxXQUFtQztRQUd6QyxJQUFJLENBQUMrQixVQUFVLEdBQUcsSUFBSXZFLHVEQUFVQSxDQUFDZ0IsZ0JBQWdCO1FBQ2pELElBQUksQ0FBQ2MsUUFBUSxHQUFHLElBQUk3QixpRUFBZUEsQ0FBQ2M7SUFDdEM7QUEwd0JGO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU1tSyx1QkFBdUIsSUFBSWpLLHVCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy9zb2xhbmEtbmF0aXZlLWNvbnRyYWN0LnRzP2Q0YzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29ubmVjdGlvbiwgUHVibGljS2V5LCBLZXlwYWlyIH0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJ1xuaW1wb3J0IHsgTmVvblByb3h5UnBjQXBpLCBjcmVhdGVCYWxhbmNlQWNjb3VudEluc3RydWN0aW9uLCBTb2xhbmFOZW9uQWNjb3VudCB9IGZyb20gJ0BuZW9uZXZtL3NvbGFuYS1zaWduJ1xuaW1wb3J0IHsgZXRoZXJzLCBoZXhsaWZ5LCB6ZXJvUGFkVmFsdWUgfSBmcm9tICdldGhlcnMnXG5pbXBvcnQgQ29udHJhY3RBQkkgZnJvbSAnLi9jb250cmFjdEFCSS5qc29uJ1xuXG4vLyBVc2UgdGhlIGFjdHVhbCBkZXBsb3llZCBjb250cmFjdCBBQklcbmNvbnN0IFNPTEFOQV9USVBDQVJEX0FCSSA9IENvbnRyYWN0QUJJXG5cbmNvbnN0IENPTlRSQUNUX0FERFJFU1MgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19USVBDQVJEX0NPTlRSQUNUX0FERFJFU1MgfHwgJzB4Q0ZFMDNjN2M2NzQ1NkQwOTRDMDE2MkY5MDMwMzkzRkMyY0NjNDBDYidcbmNvbnN0IE5FT05fQ09SRV9SUENfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfTkVPTl9SUENfVVJMIHx8ICdodHRwczovL2Rldm5ldC5uZW9uZXZtLm9yZy9zb2wnXG5jb25zdCBORU9OX1BST1hZX1JQQ19VUkwgPSBgJHtORU9OX0NPUkVfUlBDX1VSTH0vc29sYFxuY29uc3QgU09MQU5BX1JQQ19VUkwgPSAnaHR0cHM6Ly9hcGkuZGV2bmV0LnNvbGFuYS5jb20nXG5cbmV4cG9ydCBpbnRlcmZhY2UgUGF5bWVudExpbmsge1xuICBldm1DcmVhdG9yOiBzdHJpbmdcbiAgc29sYW5hQ3JlYXRvcjogc3RyaW5nXG4gIGFtb3VudDogYmlnaW50XG4gIGlzRmxleGlibGU6IGJvb2xlYW5cbiAgaXNBY3RpdmU6IGJvb2xlYW5cbiAgdG90YWxSZWNlaXZlZDogYmlnaW50XG4gIHBheW1lbnRDb3VudDogbnVtYmVyXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcbn1cblxuZXhwb3J0IGNsYXNzIFNvbGFuYU5hdGl2ZUNvbnRyYWN0IHtcbiAgcHJpdmF0ZSBjb25uZWN0aW9uOiBDb25uZWN0aW9uXG4gIHByaXZhdGUgcHJveHlBcGk6IE5lb25Qcm94eVJwY0FwaVxuICBwcml2YXRlIHNvbGFuYVVzZXI6IGFueVxuICBwcml2YXRlIGNoYWluSWQ6IG51bWJlciB8IG51bGwgPSBudWxsXG4gIHByaXZhdGUgY29udHJhY3Q6IGV0aGVycy5Db250cmFjdCB8IG51bGwgPSBudWxsXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb25uZWN0aW9uID0gbmV3IENvbm5lY3Rpb24oU09MQU5BX1JQQ19VUkwsICdjb25maXJtZWQnKVxuICAgIHRoaXMucHJveHlBcGkgPSBuZXcgTmVvblByb3h5UnBjQXBpKE5FT05fUFJPWFlfUlBDX1VSTClcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgd2l0aCBTb2xhbmEgd2FsbGV0IHVzaW5nIHRoZSByZWNvbW1lbmRlZCBTb2xhbmFOZW9uQWNjb3VudCBhcHByb2FjaFxuICAgKi9cbiAgYXN5bmMgaW5pdFdpdGhTb2xhbmFXYWxsZXQod2FsbGV0QWRhcHRlcjogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF3YWxsZXRBZGFwdGVyLnB1YmxpY0tleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGNvbm5lY3RlZCcpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SnIFVzaW5nIHJlY29tbWVuZGVkIFNvbGFuYU5lb25BY2NvdW50IGFwcHJvYWNoLi4uJylcbiAgICAgIGNvbnNvbGUubG9nKCdXYWxsZXQgcHVibGljIGtleTonLCB3YWxsZXRBZGFwdGVyLnB1YmxpY0tleS50b0Jhc2U1OCgpKVxuICAgICAgXG4gICAgICAvLyBVc2UgcHJveHlBcGkuaW5pdCB3aXRoIGp1c3QgdGhlIHB1YmxpYyBrZXkgKGxpa2UgZGVtbylcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIHNvbGFuYVVzZXIsXG4gICAgICAgIHRva2VuTWludEFkZHJlc3MsXG4gICAgICAgIHByb2dyYW1BZGRyZXNzXG4gICAgICB9ID0gYXdhaXQgdGhpcy5wcm94eUFwaS5pbml0KHdhbGxldEFkYXB0ZXIucHVibGljS2V5KVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnLSBDaGFpbiBJRDonLCBjaGFpbklkKVxuICAgICAgY29uc29sZS5sb2coJy0gTmVvbiBFVk0gUHJvZ3JhbTonLCBwcm9ncmFtQWRkcmVzcy50b0Jhc2U1OCgpKVxuICAgICAgXG4gICAgICAvLyBTdG9yZSB0aGUgcmVzdWx0IHdpdGggd2FsbGV0IGFkYXB0ZXIgZm9yIHNpZ25pbmdcbiAgICAgIHRoaXMuY2hhaW5JZCA9IGNoYWluSWRcbiAgICAgIHRoaXMuc29sYW5hVXNlciA9IHtcbiAgICAgICAgLi4uc29sYW5hVXNlcixcbiAgICAgICAgd2FsbGV0QWRhcHRlcjogd2FsbGV0QWRhcHRlciAvLyBBZGQgd2FsbGV0IGFkYXB0ZXIgZm9yIHNpZ25pbmdcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGJhbGFuY2UgYWRkcmVzcyBpZiBpdCBkb2Vzbid0IGV4aXN0ICh1c2luZyBTb2xhbmFOZW9uQWNjb3VudCBhcHByb2FjaClcbiAgICAgIGlmICghdGhpcy5zb2xhbmFVc2VyLmJhbGFuY2VBZGRyZXNzKSB7XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBuZXcgU29sYW5hTmVvbkFjY291bnQoXG4gICAgICAgICAgdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleSxcbiAgICAgICAgICB0aGlzLnNvbGFuYVVzZXIubmVvbkV2bVByb2dyYW0sXG4gICAgICAgICAgdGhpcy5zb2xhbmFVc2VyLnRva2VuTWludCxcbiAgICAgICAgICB0aGlzLnNvbGFuYVVzZXIuY2hhaW5JZFxuICAgICAgICApXG4gICAgICAgIHRoaXMuc29sYW5hVXNlci5iYWxhbmNlQWRkcmVzcyA9IGFjY291bnQuYmFsYW5jZUFkZHJlc3NcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ+KchSBXYWxsZXQgaW5pdGlhbGl6ZWQgdXNpbmcgU29sYW5hTmVvbkFjY291bnQgYXBwcm9hY2ghJylcbiAgICAgIGNvbnNvbGUubG9nKCfwn5ONIENvbm5lY3RlZCB3YWxsZXQgcHVibGljIGtleTonLCB3YWxsZXRBZGFwdGVyLnB1YmxpY0tleS50b0Jhc2U1OCgpKVxuICAgICAgY29uc29sZS5sb2coJ/Cfk40gU29sYW5hIHVzZXIgcHVibGljIGtleTonLCB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LnRvQmFzZTU4KCkpXG4gICAgICBjb25zb2xlLmxvZygn8J+TjSBEZXJpdmVkIEVWTSBhZGRyZXNzOicsIHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0KVxuICAgICAgY29uc29sZS5sb2coJ/CfkrAgQmFsYW5jZSBhZGRyZXNzOicsIHRoaXMuc29sYW5hVXNlci5iYWxhbmNlQWRkcmVzcz8udG9CYXNlNTgoKSB8fCAnTm90IGF2YWlsYWJsZScpXG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBGdWxsIHNvbGFuYVVzZXIgb2JqZWN0OicsIHRoaXMuc29sYW5hVXNlcilcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IHRoZXkgbWF0Y2hcbiAgICAgIGlmICh3YWxsZXRBZGFwdGVyLnB1YmxpY0tleS50b0Jhc2U1OCgpID09PSB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LnRvQmFzZTU4KCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBXYWxsZXQgcHVibGljIGtleXMgbWF0Y2ggY29ycmVjdGx5IScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgTUlTTUFUQ0g6IFdhbGxldCBhZGFwdGVyIGFuZCBzb2xhbmEgdXNlciBoYXZlIGRpZmZlcmVudCBwdWJsaWMga2V5cyEnKVxuICAgICAgICBjb25zb2xlLmVycm9yKCdXYWxsZXQgYWRhcHRlcjonLCB3YWxsZXRBZGFwdGVyLnB1YmxpY0tleS50b0Jhc2U1OCgpKVxuICAgICAgICBjb25zb2xlLmVycm9yKCdTb2xhbmEgdXNlcjonLCB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LnRvQmFzZTU4KCkpXG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZygn8J+SsCBGaW5hbCBiYWxhbmNlIGFkZHJlc3M6JywgdGhpcy5zb2xhbmFVc2VyLmJhbGFuY2VBZGRyZXNzPy50b0Jhc2U1OCgpIHx8ICdTdGlsbCBub3QgYXZhaWxhYmxlJylcblxuICAgICAgLy8gQ3JlYXRlIGNvbnRyYWN0IGluc3RhbmNlXG4gICAgICBjb25zdCByZWFkT25seVByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoTkVPTl9DT1JFX1JQQ19VUkwpXG4gICAgICB0aGlzLmNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChDT05UUkFDVF9BRERSRVNTLCBTT0xBTkFfVElQQ0FSRF9BQkksIHJlYWRPbmx5UHJvdmlkZXIpXG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSB0aGUgZGVyaXZlZCBFVk0gYWRkcmVzcyBpcyB2YWxpZFxuICAgICAgY29uc29sZS5sb2coJ/CflI0gVmVyaWZ5aW5nIGRlcml2ZWQgRVZNIGFkZHJlc3MuLi4nKVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBFVk0gYWRkcmVzcyBoYXMgYmVlbiB1c2VkIGJlZm9yZSAoaGFzIHRyYW5zYWN0aW9uIGhpc3RvcnkpXG4gICAgICAgIGNvbnN0IHR4Q291bnQgPSBhd2FpdCByZWFkT25seVByb3ZpZGVyLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQpXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OKIEVWTSBhZGRyZXNzIHRyYW5zYWN0aW9uIGNvdW50OicsIHR4Q291bnQpXG4gICAgICAgIFxuICAgICAgICBpZiAodHhDb3VudCA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIFRoaXMgRVZNIGFkZHJlc3MgaGFzIHRyYW5zYWN0aW9uIGhpc3RvcnkgLSBpdCBleGlzdHMgb24tY2hhaW4hJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygn4oS577iPIFRoaXMgRVZNIGFkZHJlc3MgaXMgbmV3IChubyB0cmFuc2FjdGlvbiBoaXN0b3J5IHlldCknKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCfihLnvuI8gVGhlIGFkZHJlc3Mgd2lsbCBiZSByZWdpc3RlcmVkIG9uLWNoYWluIHdoZW4gZmlyc3QgdHJhbnNhY3Rpb24gaXMgbWFkZScpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHZlcmlmeUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gQ291bGQgbm90IHZlcmlmeSBFVk0gYWRkcmVzczonLCB2ZXJpZnlFcnJvcilcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IGNvbnRyYWN0IGlzIGRlcGxveWVkIGF0IHRoaXMgYWRkcmVzc1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coJ1ZlcmlmeWluZyBjb250cmFjdCBhdCBhZGRyZXNzOicsIENPTlRSQUNUX0FERFJFU1MpXG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCByZWFkT25seVByb3ZpZGVyLmdldENvZGUoQ09OVFJBQ1RfQUREUkVTUylcbiAgICAgICAgY29uc29sZS5sb2coJ0NvbnRyYWN0IGNvZGUgbGVuZ3RoOicsIGNvZGUubGVuZ3RoKVxuICAgICAgICBpZiAoY29kZSA9PT0gJzB4Jykge1xuICAgICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIE5vIGNvbnRyYWN0IGNvZGUgZm91bmQgYXQgYWRkcmVzczonLCBDT05UUkFDVF9BRERSRVNTKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCdUaGlzIG1pZ2h0IG1lYW4gdGhlIGNvbnRyYWN0IGlzIG5vdCBkZXBsb3llZCBvciBhZGRyZXNzIGlzIGluY29ycmVjdCcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBDb250cmFjdCBmb3VuZCBhdCBhZGRyZXNzJylcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIENvbnRyYWN0IGZvdW5kIGFuZCByZWFkeSBmb3IgdHJhbnNhY3Rpb25zJylcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAodmVyaWZ5RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gdmVyaWZ5IGNvbnRyYWN0OicsIHZlcmlmeUVycm9yKVxuICAgICAgfVxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIFNvbGFuYSBOYXRpdmUgU0RLOicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgcGF5bWVudCBsaW5rIHVzaW5nIFNvbGFuYSBOYXRpdmUgU0RLXG4gICAqL1xuICBhc3luYyBjcmVhdGVQYXltZW50TGluayhcbiAgICBzdWdnZXN0ZWRBbW91bnRTT0w6IG51bWJlcixcbiAgICBpc0ZsZXhpYmxlOiBib29sZWFuLFxuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgKTogUHJvbWlzZTx7IGxpbmtJZDogc3RyaW5nOyB0eEhhc2g6IHN0cmluZyB9PiB7XG4gICAgaWYgKCF0aGlzLnNvbGFuYVVzZXIgfHwgIXRoaXMuY29udHJhY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIGNvbm5lY3Qgd2FsbGV0IGZpcnN0JylcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IFNPTCB0byBsYW1wb3J0cyAoMSBTT0wgPSAxZTkgbGFtcG9ydHMpXG4gICAgY29uc3QgYW1vdW50TGFtcG9ydHMgPSBNYXRoLmZsb29yKHN1Z2dlc3RlZEFtb3VudFNPTCAqIDFlOSlcblxuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgY3VycmVudCBub25jZSAoZXhhY3RseSBsaWtlIHdvcmtpbmcgZXhhbXBsZXMpXG4gICAgICBjb25zdCBub25jZSA9IE51bWJlcihhd2FpdCB0aGlzLnByb3h5QXBpLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQpKVxuICAgICAgY29uc29sZS5sb2coJ0N1cnJlbnQgbm9uY2U6Jywgbm9uY2UpXG5cbiAgICAgIC8vIFByZXBhcmUgY29udHJhY3QgY2FsbCBkYXRhXG4gICAgICBjb25zdCBpZmFjZSA9IG5ldyBldGhlcnMuSW50ZXJmYWNlKFNPTEFOQV9USVBDQVJEX0FCSSlcbiAgICAgIGNvbnN0IGRhdGEgPSBpZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoJ2NyZWF0ZVNvbGFuYVBheW1lbnRMaW5rJywgW1xuICAgICAgICBhbW91bnRMYW1wb3J0cyxcbiAgICAgICAgaXNGbGV4aWJsZSxcbiAgICAgICAgZGVzY3JpcHRpb25cbiAgICAgIF0pXG5cbiAgICAgIC8vIENyZWF0ZSB0cmFuc2FjdGlvbiBkYXRhXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkRhdGEgPSB7XG4gICAgICAgIGZyb206IHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0LFxuICAgICAgICB0bzogQ09OVFJBQ1RfQUREUkVTUyxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfVxuXG4gICAgICAvLyBEZWJ1ZzogQ2hlY2sgd2hhdCBzb2xhbmFQYXllciB3ZSdyZSB1c2luZ1xuICAgICAgY29uc29sZS5sb2coJ/CflI0gVHJhbnNhY3Rpb24gY3JlYXRpb24gZGVidWc6JylcbiAgICAgIGNvbnNvbGUubG9nKCctIHNvbGFuYVBheWVyIGZvciBnYXMgZXN0aW1hdGlvbjonLCB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LnRvQmFzZTU4KCkpXG4gICAgICBjb25zb2xlLmxvZygnLSBmcm9tIGFkZHJlc3MgaW4gdHJhbnNhY3Rpb25EYXRhOicsIHRyYW5zYWN0aW9uRGF0YS5mcm9tKVxuICAgICAgY29uc29sZS5sb2coJy0gbm9uY2U6Jywgbm9uY2UpXG5cbiAgICAgIC8vIEVzdGltYXRlIGdhc1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25HYXMgPSBhd2FpdCB0aGlzLnByb3h5QXBpLmVzdGltYXRlU2NoZWR1bGVkVHJhbnNhY3Rpb25HYXMoe1xuICAgICAgICBzb2xhbmFQYXllcjogdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleSxcbiAgICAgICAgdHJhbnNhY3Rpb25zOiBbdHJhbnNhY3Rpb25EYXRhXSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnNvbGUubG9nKCdHYXMgZXN0aW1hdGlvbiBjb21wbGV0ZWQnKVxuXG4gICAgICAvLyBDcmVhdGUgc2NoZWR1bGVkIHRyYW5zYWN0aW9uXG4gICAgICBsZXQgeyBzY2hlZHVsZWRUcmFuc2FjdGlvbiB9ID0gYXdhaXQgdGhpcy5wcm94eUFwaS5jcmVhdGVTY2hlZHVsZWRUcmFuc2FjdGlvbih7XG4gICAgICAgIHRyYW5zYWN0aW9uR2FzLFxuICAgICAgICB0cmFuc2FjdGlvbkRhdGEsXG4gICAgICAgIG5vbmNlXG4gICAgICB9KVxuXG4gICAgICBjb25zb2xlLmxvZygnU2NoZWR1bGVkIHRyYW5zYWN0aW9uIGNyZWF0ZWQnKVxuXG4gICAgICAvLyBDaGVjayBpZiBiYWxhbmNlIGFjY291bnQgZXhpc3RzLCBpZiBub3QgY3JlYXRlIGl0XG4gICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldEFjY291bnRJbmZvKHRoaXMuc29sYW5hVXNlci5iYWxhbmNlQWRkcmVzcylcbiAgICAgIGlmIChhY2NvdW50ID09PSBudWxsKSB7XG4gICAgICAgIHNjaGVkdWxlZFRyYW5zYWN0aW9uLmluc3RydWN0aW9ucy51bnNoaWZ0KFxuICAgICAgICAgIGNyZWF0ZUJhbGFuY2VBY2NvdW50SW5zdHJ1Y3Rpb24oXG4gICAgICAgICAgICB0aGlzLnNvbGFuYVVzZXIubmVvbkV2bVByb2dyYW0sXG4gICAgICAgICAgICB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LFxuICAgICAgICAgICAgdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsXG4gICAgICAgICAgICB0aGlzLmNoYWluSWQhXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIFNpZ24gYW5kIHNlbmQgdHJhbnNhY3Rpb24gdXNpbmcgZGVtbyBwYXR0ZXJuXG4gICAgICBjb25zdCB7IGJsb2NraGFzaCwgbGFzdFZhbGlkQmxvY2tIZWlnaHQgfSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goJ2NvbmZpcm1lZCcpXG4gICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBibG9ja2hhc2hcbiAgICAgIHNjaGVkdWxlZFRyYW5zYWN0aW9uLmxhc3RWYWxpZEJsb2NrSGVpZ2h0ID0gbGFzdFZhbGlkQmxvY2tIZWlnaHRcbiAgICAgIHNjaGVkdWxlZFRyYW5zYWN0aW9uLmZlZVBheWVyID0gdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBQcmUtc2lnbmluZyBkZWJ1ZzonKVxuICAgICAgY29uc29sZS5sb2coJy0gQ29ubmVjdGVkIHdhbGxldDonLCB0aGlzLnNvbGFuYVVzZXIud2FsbGV0QWRhcHRlci5wdWJsaWNLZXk/LnRvQmFzZTU4KCkpXG4gICAgICBjb25zb2xlLmxvZygnLSBTb2xhbmEgdXNlcjonLCB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LnRvQmFzZTU4KCkpXG4gICAgICBjb25zb2xlLmxvZygnLSBUcmFuc2FjdGlvbiBmZWVQYXllcjonLCBzY2hlZHVsZWRUcmFuc2FjdGlvbi5mZWVQYXllcj8udG9CYXNlNTgoKSlcbiAgICAgIGNvbnNvbGUubG9nKCctIEFyZSB0aGV5IHRoZSBzYW1lPycsIHRoaXMuc29sYW5hVXNlci53YWxsZXRBZGFwdGVyLnB1YmxpY0tleT8udG9CYXNlNTgoKSA9PT0gdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleS50b0Jhc2U1OCgpKVxuICAgICAgXG4gICAgICAvLyBTaWduIHdpdGggd2FsbGV0IGFkYXB0ZXIgKGRlbW8gcGF0dGVybilcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OdIFNpZ25pbmcgdHJhbnNhY3Rpb24gd2l0aCB3YWxsZXQgYWRhcHRlci4uLicpXG4gICAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMuc29sYW5hVXNlci53YWxsZXRBZGFwdGVyLnNpZ25UcmFuc2FjdGlvbihzY2hlZHVsZWRUcmFuc2FjdGlvbilcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1N1Ym1pdHRpbmcgdHJhbnNhY3Rpb24uLi4nKVxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbi5zZXJpYWxpemUoKSlcbiAgICAgIFxuICAgICAgLy8gQ29uZmlybSB0cmFuc2FjdGlvbiAoZGVtbyBwYXR0ZXJuKVxuICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XG4gICAgICAgIGJsb2NraGFzaCxcbiAgICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQsXG4gICAgICAgIHNpZ25hdHVyZVxuICAgICAgfSwgJ2NvbmZpcm1lZCcpXG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgVHJhbnNhY3Rpb24gc3VibWl0dGVkIScpXG4gICAgICBjb25zb2xlLmxvZygn8J+UlyBTaWduYXR1cmU6Jywgc2lnbmF0dXJlKVxuXG4gICAgICAvLyBXYWl0IGZvciBjb25maXJtYXRpb25cbiAgICAgIGNvbnNvbGUubG9nKGAgICBXYWl0aW5nIGZvciBwYXltZW50IGNvbmZpcm1hdGlvbi4uLmApXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwMCkpXG5cbiAgICAgIC8vIENoZWNrIHRyYW5zYWN0aW9uIHN0YXR1c1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY29uZmlybWF0aW9uID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldFNpZ25hdHVyZVN0YXR1cyhzaWduYXR1cmUpXG4gICAgICAgIGlmIChjb25maXJtYXRpb24udmFsdWU/LmNvbmZpcm1hdGlvblN0YXR1cykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgUGF5bWVudCBzdGF0dXM6ICR7Y29uZmlybWF0aW9uLnZhbHVlLmNvbmZpcm1hdGlvblN0YXR1c31gKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJ5IHRvIGdldCBwYXltZW50IGRldGFpbHNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgICAgR2V0dGluZyBwYXltZW50IHRyYW5zYWN0aW9uIGRldGFpbHMuLi5gKVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IG5lb25UeFJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vZGV2bmV0Lm5lb25ldm0ub3JnL3NvbCcsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgIG1ldGhvZDogXCJuZW9uX2dldFRyYW5zYWN0aW9uQnlTZW5kZXJOb25jZVwiLFxuICAgICAgICAgICAgICBwYXJhbXM6IFt0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCwgbm9uY2VdLFxuICAgICAgICAgICAgICBpZDogMSxcbiAgICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IG5lb25UeFJlc3VsdCA9IGF3YWl0IG5lb25UeFJlc3BvbnNlLmpzb24oKVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChuZW9uVHhSZXN1bHQucmVzdWx0ICYmIG5lb25UeFJlc3VsdC5yZXN1bHQuaGFzaCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBOZW9uIEVWTSBwYXltZW50IGhhc2g6ICR7bmVvblR4UmVzdWx0LnJlc3VsdC5oYXNofWApXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGxpbmtJZDogbmVvblR4UmVzdWx0LnJlc3VsdC5oYXNoLFxuICAgICAgICAgICAgICB0eEhhc2g6IG5lb25UeFJlc3VsdC5yZXN1bHQuaGFzaFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4oS577iPIE5lb24gRVZNIHBheW1lbnQgdHJhbnNhY3Rpb24gbm90IGZvdW5kIHlldCAobWF5IHN0aWxsIGJlIHByb2Nlc3NpbmcpYClcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgIH0gY2F0Y2ggKG5lb25FcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDihLnvuI8gQ291bGQgbm90IGdldCBOZW9uIHBheW1lbnQgZGV0YWlsczogJHtuZW9uRXJyb3IubWVzc2FnZX1gKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgfSBjYXRjaCAoY29uZmlybUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDihLnvuI8gUGF5bWVudCBjb25maXJtYXRpb24gY2hlY2s6ICR7Y29uZmlybUVycm9yLm1lc3NhZ2V9YClcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYPCfjokgUGF5bWVudCB0cmFuc2FjdGlvbiBjb21wbGV0ZWQhYClcbiAgICAgIFxuICAgICAgLy8gUmV0dXJuIHNpZ25hdHVyZSBhcyBmYWxsYmFja1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGlua0lkOiBzaWduYXR1cmUsXG4gICAgICAgIHR4SGFzaDogc2lnbmF0dXJlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHBheW1lbnQgbGluazonLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdGhpcy5wcm94eUFwaS5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKVxuICAgICAgY29uc29sZS5sb2coJ0Z1bGwgdHJhbnNhY3Rpb24gcmVjZWlwdDonLCBKU09OLnN0cmluZ2lmeShyZWNlaXB0LCBudWxsLCAyKSlcbiAgICAgIFxuICAgICAgbGV0IGxpbmtJZCA9ICcnXG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRoZSB0cmFuc2FjdGlvbiB3YXMgc3VjY2Vzc2Z1bFxuICAgICAgaWYgKHJlY2VpcHQucmVzdWx0Py5zdGF0dXMgIT09ICcweDEnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gZmFpbGVkIC0gc3RhdHVzOiAnICsgcmVjZWlwdC5yZXN1bHQ/LnN0YXR1cylcbiAgICAgIH1cblxuICAgICAgLy8gRW5oYW5jZWQgZGVidWdnaW5nIG9mIHRoZSByZWNlaXB0IHN0cnVjdHVyZVxuICAgICAgY29uc29sZS5sb2coJ1JlY2VpcHQgc3RhdHVzOicsIHJlY2VpcHQucmVzdWx0Py5zdGF0dXMpXG4gICAgICBjb25zb2xlLmxvZygnUmVjZWlwdCBsb2dzIGFycmF5OicsIHJlY2VpcHQucmVzdWx0Py5sb2dzKVxuICAgICAgY29uc29sZS5sb2coJ1JlY2VpcHQgbG9ncyBsZW5ndGg6JywgcmVjZWlwdC5yZXN1bHQ/LmxvZ3M/Lmxlbmd0aClcbiAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXB0IGxvZ3NCbG9vbTonLCByZWNlaXB0LnJlc3VsdD8ubG9nc0Jsb29tKVxuICAgICAgY29uc29sZS5sb2coJ1JlY2VpcHQgY29udHJhY3RBZGRyZXNzOicsIHJlY2VpcHQucmVzdWx0Py5jb250cmFjdEFkZHJlc3MpXG4gICAgICBjb25zb2xlLmxvZygnUmVjZWlwdCBnYXNVc2VkOicsIHJlY2VpcHQucmVzdWx0Py5nYXNVc2VkKVxuICAgICAgY29uc29sZS5sb2coJ1JlY2VpcHQgZWZmZWN0aXZlR2FzUHJpY2U6JywgcmVjZWlwdC5yZXN1bHQ/LmVmZmVjdGl2ZUdhc1ByaWNlKVxuXG4gICAgICAvLyBDaGVjayBpZiB0aGVyZSdzIGEgZGlmZmVyZW50IGxvY2F0aW9uIGZvciBsb2dzXG4gICAgICBjb25zb2xlLmxvZygnUmF3IHRyYW5zYWN0aW9uIGRhdGE6JywgcmVjZWlwdC5yZXN1bHQ/Lm5lb25SYXdUcmFuc2FjdGlvbilcbiAgICAgIFxuICAgICAgLy8gTm90ZTogZ2V0VHJhbnNhY3Rpb24gbWV0aG9kIG5vdCBhdmFpbGFibGUgb24gTmVvblByb3h5UnBjQXBpXG4gICAgICAvLyBUcmFuc2FjdGlvbiBkZXRhaWxzIGFyZSBhbHJlYWR5IGluIHRoZSByZWNlaXB0XG5cbiAgICAgIC8vIEV4dHJhY3QgYWxsIG5lb25Mb2dzIGZyb20gc29sYW5hVHJhbnNhY3Rpb25zXG4gICAgICBjb25zdCBhbGxOZW9uTG9nczogYW55W10gPSBbXVxuICAgICAgaWYgKHJlY2VpcHQucmVzdWx0Py5zb2xhbmFUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBzb2xUeCBvZiByZWNlaXB0LnJlc3VsdC5zb2xhbmFUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICBpZiAoc29sVHguc29sYW5hSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIHNvbFR4LnNvbGFuYUluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24ubmVvbkxvZ3MgJiYgaW5zdHJ1Y3Rpb24ubmVvbkxvZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGFsbE5lb25Mb2dzLnB1c2goLi4uaW5zdHJ1Y3Rpb24ubmVvbkxvZ3MpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ0ZvdW5kJywgYWxsTmVvbkxvZ3MubGVuZ3RoLCAnbmVvbkxvZ3MgdG8gcGFyc2UnKVxuXG4gICAgICAvLyBUcnkgdG8gcGFyc2UgbG9ncyBmb3IgdGhlIFNvbGFuYUxpbmtDcmVhdGVkIGV2ZW50XG4gICAgICBpZiAoYWxsTmVvbkxvZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IGxvZyBvZiBhbGxOZW9uTG9ncykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVHJ5aW5nIHRvIHBhcnNlIG5lb25Mb2c6JywgbG9nKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGxvZyBpcyBmcm9tIG91ciBjb250cmFjdFxuICAgICAgICAgICAgaWYgKGxvZy5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IENPTlRSQUNUX0FERFJFU1MudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTG9nIGlzIGZyb20gb3VyIGNvbnRyYWN0LCBwYXJzaW5nLi4uJylcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGxvZyB0byB0aGUgZm9ybWF0IGV4cGVjdGVkIGJ5IGV0aGVyc1xuICAgICAgICAgICAgICBjb25zdCBldGhlcnNMb2cgPSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogbG9nLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgZGF0YTogbG9nLmRhdGEsXG4gICAgICAgICAgICAgICAgdG9waWNzOiBsb2cudG9waWNzXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGNvbnN0IHBhcnNlZExvZyA9IGlmYWNlLnBhcnNlTG9nKGV0aGVyc0xvZylcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BhcnNlZCBsb2c6JywgcGFyc2VkTG9nKVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKHBhcnNlZExvZz8ubmFtZSA9PT0gJ1NvbGFuYUxpbmtDcmVhdGVkJykge1xuICAgICAgICAgICAgICAgIGxpbmtJZCA9IHBhcnNlZExvZy5hcmdzLmxpbmtJZFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgRm91bmQgbGluayBJRCBmcm9tIFNvbGFuYUxpbmtDcmVhdGVkIGV2ZW50OicsIGxpbmtJZClcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTG9nIGZyb20gZGlmZmVyZW50IGNvbnRyYWN0OicsIGxvZy5hZGRyZXNzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgdG8gcGFyc2UgbmVvbkxvZzonLCBlKVxuICAgICAgICAgICAgLy8gU2tpcCBsb2dzIHRoYXQgY2FuJ3QgYmUgcGFyc2VkXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ05vIG5lb25Mb2dzIGZvdW5kIGluIHRyYW5zYWN0aW9uIHJlY2VpcHQhJylcbiAgICAgICAgY29uc29sZS5sb2coJ1RoaXMgbWlnaHQgaW5kaWNhdGU6JylcbiAgICAgICAgY29uc29sZS5sb2coJzEuIFRoZSBjb250cmFjdCBjYWxsIGZhaWxlZCBzaWxlbnRseScpXG4gICAgICAgIGNvbnNvbGUubG9nKCcyLiBUaGUgY29udHJhY3QgaXMgbm90IGF0IHRoZSBleHBlY3RlZCBhZGRyZXNzJylcbiAgICAgICAgY29uc29sZS5sb2coJzMuIFRoZSBjb250cmFjdCBmdW5jdGlvbiBjYWxsIHJldmVydGVkJylcbiAgICAgICAgY29uc29sZS5sb2coJzQuIEV2ZW50cyBhcmUgbm90IGJlaW5nIGVtaXR0ZWQgcHJvcGVybHknKVxuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IGNhbGxpbmcgdGhlIGNvbnRyYWN0IHJlYWQgbWV0aG9kIHRvIHNlZSBpZiBkYXRhIHdhcyBhY3R1YWxseSBzdG9yZWRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnQXR0ZW1wdGluZyB0byByZWFkIHBheW1lbnQgbGluayB1c2luZyB0cmFuc2FjdGlvbiBoYXNoIGFzIElELi4uJylcbiAgICAgICAgICBjb25zdCB0ZXN0RGF0YSA9IGF3YWl0IHRoaXMuY29udHJhY3QhLmdldFNvbGFuYVBheW1lbnRMaW5rKHR4SGFzaClcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ29udHJhY3QgcmVhZCByZXN1bHQ6JywgdGVzdERhdGEpXG4gICAgICAgIH0gY2F0Y2ggKHJlYWRFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdDb250cmFjdCByZWFkIGZhaWxlZDonLCByZWFkRXJyb3IpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgY291bGRuJ3QgZXh0cmFjdCBmcm9tIGxvZ3MsIGludmVzdGlnYXRlIGZ1cnRoZXJcbiAgICAgIGlmICghbGlua0lkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NvdWxkIG5vdCBleHRyYWN0IGxpbmsgSUQgZnJvbSB0cmFuc2FjdGlvbiBldmVudHMhJylcbiAgICAgICAgY29uc29sZS5sb2coJ1RoaXMgc3VnZ2VzdHMgdGhlIGNvbnRyYWN0IGNhbGwgbWF5IGhhdmUgZmFpbGVkIHNpbGVudGx5JylcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSB0cmFuc2FjdGlvbiBhY3R1YWxseSByZXZlcnRlZFxuICAgICAgICBjb25zb2xlLmxvZygnQ2hlY2tpbmcgZm9yIHJldmVydCBkYXRhLi4uJylcbiAgICAgICAgaWYgKHJlY2VpcHQucmVzdWx0Py5uZW9uUmV2ZXJ0RGF0YSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdSZXZlcnQgZGF0YSBmb3VuZDonLCByZWNlaXB0LnJlc3VsdC5uZW9uUmV2ZXJ0RGF0YSlcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIGRlY29kZSB0aGUgcmV2ZXJ0IHJlYXNvblxuICAgICAgICAgICAgY29uc3QgcmV2ZXJ0UmVhc29uID0gZXRoZXJzLnRvVXRmOFN0cmluZyhyZWNlaXB0LnJlc3VsdC5uZW9uUmV2ZXJ0RGF0YSlcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZXZlcnQgcmVhc29uOicsIHJldmVydFJlYXNvbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udHJhY3QgY2FsbCByZXZlcnRlZDogJHtyZXZlcnRSZWFzb259YClcbiAgICAgICAgICB9IGNhdGNoIChkZWNvZGVFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0NvdWxkIG5vdCBkZWNvZGUgcmV2ZXJ0IHJlYXNvbjonLCBkZWNvZGVFcnJvcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udHJhY3QgY2FsbCByZXZlcnRlZCB3aXRoIHVua25vd24gcmVhc29uJylcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIExldCdzIHRyeSB0byB1bmRlcnN0YW5kIHdoeSB0aGUgZXZlbnQgd2Fzbid0IGVtaXR0ZWRcbiAgICAgICAgY29uc29sZS5sb2coJ0FuYWx5emluZyBmdW5jdGlvbiBjYWxsLi4uJylcbiAgICAgICAgY29uc29sZS5sb2coJ0NvbnRyYWN0IGFkZHJlc3M6JywgQ09OVFJBQ1RfQUREUkVTUylcbiAgICAgICAgY29uc29sZS5sb2coJ0Zyb20gYWRkcmVzczonLCB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldClcbiAgICAgICAgY29uc29sZS5sb2coJ0Z1bmN0aW9uIGRhdGEgaW4gcmF3IHR4OicsIHJlY2VpcHQucmVzdWx0Py5uZW9uUmF3VHJhbnNhY3Rpb24pXG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB1c2VyIGlzIHJlZ2lzdGVyZWRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBpc1JlZ2lzdGVyZWQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0IS5pc1NvbGFuYVVzZXIodGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQpXG4gICAgICAgICAgY29uc29sZS5sb2coJ0lzIHVzZXIgcmVnaXN0ZXJlZCBhcyBTb2xhbmEgdXNlcjonLCBpc1JlZ2lzdGVyZWQpXG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCFpc1JlZ2lzdGVyZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVXNlciBpcyBub3QgcmVnaXN0ZXJlZCBhcyBhIFNvbGFuYSB1c2VyIHdpdGggdGhlIGNvbnRyYWN0LiBUaGlzIGlzIHJlcXVpcmVkIHRvIGNyZWF0ZSBwYXltZW50IGxpbmtzLicpXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChyZWdpc3RyYXRpb25FcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjaGVjayB1c2VyIHJlZ2lzdHJhdGlvbjonLCByZWdpc3RyYXRpb25FcnJvcilcbiAgICAgICAgICB0aHJvdyByZWdpc3RyYXRpb25FcnJvclxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgc29tZXRoaW5nIGVsc2Ugd2VudCB3cm9uZ1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BheW1lbnQgbGluayBjcmVhdGlvbiBmYWlsZWQ6IENvbnRyYWN0IGNhbGwgZXhlY3V0ZWQgYnV0IG5vIGV2ZW50IHdhcyBlbWl0dGVkLiBUaGUgdHJhbnNhY3Rpb24gbWF5IGhhdmUgZmFpbGVkIHNpbGVudGx5LicpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmtJZCxcbiAgICAgICAgdHhIYXNoXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgcGF5bWVudCBsaW5rOicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSByZWFkLW9ubHkgY29udHJhY3QgYWNjZXNzICh3aXRob3V0IHdhbGxldClcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW5pdFJlYWRPbmx5Q29udHJhY3QoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLmNvbnRyYWN0KSB7XG4gICAgICAvLyBDcmVhdGUgYSBzaW1wbGUgSlNPTiBSUEMgcHJvdmlkZXIgZm9yIHJlYWQgb3BlcmF0aW9uc1xuICAgICAgY29uc3QgcmVhZE9ubHlQcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKE5FT05fQ09SRV9SUENfVVJMKVxuICAgICAgdGhpcy5jb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoQ09OVFJBQ1RfQUREUkVTUywgU09MQU5BX1RJUENBUkRfQUJJLCByZWFkT25seVByb3ZpZGVyKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcGF5bWVudCBsaW5rIGRldGFpbHNcbiAgICovXG4gIGFzeW5jIGdldFBheW1lbnRMaW5rKGxpbmtJZDogc3RyaW5nKTogUHJvbWlzZTxQYXltZW50TGluaz4ge1xuICAgIC8vIEluaXRpYWxpemUgY29udHJhY3QgaWYgbm90IGFscmVhZHkgZG9uZVxuICAgIGlmICghdGhpcy5jb250cmFjdCkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0UmVhZE9ubHlDb250cmFjdCgpXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ0dldHRpbmcgcGF5bWVudCBsaW5rIHdpdGggSUQ6JywgbGlua0lkKVxuICAgIGNvbnNvbGUubG9nKCdDb250cmFjdCBhZGRyZXNzOicsIENPTlRSQUNUX0FERFJFU1MpXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jb250cmFjdCEuZ2V0U29sYW5hUGF5bWVudExpbmsobGlua0lkKVxuICAgICAgY29uc29sZS5sb2coJ1JhdyBjb250cmFjdCByZXN1bHQ6JywgcmVzdWx0KVxuICAgICAgXG4gICAgICBjb25zdCBwYXltZW50TGluayA9IHtcbiAgICAgICAgZXZtQ3JlYXRvcjogcmVzdWx0LmV2bUNyZWF0b3IsXG4gICAgICAgIHNvbGFuYUNyZWF0b3I6IHJlc3VsdC5zb2xhbmFDcmVhdG9yLFxuICAgICAgICBhbW91bnQ6IHJlc3VsdC5hbW91bnQsXG4gICAgICAgIGlzRmxleGlibGU6IHJlc3VsdC5pc0ZsZXhpYmxlLFxuICAgICAgICBpc0FjdGl2ZTogcmVzdWx0LmlzQWN0aXZlLFxuICAgICAgICB0b3RhbFJlY2VpdmVkOiByZXN1bHQudG90YWxSZWNlaXZlZCxcbiAgICAgICAgcGF5bWVudENvdW50OiBOdW1iZXIocmVzdWx0LnBheW1lbnRDb3VudCksXG4gICAgICAgIGRlc2NyaXB0aW9uOiByZXN1bHQuZGVzY3JpcHRpb25cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBsb29rcyBsaWtlIGFuIGVtcHR5L25vbi1leGlzdGVudCBsaW5rICh0cmFuc2FjdGlvbiBub3QgcHJvY2Vzc2VkIHlldClcbiAgICAgIGlmIChyZXN1bHQuZXZtQ3JlYXRvciA9PT0gJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcgJiYgXG4gICAgICAgICAgcmVzdWx0LmFtb3VudCA9PT0gQmlnSW50KDApICYmIFxuICAgICAgICAgICFyZXN1bHQuaXNBY3RpdmUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdQYXltZW50IGxpbmsgYXBwZWFycyB0byBiZSBlbXB0eS9ub24tZXhpc3RlbnQnKVxuICAgICAgICBcbiAgICAgICAgLy8gSWYgdGhpcyBsb29rcyBsaWtlIGEgdHJhbnNhY3Rpb24gaGFzaCAoNjYgY2hhcnMsIHN0YXJ0cyB3aXRoIDB4KSwgcHJvdmlkZSBoZWxwZnVsIGluZm9cbiAgICAgICAgaWYgKGxpbmtJZC5sZW5ndGggPT09IDY2ICYmIGxpbmtJZC5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ/CfkqEgVGhpcyBhcHBlYXJzIHRvIGJlIGEgdHJhbnNhY3Rpb24gaGFzaCAtIHRoZSBwYXltZW50IGxpbmsgbWF5IHN0aWxsIGJlIHByb2Nlc3NpbmcnKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5KhIE5lb24gb3BlcmF0b3JzIHdpbGwgZXZlbnR1YWxseSBwcm9jZXNzIHRoaXMgdHJhbnNhY3Rpb24gYW5kIGNyZWF0ZSB0aGUgcGF5bWVudCBsaW5rJylcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+SoSBZb3UgY2FuIGJvb2ttYXJrIHRoaXMgbGluayBhbmQgdHJ5IGFnYWluIGluIGEgZmV3IG1pbnV0ZXMnKVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZvciBub3csIGRvbid0IHRocm93IGFuIGVycm9yIC0gbGV0IHRoZSBVSSBoYW5kbGUgdGhlIGVtcHR5IGRhdGEgZ3JhY2VmdWxseVxuICAgICAgICAgIGNvbnNvbGUubG9nKCdSZXR1cm5pbmcgZW1wdHkgcGF5bWVudCBsaW5rIGRhdGEgLSB0cmFuc2FjdGlvbiBtYXkgc3RpbGwgYmUgcHJvY2Vzc2luZycpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHBheW1lbnRMaW5rXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0NvbnRyYWN0IGNhbGwgZXJyb3I6JywgZXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BheW1lbnQgbGluayBub3QgZm91bmQgb3IgY29udHJhY3QgZXJyb3InKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdXNlcidzIHBheW1lbnQgbGlua3NcbiAgICovXG4gIGFzeW5jIGdldFVzZXJMaW5rcyh1c2VyRVZNQWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIC8vIEluaXRpYWxpemUgY29udHJhY3QgaWYgbm90IGFscmVhZHkgZG9uZVxuICAgIGlmICghdGhpcy5jb250cmFjdCkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0UmVhZE9ubHlDb250cmFjdCgpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbnRyYWN0IS5nZXRVc2VyU29sYW5hTGlua3ModXNlckVWTUFkZHJlc3MpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdXNlciBsaW5rczonLCBlcnJvcilcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXkgYSBwYXltZW50IGxpbmsgdXNpbmcgU29sYW5hIE5hdGl2ZSBTREtcbiAgICovXG4gIGFzeW5jIHBheUxpbmsoXG4gICAgbGlua0lkOiBzdHJpbmcsXG4gICAgYW1vdW50U09MOiBudW1iZXJcbiAgKTogUHJvbWlzZTx7IHR4SGFzaDogc3RyaW5nOyB0cmFuc2ZlclNpZ25hdHVyZT86IHN0cmluZyB9PiB7XG4gICAgaWYgKCF0aGlzLnNvbGFuYVVzZXIgfHwgIXRoaXMuY29udHJhY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIGNvbm5lY3Qgd2FsbGV0IGZpcnN0JylcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgcGF5bWVudCBwcm9jZXNzLi4uJylcbiAgICBjb25zb2xlLmxvZygnTGluayBJRDonLCBsaW5rSWQpXG4gICAgY29uc29sZS5sb2coJ0Ftb3VudCBTT0w6JywgYW1vdW50U09MKVxuXG4gICAgLy8gRmlyc3QsIGdldCB0aGUgcGF5bWVudCBsaW5rIGRldGFpbHMgdG8gZmluZCB0aGUgcmVjaXBpZW50XG4gICAgY29uc3QgbGlua0RhdGEgPSBhd2FpdCB0aGlzLmdldFBheW1lbnRMaW5rKGxpbmtJZClcbiAgICBjb25zb2xlLmxvZygnUGF5bWVudCBsaW5rIGRhdGE6JywgbGlua0RhdGEpXG5cbiAgICBpZiAoIWxpbmtEYXRhLmlzQWN0aXZlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BheW1lbnQgbGluayBpcyBubyBsb25nZXIgYWN0aXZlJylcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IFNPTCB0byBsYW1wb3J0c1xuICAgIGNvbnN0IGFtb3VudExhbXBvcnRzID0gTWF0aC5mbG9vcihhbW91bnRTT0wgKiAxZTkpXG4gICAgXG4gICAgbGV0IHRyYW5zZmVyU2lnbmF0dXJlOiBzdHJpbmcgfCB1bmRlZmluZWRcblxuICAgIHRyeSB7XG4gICAgICAvLyBTdGVwIDE6IFBlcmZvcm0gdGhlIGFjdHVhbCBTT0wgdHJhbnNmZXIgZmlyc3RcbiAgICAgIGNvbnNvbGUubG9nKCdTdGVwIDE6IFBlcmZvcm1pbmcgU09MIHRyYW5zZmVyLi4uJylcbiAgICAgIGNvbnNvbGUubG9nKCdGcm9tOicsIHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXkudG9CYXNlNTgoKSlcbiAgICAgIGNvbnNvbGUubG9nKCdUbyByZWNpcGllbnQgYnl0ZXMzMjonLCBsaW5rRGF0YS5zb2xhbmFDcmVhdG9yKVxuICAgICAgY29uc29sZS5sb2coJ0Ftb3VudCBsYW1wb3J0czonLCBhbW91bnRMYW1wb3J0cylcblxuICAgICAgLy8gQ29udmVydCByZWNpcGllbnQgU29sYW5hIGFkZHJlc3MgZnJvbSBieXRlczMyIHRvIFB1YmxpY0tleVxuICAgICAgLy8gUmVtb3ZlICcweCcgcHJlZml4IGlmIHByZXNlbnRcbiAgICAgIGNvbnN0IGhleFN0cmluZyA9IGxpbmtEYXRhLnNvbGFuYUNyZWF0b3Iuc3RhcnRzV2l0aCgnMHgnKSBcbiAgICAgICAgPyBsaW5rRGF0YS5zb2xhbmFDcmVhdG9yLnNsaWNlKDIpIFxuICAgICAgICA6IGxpbmtEYXRhLnNvbGFuYUNyZWF0b3JcbiAgICAgIFxuICAgICAgLy8gQ29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbiAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoaGV4U3RyaW5nLm1hdGNoKC8uezJ9L2cpPy5tYXAoYnl0ZSA9PiBwYXJzZUludChieXRlLCAxNikpIHx8IFtdKVxuICAgICAgXG4gICAgICAvLyBGb3IgYnl0ZXMzMiBmcm9tIFNvbGFuYSBhZGRyZXNzZXMsIHdlIG5lZWQgdG8gZmluZCB0aGUgYWN0dWFsIDMyLWJ5dGUgcHVibGljIGtleVxuICAgICAgLy8gVGhlIGJ5dGVzMzIgc2hvdWxkIGNvbnRhaW4gdGhlIDMyLWJ5dGUgU29sYW5hIHB1YmxpYyBrZXksIHBvc3NpYmx5IHdpdGggbGVhZGluZyB6ZXJvc1xuICAgICAgbGV0IHJlY2lwaWVudFB1YmtleVxuICAgICAgXG4gICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAzMikge1xuICAgICAgICAvLyBEaXJlY3QgY29udmVyc2lvbiBmcm9tIDMyIGJ5dGVzXG4gICAgICAgIHJlY2lwaWVudFB1YmtleSA9IG5ldyAoYXdhaXQgaW1wb3J0KCdAc29sYW5hL3dlYjMuanMnKSkuUHVibGljS2V5KGJ5dGVzKVxuICAgICAgfSBlbHNlIGlmIChieXRlcy5sZW5ndGggPiAzMikge1xuICAgICAgICAvLyBUYWtlIHRoZSBsYXN0IDMyIGJ5dGVzIGlmIGl0J3MgbG9uZ2VyXG4gICAgICAgIGNvbnN0IGxhc3QzMkJ5dGVzID0gYnl0ZXMuc2xpY2UoLTMyKVxuICAgICAgICByZWNpcGllbnRQdWJrZXkgPSBuZXcgKGF3YWl0IGltcG9ydCgnQHNvbGFuYS93ZWIzLmpzJykpLlB1YmxpY0tleShsYXN0MzJCeXRlcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFBhZCB3aXRoIGxlYWRpbmcgemVyb3MgaWYgc2hvcnRlclxuICAgICAgICBjb25zdCBwYWRkZWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KDMyKVxuICAgICAgICBwYWRkZWRCeXRlcy5zZXQoYnl0ZXMsIDMyIC0gYnl0ZXMubGVuZ3RoKVxuICAgICAgICByZWNpcGllbnRQdWJrZXkgPSBuZXcgKGF3YWl0IGltcG9ydCgnQHNvbGFuYS93ZWIzLmpzJykpLlB1YmxpY0tleShwYWRkZWRCeXRlcylcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ1JlY2lwaWVudCBQdWJsaWNLZXk6JywgcmVjaXBpZW50UHVia2V5LnRvQmFzZTU4KCkpXG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgU09MIHRyYW5zZmVyIHRyYW5zYWN0aW9uXG4gICAgICBjb25zdCB7IFN5c3RlbVByb2dyYW0sIFRyYW5zYWN0aW9uIH0gPSBhd2FpdCBpbXBvcnQoJ0Bzb2xhbmEvd2ViMy5qcycpXG5cbiAgICAgIC8vIENyZWF0ZSB0cmFuc2ZlciBpbnN0cnVjdGlvblxuICAgICAgY29uc3QgdHJhbnNmZXJJeCA9IFN5c3RlbVByb2dyYW0udHJhbnNmZXIoe1xuICAgICAgICBmcm9tUHVia2V5OiB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LFxuICAgICAgICB0b1B1YmtleTogcmVjaXBpZW50UHVia2V5LFxuICAgICAgICBsYW1wb3J0czogYW1vdW50TGFtcG9ydHNcbiAgICAgIH0pXG5cbiAgICAgIC8vIENyZWF0ZSB0cmFuc2FjdGlvblxuICAgICAgY29uc3QgdHJhbnNmZXJUeCA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZCh0cmFuc2Zlckl4KVxuICAgICAgXG4gICAgICAvLyBHZXQgZnJlc2ggcmVjZW50IGJsb2NraGFzaCByaWdodCBiZWZvcmUgc2lnbmluZ1xuICAgICAgY29uc29sZS5sb2coJ0dldHRpbmcgZnJlc2ggYmxvY2toYXNoIGZvciBTT0wgdHJhbnNmZXIuLi4nKVxuICAgICAgY29uc3QgeyBibG9ja2hhc2gsIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiB0cmFuc2ZlckJsb2NrSGVpZ2h0IH0gPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCdjb25maXJtZWQnKVxuICAgICAgY29uc29sZS5sb2coJ0ZyZXNoIFNPTCB0cmFuc2ZlciBibG9ja2hhc2g6JywgYmxvY2toYXNoKVxuICAgICAgY29uc29sZS5sb2coJ0xhc3QgdmFsaWQgYmxvY2sgaGVpZ2h0OicsIHRyYW5zZmVyQmxvY2tIZWlnaHQpXG4gICAgICBcbiAgICAgIHRyYW5zZmVyVHgucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoXG4gICAgICB0cmFuc2ZlclR4LmZlZVBheWVyID0gdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleVxuXG4gICAgICAvLyBTaWduIGFuZCBzZW5kIHRoZSBTT0wgdHJhbnNmZXIgaW1tZWRpYXRlbHlcbiAgICAgIGNvbnNvbGUubG9nKCdTaWduaW5nIGFuZCBzZW5kaW5nIFNPTCB0cmFuc2ZlciB3aXRoIGZyZXNoIGJsb2NraGFzaC4uLicpXG4gICAgICBjb25zdCBzaWduZWRUcmFuc2ZlclR4ID0gYXdhaXQgdGhpcy5zb2xhbmFVc2VyLndhbGxldEFkYXB0ZXIuc2lnblRyYW5zYWN0aW9uKHRyYW5zZmVyVHgpXG4gICAgICB0cmFuc2ZlclNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNmZXJUeC5zZXJpYWxpemUoKSlcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1NPTCB0cmFuc2ZlciBzZW50OicsIHRyYW5zZmVyU2lnbmF0dXJlKVxuICAgICAgXG4gICAgICAvLyBXYWl0IGZvciB0cmFuc2ZlciBjb25maXJtYXRpb24gdXNpbmcgdGhlIG1vZGVybiBBUElcbiAgICAgIGF3YWl0IHRoaXMuY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oe1xuICAgICAgICBzaWduYXR1cmU6IHRyYW5zZmVyU2lnbmF0dXJlLFxuICAgICAgICAuLi4oYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgpKVxuICAgICAgfSlcbiAgICAgIGNvbnNvbGUubG9nKCdTT0wgdHJhbnNmZXIgY29uZmlybWVkJylcblxuICAgICAgLy8gU3RlcCAyOiBSZWNvcmQgdGhlIHBheW1lbnQgaW4gdGhlIGNvbnRyYWN0XG4gICAgICBjb25zb2xlLmxvZygnU3RlcCAyOiBSZWNvcmRpbmcgcGF5bWVudCBpbiBjb250cmFjdC4uLicpXG4gICAgICBcbiAgICAgIC8vIENvbnZlcnQgU29sYW5hIFB1YmxpY0tleSB0byBieXRlczMyXG4gICAgICBjb25zdCBwYXllclNvbGFuYUJ5dGVzMzIgPSB6ZXJvUGFkVmFsdWUoaGV4bGlmeSh0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LnRvQnl0ZXMoKSksIDMyKVxuXG4gICAgICAvLyBHZXQgY3VycmVudCBub25jZVxuICAgICAgY29uc3Qgbm9uY2UgPSBOdW1iZXIoYXdhaXQgdGhpcy5wcm94eUFwaS5nZXRUcmFuc2FjdGlvbkNvdW50KHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0KSlcbiAgICAgIGNvbnNvbGUubG9nKCdDdXJyZW50IG5vbmNlOicsIG5vbmNlKVxuXG4gICAgICAvLyBQcmVwYXJlIGNvbnRyYWN0IGNhbGwgZGF0YVxuICAgICAgY29uc3QgaWZhY2UgPSBuZXcgZXRoZXJzLkludGVyZmFjZShTT0xBTkFfVElQQ0FSRF9BQkkpXG4gICAgICBjb25zdCBkYXRhID0gaWZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKCdwYXlTb2xhbmFMaW5rJywgW1xuICAgICAgICBsaW5rSWQsXG4gICAgICAgIGFtb3VudExhbXBvcnRzLFxuICAgICAgICBwYXllclNvbGFuYUJ5dGVzMzJcbiAgICAgIF0pXG5cbiAgICAgIC8vIENyZWF0ZSB0cmFuc2FjdGlvbiBkYXRhXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkRhdGEgPSB7XG4gICAgICAgIGZyb206IHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0LFxuICAgICAgICB0bzogQ09OVFJBQ1RfQUREUkVTUyxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfVxuXG4gICAgICAvLyBFc3RpbWF0ZSBnYXNcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uR2FzID0gYXdhaXQgdGhpcy5wcm94eUFwaS5lc3RpbWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uR2FzKHtcbiAgICAgICAgc29sYW5hUGF5ZXI6IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXksXG4gICAgICAgIHRyYW5zYWN0aW9uczogW3RyYW5zYWN0aW9uRGF0YV0sXG4gICAgICB9KVxuXG4gICAgICAvLyBDcmVhdGUgc2NoZWR1bGVkIHRyYW5zYWN0aW9uXG4gICAgICBsZXQgeyBzY2hlZHVsZWRUcmFuc2FjdGlvbiB9ID0gYXdhaXQgdGhpcy5wcm94eUFwaS5jcmVhdGVTY2hlZHVsZWRUcmFuc2FjdGlvbih7XG4gICAgICAgIHRyYW5zYWN0aW9uR2FzLFxuICAgICAgICB0cmFuc2FjdGlvbkRhdGEsXG4gICAgICAgIG5vbmNlXG4gICAgICB9KVxuXG4gICAgICAvLyBHZXQgZnJlc2ggcmVjZW50IGJsb2NraGFzaCByaWdodCBiZWZvcmUgc2lnbmluZ1xuICAgICAgY29uc29sZS5sb2coJ0dldHRpbmcgZnJlc2ggYmxvY2toYXNoIGZvciBjb250cmFjdCBjYWxsLi4uJylcbiAgICAgIGNvbnN0IHsgYmxvY2toYXNoOiBjb250cmFjdEJsb2NraGFzaCwgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IGNvbnRyYWN0QmxvY2tIZWlnaHQgfSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goJ2NvbmZpcm1lZCcpXG4gICAgICBjb25zb2xlLmxvZygnRnJlc2ggY29udHJhY3QgY2FsbCBibG9ja2hhc2g6JywgY29udHJhY3RCbG9ja2hhc2gpXG4gICAgICBjb25zb2xlLmxvZygnTGFzdCB2YWxpZCBibG9jayBoZWlnaHQ6JywgY29udHJhY3RCbG9ja0hlaWdodClcbiAgICAgIFxuICAgICAgc2NoZWR1bGVkVHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gY29udHJhY3RCbG9ja2hhc2hcbiAgICAgIHNjaGVkdWxlZFRyYW5zYWN0aW9uLmZlZVBheWVyID0gdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleVxuXG4gICAgICAvLyBTaWduIHdpdGggd2FsbGV0IGFkYXB0ZXIgaW5zdGVhZCBvZiBrZXlwYWlyIChsaWtlIGluIHRlc3RzKVxuICAgICAgLy8gSW4gdGVzdHM6IHNjaGVkdWxlZFRyYW5zYWN0aW9uLnNpZ24oeyBwdWJsaWNLZXk6IHNvbGFuYVVzZXIucHVibGljS2V5LCBzZWNyZXRLZXk6IHNvbGFuYVVzZXIua2V5cGFpci5zZWNyZXRLZXkgfSlcbiAgICAgIC8vIEluIGZyb250ZW5kOiB1c2Ugd2FsbGV0IGFkYXB0ZXIgc2lnbmluZ1xuICAgICAgY29uc29sZS5sb2coJ1NpZ25pbmcgY29udHJhY3QgY2FsbCB3aXRoIGZyZXNoIGJsb2NraGFzaC4uLicpXG4gICAgICBjb25zdCBzaWduZWRUeCA9IGF3YWl0IHRoaXMuc29sYW5hVXNlci53YWxsZXRBZGFwdGVyLnNpZ25UcmFuc2FjdGlvbihzY2hlZHVsZWRUcmFuc2FjdGlvbilcbiAgICAgIFxuICAgICAgLy8gU2VuZCB0cmFuc2FjdGlvbiBpbW1lZGlhdGVseVxuICAgICAgY29uc29sZS5sb2coJ1NlbmRpbmcgY29udHJhY3QgY2FsbCB0cmFuc2FjdGlvbiBpbW1lZGlhdGVseS4uLicpXG4gICAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uc2VuZFJhd1RyYW5zYWN0aW9uKHNpZ25lZFR4LnNlcmlhbGl6ZSgpKVxuXG4gICAgICAvLyBXYWl0IGZvciB0cmFuc2FjdGlvbiBleGVjdXRpb24gb24gTmVvbiBFVk1cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uU3RhdHVzID0gYXdhaXQgdGhpcy5wcm94eUFwaS53YWl0VHJhbnNhY3Rpb25UcmVlRXhlY3V0aW9uKFxuICAgICAgICB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCwgXG4gICAgICAgIG5vbmNlLCBcbiAgICAgICAgNjAwMDBcbiAgICAgIClcblxuICAgICAgaWYgKHRyYW5zYWN0aW9uU3RhdHVzLmxlbmd0aCA9PT0gMCB8fCB0cmFuc2FjdGlvblN0YXR1c1swXS5zdGF0dXMgIT09ICdTdWNjZXNzJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0NvbnRyYWN0IHBheW1lbnQgcmVjb3JkaW5nIGZhaWxlZCwgYnV0IFNPTCB0cmFuc2ZlciBzdWNjZWVkZWQnKVxuICAgICAgICBjb25zb2xlLmxvZygnVHJhbnNmZXIgc2lnbmF0dXJlOicsIHRyYW5zZmVyU2lnbmF0dXJlKVxuICAgICAgICAvLyBEb24ndCB0aHJvdyBlcnJvciAtIHRoZSBwYXltZW50IHdlbnQgdGhyb3VnaCBldmVuIGlmIHJlY29yZGluZyBmYWlsZWRcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ1BheW1lbnQgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSEnKVxuICAgICAgY29uc29sZS5sb2coJ1NPTCB0cmFuc2ZlcjonLCB0cmFuc2ZlclNpZ25hdHVyZSlcbiAgICAgIGNvbnNvbGUubG9nKCdDb250cmFjdCByZWNvcmQ6JywgdHJhbnNhY3Rpb25TdGF0dXNbMF0/LnRyYW5zYWN0aW9uSGFzaClcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHhIYXNoOiB0cmFuc2FjdGlvblN0YXR1c1swXT8udHJhbnNhY3Rpb25IYXNoIHx8ICdjb250cmFjdC1yZWNvcmRpbmctZmFpbGVkJyxcbiAgICAgICAgdHJhbnNmZXJTaWduYXR1cmVcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXlpbmcgbGluazonLCBlcnJvcilcbiAgICAgIGlmICh0cmFuc2ZlclNpZ25hdHVyZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnTm90ZTogU09MIHRyYW5zZmVyIG1heSBoYXZlIHN1Y2NlZWRlZDonLCB0cmFuc2ZlclNpZ25hdHVyZSlcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlYWN0aXZhdGUgYSBwYXltZW50IGxpbmtcbiAgICovXG4gIGFzeW5jIGRlYWN0aXZhdGVMaW5rKGxpbmtJZDogc3RyaW5nKTogUHJvbWlzZTx7IHR4SGFzaDogc3RyaW5nIH0+IHtcbiAgICBpZiAoIXRoaXMuc29sYW5hVXNlciB8fCAhdGhpcy5jb250cmFjdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgY29ubmVjdCB3YWxsZXQgZmlyc3QnKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgY3VycmVudCBub25jZVxuICAgICAgY29uc3Qgbm9uY2UgPSBOdW1iZXIoYXdhaXQgdGhpcy5wcm94eUFwaS5nZXRUcmFuc2FjdGlvbkNvdW50KHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0KSlcbiAgICAgIGNvbnNvbGUubG9nKCdDdXJyZW50IG5vbmNlOicsIG5vbmNlKVxuXG4gICAgICAvLyBQcmVwYXJlIGNvbnRyYWN0IGNhbGwgZGF0YVxuICAgICAgY29uc3QgaWZhY2UgPSBuZXcgZXRoZXJzLkludGVyZmFjZShTT0xBTkFfVElQQ0FSRF9BQkkpXG4gICAgICBjb25zdCBkYXRhID0gaWZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKCdkZWFjdGl2YXRlU29sYW5hTGluaycsIFtsaW5rSWRdKVxuXG4gICAgICAvLyBDcmVhdGUgdHJhbnNhY3Rpb24gZGF0YVxuICAgICAgY29uc3QgdHJhbnNhY3Rpb25EYXRhID0ge1xuICAgICAgICBmcm9tOiB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCxcbiAgICAgICAgdG86IENPTlRSQUNUX0FERFJFU1MsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH1cblxuICAgICAgLy8gRXN0aW1hdGUgZ2FzXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkdhcyA9IGF3YWl0IHRoaXMucHJveHlBcGkuZXN0aW1hdGVTY2hlZHVsZWRUcmFuc2FjdGlvbkdhcyh7XG4gICAgICAgIHNvbGFuYVBheWVyOiB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LFxuICAgICAgICB0cmFuc2FjdGlvbnM6IFt0cmFuc2FjdGlvbkRhdGFdLFxuICAgICAgfSlcblxuICAgICAgLy8gQ3JlYXRlIHNjaGVkdWxlZCB0cmFuc2FjdGlvblxuICAgICAgbGV0IHsgc2NoZWR1bGVkVHJhbnNhY3Rpb24gfSA9IGF3YWl0IHRoaXMucHJveHlBcGkuY3JlYXRlU2NoZWR1bGVkVHJhbnNhY3Rpb24oe1xuICAgICAgICB0cmFuc2FjdGlvbkdhcyxcbiAgICAgICAgdHJhbnNhY3Rpb25EYXRhLFxuICAgICAgICBub25jZVxuICAgICAgfSlcblxuICAgICAgLy8gR2V0IGZyZXNoIHJlY2VudCBibG9ja2hhc2ggcmlnaHQgYmVmb3JlIHNpZ25pbmdcbiAgICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIGZyZXNoIGJsb2NraGFzaCBmb3IgZGVhY3RpdmF0ZSB0cmFuc2FjdGlvbi4uLicpXG4gICAgICBjb25zdCB7IGJsb2NraGFzaCwgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IGRlYWN0aXZhdGVCbG9ja0hlaWdodCB9ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgnY29uZmlybWVkJylcbiAgICAgIGNvbnNvbGUubG9nKCdGcmVzaCBkZWFjdGl2YXRlIGJsb2NraGFzaDonLCBibG9ja2hhc2gpXG4gICAgICBjb25zb2xlLmxvZygnTGFzdCB2YWxpZCBibG9jayBoZWlnaHQ6JywgZGVhY3RpdmF0ZUJsb2NrSGVpZ2h0KVxuICAgICAgXG4gICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBibG9ja2hhc2hcbiAgICAgIHNjaGVkdWxlZFRyYW5zYWN0aW9uLmZlZVBheWVyID0gdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleVxuXG4gICAgICAvLyBTaWduIHdpdGggd2FsbGV0IGFkYXB0ZXIgaW5zdGVhZCBvZiBrZXlwYWlyIChsaWtlIGluIHRlc3RzKVxuICAgICAgLy8gSW4gdGVzdHM6IHNjaGVkdWxlZFRyYW5zYWN0aW9uLnNpZ24oeyBwdWJsaWNLZXk6IHNvbGFuYVVzZXIucHVibGljS2V5LCBzZWNyZXRLZXk6IHNvbGFuYVVzZXIua2V5cGFpci5zZWNyZXRLZXkgfSlcbiAgICAgIC8vIEluIGZyb250ZW5kOiB1c2Ugd2FsbGV0IGFkYXB0ZXIgc2lnbmluZ1xuICAgICAgY29uc29sZS5sb2coJ1NpZ25pbmcgZGVhY3RpdmF0ZSB0cmFuc2FjdGlvbiB3aXRoIGZyZXNoIGJsb2NraGFzaC4uLicpXG4gICAgICBjb25zdCBzaWduZWRUeCA9IGF3YWl0IHRoaXMuc29sYW5hVXNlci53YWxsZXRBZGFwdGVyLnNpZ25UcmFuc2FjdGlvbihzY2hlZHVsZWRUcmFuc2FjdGlvbilcbiAgICAgIFxuICAgICAgLy8gU2VuZCB0cmFuc2FjdGlvbiBpbW1lZGlhdGVseVxuICAgICAgY29uc29sZS5sb2coJ1NlbmRpbmcgZGVhY3RpdmF0ZSB0cmFuc2FjdGlvbiBpbW1lZGlhdGVseS4uLicpXG4gICAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uc2VuZFJhd1RyYW5zYWN0aW9uKHNpZ25lZFR4LnNlcmlhbGl6ZSgpKVxuXG4gICAgICAvLyBXYWl0IGZvciB0cmFuc2FjdGlvbiBleGVjdXRpb25cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uU3RhdHVzID0gYXdhaXQgdGhpcy5wcm94eUFwaS53YWl0VHJhbnNhY3Rpb25UcmVlRXhlY3V0aW9uKFxuICAgICAgICB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCwgXG4gICAgICAgIG5vbmNlLCBcbiAgICAgICAgNjAwMDBcbiAgICAgIClcblxuICAgICAgaWYgKHRyYW5zYWN0aW9uU3RhdHVzLmxlbmd0aCA9PT0gMCB8fCB0cmFuc2FjdGlvblN0YXR1c1swXS5zdGF0dXMgIT09ICdTdWNjZXNzJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlYWN0aXZhdGlvbiB0cmFuc2FjdGlvbiBmYWlsZWQgdG8gZXhlY3V0ZSBvbiBOZW9uIEVWTScpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR4SGFzaDogdHJhbnNhY3Rpb25TdGF0dXNbMF0udHJhbnNhY3Rpb25IYXNoXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgc2hhcmVhYmxlIFVSTCBmb3IgYSBwYXltZW50IGxpbmtcbiAgICovXG4gIGNyZWF0ZVBheW1lbnRVUkwobGlua0lkOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt3aW5kb3cubG9jYXRpb24ub3JpZ2lufT9wYXk9JHtsaW5rSWR9YFxuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgbGluayBJRCBmcm9tIFVSTFxuICAgKi9cbiAgc3RhdGljIGV4dHJhY3RMaW5rSWRGcm9tVVJMKHVybDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodXJsKVxuICAgICAgcmV0dXJuIHVybE9iai5zZWFyY2hQYXJhbXMuZ2V0KCdwYXknKVxuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB1c2VyJ3MgRVZNIGFkZHJlc3MgZGVyaXZlZCBmcm9tIFNvbGFuYSBwdWJsaWMga2V5XG4gICAqL1xuICBnZXRVc2VyRVZNQWRkcmVzcygpOiBzdHJpbmcgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5zb2xhbmFVc2VyPy5uZW9uV2FsbGV0IHx8IG51bGxcbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3Qgc29sYW5hTmF0aXZlQ29udHJhY3QgPSBuZXcgU29sYW5hTmF0aXZlQ29udHJhY3QoKSJdLCJuYW1lcyI6WyJDb25uZWN0aW9uIiwiTmVvblByb3h5UnBjQXBpIiwiY3JlYXRlQmFsYW5jZUFjY291bnRJbnN0cnVjdGlvbiIsIlNvbGFuYU5lb25BY2NvdW50IiwiZXRoZXJzIiwiaGV4bGlmeSIsInplcm9QYWRWYWx1ZSIsIkNvbnRyYWN0QUJJIiwiU09MQU5BX1RJUENBUkRfQUJJIiwiQ09OVFJBQ1RfQUREUkVTUyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19USVBDQVJEX0NPTlRSQUNUX0FERFJFU1MiLCJORU9OX0NPUkVfUlBDX1VSTCIsIk5FWFRfUFVCTElDX05FT05fUlBDX1VSTCIsIk5FT05fUFJPWFlfUlBDX1VSTCIsIlNPTEFOQV9SUENfVVJMIiwiU29sYW5hTmF0aXZlQ29udHJhY3QiLCJpbml0V2l0aFNvbGFuYVdhbGxldCIsIndhbGxldEFkYXB0ZXIiLCJwdWJsaWNLZXkiLCJFcnJvciIsImNvbnNvbGUiLCJsb2ciLCJ0b0Jhc2U1OCIsInByb3ZpZGVyIiwiY2hhaW5JZCIsInNvbGFuYVVzZXIiLCJ0b2tlbk1pbnRBZGRyZXNzIiwicHJvZ3JhbUFkZHJlc3MiLCJwcm94eUFwaSIsImluaXQiLCJiYWxhbmNlQWRkcmVzcyIsImFjY291bnQiLCJuZW9uRXZtUHJvZ3JhbSIsInRva2VuTWludCIsIm5lb25XYWxsZXQiLCJlcnJvciIsInJlYWRPbmx5UHJvdmlkZXIiLCJKc29uUnBjUHJvdmlkZXIiLCJjb250cmFjdCIsIkNvbnRyYWN0IiwidHhDb3VudCIsImdldFRyYW5zYWN0aW9uQ291bnQiLCJ2ZXJpZnlFcnJvciIsImNvZGUiLCJnZXRDb2RlIiwibGVuZ3RoIiwid2FybiIsImNyZWF0ZVBheW1lbnRMaW5rIiwic3VnZ2VzdGVkQW1vdW50U09MIiwiaXNGbGV4aWJsZSIsImRlc2NyaXB0aW9uIiwiYW1vdW50TGFtcG9ydHMiLCJNYXRoIiwiZmxvb3IiLCJzY2hlZHVsZWRUcmFuc2FjdGlvbiIsIm5vbmNlIiwiTnVtYmVyIiwiaWZhY2UiLCJJbnRlcmZhY2UiLCJkYXRhIiwiZW5jb2RlRnVuY3Rpb25EYXRhIiwidHJhbnNhY3Rpb25EYXRhIiwiZnJvbSIsInRvIiwidHJhbnNhY3Rpb25HYXMiLCJlc3RpbWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uR2FzIiwic29sYW5hUGF5ZXIiLCJ0cmFuc2FjdGlvbnMiLCJjcmVhdGVTY2hlZHVsZWRUcmFuc2FjdGlvbiIsImNvbm5lY3Rpb24iLCJnZXRBY2NvdW50SW5mbyIsImluc3RydWN0aW9ucyIsInVuc2hpZnQiLCJibG9ja2hhc2giLCJsYXN0VmFsaWRCbG9ja0hlaWdodCIsImdldExhdGVzdEJsb2NraGFzaCIsInJlY2VudEJsb2NraGFzaCIsImZlZVBheWVyIiwic2lnbmVkVHJhbnNhY3Rpb24iLCJzaWduVHJhbnNhY3Rpb24iLCJzaWduYXR1cmUiLCJzZW5kUmF3VHJhbnNhY3Rpb24iLCJzZXJpYWxpemUiLCJjb25maXJtVHJhbnNhY3Rpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJjb25maXJtYXRpb24iLCJnZXRTaWduYXR1cmVTdGF0dXMiLCJ2YWx1ZSIsImNvbmZpcm1hdGlvblN0YXR1cyIsIm5lb25UeFJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJwYXJhbXMiLCJpZCIsImpzb25ycGMiLCJuZW9uVHhSZXN1bHQiLCJqc29uIiwicmVzdWx0IiwiaGFzaCIsImxpbmtJZCIsInR4SGFzaCIsIm5lb25FcnJvciIsIm1lc3NhZ2UiLCJjb25maXJtRXJyb3IiLCJpbml0UmVhZE9ubHlDb250cmFjdCIsImdldFBheW1lbnRMaW5rIiwiZ2V0U29sYW5hUGF5bWVudExpbmsiLCJwYXltZW50TGluayIsImV2bUNyZWF0b3IiLCJzb2xhbmFDcmVhdG9yIiwiYW1vdW50IiwiaXNBY3RpdmUiLCJ0b3RhbFJlY2VpdmVkIiwicGF5bWVudENvdW50IiwiQmlnSW50Iiwic3RhcnRzV2l0aCIsImdldFVzZXJMaW5rcyIsInVzZXJFVk1BZGRyZXNzIiwiZ2V0VXNlclNvbGFuYUxpbmtzIiwicGF5TGluayIsImFtb3VudFNPTCIsImxpbmtEYXRhIiwidHJhbnNmZXJTaWduYXR1cmUiLCJoZXhTdHJpbmciLCJ0cmFuc2FjdGlvblN0YXR1cyIsInNsaWNlIiwiYnl0ZXMiLCJVaW50OEFycmF5IiwibWF0Y2giLCJtYXAiLCJieXRlIiwicGFyc2VJbnQiLCJyZWNpcGllbnRQdWJrZXkiLCJQdWJsaWNLZXkiLCJsYXN0MzJCeXRlcyIsInBhZGRlZEJ5dGVzIiwic2V0IiwiU3lzdGVtUHJvZ3JhbSIsIlRyYW5zYWN0aW9uIiwidHJhbnNmZXJJeCIsInRyYW5zZmVyIiwiZnJvbVB1YmtleSIsInRvUHVia2V5IiwibGFtcG9ydHMiLCJ0cmFuc2ZlclR4IiwiYWRkIiwidHJhbnNmZXJCbG9ja0hlaWdodCIsInNpZ25lZFRyYW5zZmVyVHgiLCJwYXllclNvbGFuYUJ5dGVzMzIiLCJ0b0J5dGVzIiwiY29udHJhY3RCbG9ja2hhc2giLCJjb250cmFjdEJsb2NrSGVpZ2h0Iiwic2lnbmVkVHgiLCJ3YWl0VHJhbnNhY3Rpb25UcmVlRXhlY3V0aW9uIiwic3RhdHVzIiwidHJhbnNhY3Rpb25IYXNoIiwiZGVhY3RpdmF0ZUxpbmsiLCJkZWFjdGl2YXRlQmxvY2tIZWlnaHQiLCJjcmVhdGVQYXltZW50VVJMIiwid2luZG93IiwibG9jYXRpb24iLCJvcmlnaW4iLCJleHRyYWN0TGlua0lkRnJvbVVSTCIsInVybCIsInVybE9iaiIsIlVSTCIsInNlYXJjaFBhcmFtcyIsImdldCIsImdldFVzZXJFVk1BZGRyZXNzIiwiY29uc3RydWN0b3IiLCJzb2xhbmFOYXRpdmVDb250cmFjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/solana-native-contract.ts\n"));

/***/ })

});