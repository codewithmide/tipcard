"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/solana-native-contract.ts":
/*!*****************************************!*\
  !*** ./utils/solana-native-contract.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaNativeContract: function() { return /* binding */ SolanaNativeContract; },\n/* harmony export */   solanaNativeContract: function() { return /* binding */ solanaNativeContract; }\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var _neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @neonevm/solana-sign */ \"(app-pages-browser)/./node_modules/@neonevm/solana-sign/dist/esm/index.mjs\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n\n\n\n// Contract ABI - only the functions we need\nconst SOLANA_TIPCARD_ABI = [\n    \"function createSolanaPaymentLink(uint64 _suggestedAmount, bool _isFlexible, string memory _description) external returns (bytes32)\",\n    \"function getSolanaPaymentLink(bytes32 _linkId) external view returns (tuple(address evmCreator, bytes32 solanaCreator, uint64 amount, bool isFlexible, bool isActive, uint64 totalReceived, uint32 paymentCount, string description))\",\n    \"function getUserSolanaLinks(address _user) external view returns (bytes32[] memory)\",\n    \"function paySolanaLink(bytes32 _linkId, uint64 _amount, bytes32 _payerSolanaAccount) external\",\n    \"function deactivateSolanaLink(bytes32 _linkId) external\",\n    \"function getSolanaUserAddress(address _evmAddress) external view returns (bytes32)\",\n    \"function isSolanaUser(address _evmAddress) external view returns (bool)\",\n    \"event SolanaLinkCreated(bytes32 indexed linkId, address indexed evmCreator, bytes32 indexed solanaCreator, uint64 amount, bool isFlexible, string description)\",\n    \"event SolanaPaymentReceived(bytes32 indexed linkId, bytes32 indexed payerSolana, bytes32 indexed recipientSolana, uint64 amount)\"\n];\nconst CONTRACT_ADDRESS = \"0x388Ed79FE1A0A05fa5adC14863EB153a31E4e469\" || 0;\nconst NEON_CORE_RPC_URL = \"https://devnet.neonevm.org\" || 0;\nconst NEON_PROXY_RPC_URL = \"\".concat(NEON_CORE_RPC_URL, \"/sol\");\nconst SOLANA_RPC_URL = \"https://api.devnet.solana.com\";\nclass SolanaNativeContract {\n    /**\n   * Initialize with Solana wallet using the Native SDK\n   */ async initWithSolanaWallet(walletAdapter) {\n        if (!walletAdapter.publicKey) {\n            throw new Error(\"Wallet not connected\");\n        }\n        try {\n            // Initialize the Neon Proxy API with the wallet's public key\n            const initResult = await this.proxyApi.init(walletAdapter.publicKey);\n            this.chainId = initResult.chainId;\n            this.programAddress = initResult.programAddress;\n            this.provider = initResult.provider;\n            this.solanaUser = initResult.solanaUser;\n            // Add wallet adapter to the solana user for signing\n            this.solanaUser.walletAdapter = walletAdapter;\n            // Create contract instance\n            this.contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.Contract(CONTRACT_ADDRESS, SOLANA_TIPCARD_ABI, this.provider);\n            // Verify contract is deployed at this address\n            try {\n                console.log(\"Verifying contract at address:\", CONTRACT_ADDRESS);\n                const code = await this.provider.getCode(CONTRACT_ADDRESS);\n                console.log(\"Contract code length:\", code.length);\n                if (code === \"0x\") {\n                    console.warn(\"⚠️ No contract code found at address:\", CONTRACT_ADDRESS);\n                    console.log(\"This might mean the contract is not deployed or address is incorrect\");\n                } else {\n                    console.log(\"✅ Contract found at address\");\n                    // Check if user's Solana address is registered with Neon EVM\n                    console.log(\"Checking Solana user registration...\");\n                    console.log(\"User EVM address:\", this.solanaUser.neonWallet);\n                    console.log(\"User Solana address:\", this.solanaUser.publicKey.toBase58());\n                    // Get the Solana address that Neon EVM has registered for this user\n                    const registeredSolanaAddr = await this.contract.getSolanaUserAddress(this.solanaUser.neonWallet);\n                    console.log(\"Registered Solana address (from contract):\", registeredSolanaAddr);\n                    const isUserRegistered = await this.contract.isSolanaUser(this.solanaUser.neonWallet);\n                    console.log(\"Is user registered with contract:\", isUserRegistered);\n                    if (!isUserRegistered) {\n                        console.warn(\"⚠️ User is not registered as Solana user with Neon EVM\");\n                        console.log(\"This may happen if the Solana Native SDK initialization did not complete properly\");\n                        console.log(\"The SDK should automatically register the user during init() call\");\n                        console.log(\"Attempting to create balance account to complete registration...\");\n                        // Try to create the balance account which should register the user\n                        try {\n                            const account = await this.connection.getAccountInfo(this.solanaUser.balanceAddress);\n                            if (account === null) {\n                                console.log(\"Balance account does not exist, will create it on first transaction\");\n                            } else {\n                                console.log(\"Balance account exists, user should be registered\");\n                            }\n                        } catch (balanceError) {\n                            console.log(\"Could not check balance account:\", balanceError);\n                        }\n                    } else {\n                        console.log(\"✅ User is properly registered\");\n                    }\n                }\n            } catch (verifyError) {\n                console.warn(\"Failed to verify contract:\", verifyError);\n            }\n        } catch (error) {\n            console.error(\"Failed to initialize Solana Native SDK:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Create a payment link using Solana Native SDK\n   */ async createPaymentLink(suggestedAmountSOL, isFlexible, description) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        // Convert SOL to lamports (1 SOL = 1e9 lamports)\n        const amountLamports = Math.floor(suggestedAmountSOL * 1e9);\n        try {\n            var _receipt_result, _receipt_result1, _receipt_result2, _receipt_result_logs, _receipt_result3, _receipt_result4, _receipt_result5, _receipt_result6, _receipt_result7, _receipt_result8, _receipt_result9;\n            // Get nonce\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_3__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"createSolanaPaymentLink\", [\n                amountLamports,\n                isFlexible,\n                description\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            // Create scheduled transaction\n            const { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Check if balance account exists, if not create it\n            const account = await this.connection.getAccountInfo(this.solanaUser.balanceAddress);\n            if (account === null) {\n                scheduledTransaction.instructions.unshift((0,_neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__.createBalanceAccountInstruction)(this.programAddress, this.solanaUser.publicKey, this.solanaUser.neonWallet, this.chainId));\n            }\n            // Get recent blockhash\n            const { blockhash } = await this.connection.getLatestBlockhash();\n            scheduledTransaction.recentBlockhash = blockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            // Sign with wallet adapter\n            const signedTx = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            // Send transaction\n            await this.connection.sendRawTransaction(signedTx.serialize());\n            // Wait for transaction execution on Neon EVM\n            const transactionStatus = await this.proxyApi.waitTransactionTreeExecution(this.solanaUser.neonWallet, nonce, 60000 // 60 second timeout\n            );\n            console.log(\"Transaction status:\", transactionStatus);\n            if (transactionStatus.length === 0 || transactionStatus[0].status !== \"Success\") {\n                throw new Error(\"Transaction failed to execute on Neon EVM\");\n            }\n            const txHash = transactionStatus[0].transactionHash;\n            console.log(\"Transaction hash:\", txHash);\n            // Get the link ID from transaction receipt\n            const receipt = await this.proxyApi.getTransactionReceipt(txHash);\n            console.log(\"Full transaction receipt:\", JSON.stringify(receipt, null, 2));\n            let linkId = \"\";\n            // Check if the transaction was successful\n            if (((_receipt_result = receipt.result) === null || _receipt_result === void 0 ? void 0 : _receipt_result.status) !== \"0x1\") {\n                var _receipt_result10;\n                throw new Error(\"Transaction failed - status: \" + ((_receipt_result10 = receipt.result) === null || _receipt_result10 === void 0 ? void 0 : _receipt_result10.status));\n            }\n            // Enhanced debugging of the receipt structure\n            console.log(\"Receipt status:\", (_receipt_result1 = receipt.result) === null || _receipt_result1 === void 0 ? void 0 : _receipt_result1.status);\n            console.log(\"Receipt logs array:\", (_receipt_result2 = receipt.result) === null || _receipt_result2 === void 0 ? void 0 : _receipt_result2.logs);\n            console.log(\"Receipt logs length:\", (_receipt_result3 = receipt.result) === null || _receipt_result3 === void 0 ? void 0 : (_receipt_result_logs = _receipt_result3.logs) === null || _receipt_result_logs === void 0 ? void 0 : _receipt_result_logs.length);\n            console.log(\"Receipt logsBloom:\", (_receipt_result4 = receipt.result) === null || _receipt_result4 === void 0 ? void 0 : _receipt_result4.logsBloom);\n            console.log(\"Receipt contractAddress:\", (_receipt_result5 = receipt.result) === null || _receipt_result5 === void 0 ? void 0 : _receipt_result5.contractAddress);\n            console.log(\"Receipt gasUsed:\", (_receipt_result6 = receipt.result) === null || _receipt_result6 === void 0 ? void 0 : _receipt_result6.gasUsed);\n            console.log(\"Receipt effectiveGasPrice:\", (_receipt_result7 = receipt.result) === null || _receipt_result7 === void 0 ? void 0 : _receipt_result7.effectiveGasPrice);\n            // Check if there's a different location for logs\n            console.log(\"Raw transaction data:\", (_receipt_result8 = receipt.result) === null || _receipt_result8 === void 0 ? void 0 : _receipt_result8.neonRawTransaction);\n            // Get additional transaction details\n            try {\n                const txDetails = await this.proxyApi.getTransaction(txHash);\n                console.log(\"Full transaction details:\", JSON.stringify(txDetails, null, 2));\n            } catch (e) {\n                console.log(\"Could not fetch transaction details:\", e);\n            }\n            // Extract all neonLogs from solanaTransactions\n            const allNeonLogs = [];\n            if ((_receipt_result9 = receipt.result) === null || _receipt_result9 === void 0 ? void 0 : _receipt_result9.solanaTransactions) {\n                for (const solTx of receipt.result.solanaTransactions){\n                    if (solTx.solanaInstructions) {\n                        for (const instruction of solTx.solanaInstructions){\n                            if (instruction.neonLogs && instruction.neonLogs.length > 0) {\n                                allNeonLogs.push(...instruction.neonLogs);\n                            }\n                        }\n                    }\n                }\n            }\n            console.log(\"Found\", allNeonLogs.length, \"neonLogs to parse\");\n            // Try to parse logs for the SolanaLinkCreated event\n            if (allNeonLogs.length > 0) {\n                for (const log of allNeonLogs){\n                    try {\n                        console.log(\"Trying to parse neonLog:\", log);\n                        // Check if this log is from our contract\n                        if (log.address.toLowerCase() === CONTRACT_ADDRESS.toLowerCase()) {\n                            console.log(\"Log is from our contract, parsing...\");\n                            // Convert the log to the format expected by ethers\n                            const ethersLog = {\n                                address: log.address,\n                                data: log.data,\n                                topics: log.topics\n                            };\n                            const parsedLog = iface.parseLog(ethersLog);\n                            console.log(\"Parsed log:\", parsedLog);\n                            if ((parsedLog === null || parsedLog === void 0 ? void 0 : parsedLog.name) === \"SolanaLinkCreated\") {\n                                linkId = parsedLog.args.linkId;\n                                console.log(\"✅ Found link ID from SolanaLinkCreated event:\", linkId);\n                                break;\n                            }\n                        } else {\n                            console.log(\"Log from different contract:\", log.address);\n                        }\n                    } catch (e) {\n                        console.log(\"Failed to parse neonLog:\", e);\n                    // Skip logs that can't be parsed\n                    }\n                }\n            } else {\n                console.warn(\"No neonLogs found in transaction receipt!\");\n                console.log(\"This might indicate:\");\n                console.log(\"1. The contract call failed silently\");\n                console.log(\"2. The contract is not at the expected address\");\n                console.log(\"3. The contract function call reverted\");\n                console.log(\"4. Events are not being emitted properly\");\n                // Try calling the contract read method to see if data was actually stored\n                try {\n                    console.log(\"Attempting to read payment link using transaction hash as ID...\");\n                    const testData = await this.contract.getSolanaPaymentLink(txHash);\n                    console.log(\"Contract read result:\", testData);\n                } catch (readError) {\n                    console.log(\"Contract read failed:\", readError);\n                }\n            }\n            // If we couldn't extract from logs, investigate further\n            if (!linkId) {\n                var _receipt_result11, _receipt_result12;\n                console.error(\"Could not extract link ID from transaction events!\");\n                console.log(\"This suggests the contract call may have failed silently\");\n                // Check if the transaction actually reverted\n                console.log(\"Checking for revert data...\");\n                if ((_receipt_result11 = receipt.result) === null || _receipt_result11 === void 0 ? void 0 : _receipt_result11.neonRevertData) {\n                    console.log(\"Revert data found:\", receipt.result.neonRevertData);\n                    try {\n                        // Try to decode the revert reason\n                        const revertReason = ethers__WEBPACK_IMPORTED_MODULE_4__.toUtf8String(receipt.result.neonRevertData);\n                        console.log(\"Revert reason:\", revertReason);\n                        throw new Error(\"Contract call reverted: \".concat(revertReason));\n                    } catch (decodeError) {\n                        console.log(\"Could not decode revert reason:\", decodeError);\n                        throw new Error(\"Contract call reverted with unknown reason\");\n                    }\n                }\n                // Let's try to understand why the event wasn't emitted\n                console.log(\"Analyzing function call...\");\n                console.log(\"Contract address:\", CONTRACT_ADDRESS);\n                console.log(\"From address:\", this.solanaUser.neonWallet);\n                console.log(\"Function data in raw tx:\", (_receipt_result12 = receipt.result) === null || _receipt_result12 === void 0 ? void 0 : _receipt_result12.neonRawTransaction);\n                // Check if user is registered\n                try {\n                    const isRegistered = await this.contract.isSolanaUser(this.solanaUser.neonWallet);\n                    console.log(\"Is user registered as Solana user:\", isRegistered);\n                    if (!isRegistered) {\n                        throw new Error(\"User is not registered as a Solana user with the contract. This is required to create payment links.\");\n                    }\n                } catch (registrationError) {\n                    console.error(\"Failed to check user registration:\", registrationError);\n                    throw registrationError;\n                }\n                // If we get here, something else went wrong\n                throw new Error(\"Payment link creation failed: Contract call executed but no event was emitted. The transaction may have failed silently.\");\n            }\n            return {\n                linkId,\n                txHash\n            };\n        } catch (error) {\n            console.error(\"Error creating payment link:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Initialize read-only contract access (without wallet)\n   */ async initReadOnlyContract() {\n        if (!this.contract) {\n            // Create a simple JSON RPC provider for read operations\n            const readOnlyProvider = new ethers__WEBPACK_IMPORTED_MODULE_5__.JsonRpcProvider(NEON_CORE_RPC_URL);\n            this.contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.Contract(CONTRACT_ADDRESS, SOLANA_TIPCARD_ABI, readOnlyProvider);\n        }\n    }\n    /**\n   * Get payment link details\n   */ async getPaymentLink(linkId) {\n        // Initialize contract if not already done\n        if (!this.contract) {\n            await this.initReadOnlyContract();\n        }\n        try {\n            const result = await this.contract.getSolanaPaymentLink(linkId);\n            return {\n                evmCreator: result.evmCreator,\n                solanaCreator: result.solanaCreator,\n                amount: result.amount,\n                isFlexible: result.isFlexible,\n                isActive: result.isActive,\n                totalReceived: result.totalReceived,\n                paymentCount: Number(result.paymentCount),\n                description: result.description\n            };\n        } catch (error) {\n            console.error(\"Contract call error:\", error);\n            throw new Error(\"Payment link not found or contract error\");\n        }\n    }\n    /**\n   * Get user's payment links\n   */ async getUserLinks(userEVMAddress) {\n        // Initialize contract if not already done\n        if (!this.contract) {\n            await this.initReadOnlyContract();\n        }\n        try {\n            return await this.contract.getUserSolanaLinks(userEVMAddress);\n        } catch (error) {\n            console.error(\"Error getting user links:\", error);\n            return [];\n        }\n    }\n    /**\n   * Pay a payment link using Solana Native SDK\n   */ async payLink(linkId, amountSOL) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        console.log(\"Starting payment process...\");\n        console.log(\"Link ID:\", linkId);\n        console.log(\"Amount SOL:\", amountSOL);\n        // First, get the payment link details to find the recipient\n        const linkData = await this.getPaymentLink(linkId);\n        console.log(\"Payment link data:\", linkData);\n        if (!linkData.isActive) {\n            throw new Error(\"Payment link is no longer active\");\n        }\n        // Convert SOL to lamports\n        const amountLamports = Math.floor(amountSOL * 1e9);\n        // Convert recipient Solana address from bytes32 to PublicKey\n        const recipientBytes = linkData.solanaCreator.startsWith(\"0x\") ? linkData.solanaCreator.slice(2) : linkData.solanaCreator;\n        // Remove leading zeros and convert to PublicKey\n        const recipientPubkeyBytes = new Uint8Array(32);\n        const hexBytes = recipientBytes.match(/.{2}/g) || [];\n        for(let i = 0; i < Math.min(hexBytes.length, 32); i++){\n            recipientPubkeyBytes[i] = parseInt(hexBytes[i], 16);\n        }\n        let transferSignature;\n        try {\n            var _transactionStatus_, _transactionStatus_1;\n            // Step 1: Perform the actual SOL transfer first\n            console.log(\"Step 1: Performing SOL transfer...\");\n            console.log(\"From:\", this.solanaUser.publicKey.toBase58());\n            console.log(\"To recipient bytes32:\", linkData.solanaCreator);\n            console.log(\"Amount lamports:\", amountLamports);\n            // Create the SOL transfer transaction\n            const { SystemProgram, Transaction } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"));\n            // Find the first non-zero byte to determine actual public key length\n            let actualKeyStart = 0;\n            for(let i = 0; i < recipientPubkeyBytes.length; i++){\n                if (recipientPubkeyBytes[i] !== 0) {\n                    actualKeyStart = i;\n                    break;\n                }\n            }\n            // Extract the 32-byte public key (should be the last 32 bytes if padded)\n            const actualKeyBytes = recipientPubkeyBytes.slice(actualKeyStart);\n            if (actualKeyBytes.length !== 32) {\n                // If not 32 bytes, take the last 32 bytes\n                const paddedKey = new Uint8Array(32);\n                const startOffset = Math.max(0, 32 - actualKeyBytes.length);\n                paddedKey.set(actualKeyBytes, startOffset);\n                recipientPubkeyBytes.set(paddedKey);\n            }\n            const recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(recipientPubkeyBytes);\n            console.log(\"Recipient PublicKey:\", recipientPubkey.toBase58());\n            // Create transfer instruction\n            const transferIx = SystemProgram.transfer({\n                fromPubkey: this.solanaUser.publicKey,\n                toPubkey: recipientPubkey,\n                lamports: amountLamports\n            });\n            // Create transaction\n            const transferTx = new Transaction().add(transferIx);\n            // Get recent blockhash\n            const { blockhash } = await this.connection.getLatestBlockhash();\n            transferTx.recentBlockhash = blockhash;\n            transferTx.feePayer = this.solanaUser.publicKey;\n            // Sign and send the SOL transfer\n            const signedTransferTx = await this.solanaUser.walletAdapter.signTransaction(transferTx);\n            transferSignature = await this.connection.sendRawTransaction(signedTransferTx.serialize());\n            console.log(\"SOL transfer sent:\", transferSignature);\n            // Wait for transfer confirmation\n            await this.connection.confirmTransaction(transferSignature, \"confirmed\");\n            console.log(\"SOL transfer confirmed\");\n            // Step 2: Record the payment in the contract\n            console.log(\"Step 2: Recording payment in contract...\");\n            // Convert Solana PublicKey to bytes32\n            const payerSolanaBytes32 = (0,ethers__WEBPACK_IMPORTED_MODULE_6__.zeroPadValue)((0,ethers__WEBPACK_IMPORTED_MODULE_6__.hexlify)(this.solanaUser.publicKey.toBytes()), 32);\n            // Get nonce\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_3__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"paySolanaLink\", [\n                linkId,\n                amountLamports,\n                payerSolanaBytes32\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            // Create scheduled transaction\n            const { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Get recent blockhash\n            const contractBlockhash = await this.connection.getLatestBlockhash();\n            scheduledTransaction.recentBlockhash = contractBlockhash.blockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            // Sign with wallet adapter\n            const signedTx = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            // Send transaction\n            await this.connection.sendRawTransaction(signedTx.serialize());\n            // Wait for transaction execution on Neon EVM\n            const transactionStatus = await this.proxyApi.waitTransactionTreeExecution(this.solanaUser.neonWallet, nonce, 60000);\n            if (transactionStatus.length === 0 || transactionStatus[0].status !== \"Success\") {\n                console.warn(\"Contract payment recording failed, but SOL transfer succeeded\");\n                console.log(\"Transfer signature:\", transferSignature);\n            // Don't throw error - the payment went through even if recording failed\n            }\n            console.log(\"Payment completed successfully!\");\n            console.log(\"SOL transfer:\", transferSignature);\n            console.log(\"Contract record:\", (_transactionStatus_ = transactionStatus[0]) === null || _transactionStatus_ === void 0 ? void 0 : _transactionStatus_.transactionHash);\n            return {\n                txHash: ((_transactionStatus_1 = transactionStatus[0]) === null || _transactionStatus_1 === void 0 ? void 0 : _transactionStatus_1.transactionHash) || \"contract-recording-failed\",\n                transferSignature\n            };\n        } catch (error) {\n            console.error(\"Error paying link:\", error);\n            if (transferSignature) {\n                console.log(\"Note: SOL transfer may have succeeded:\", transferSignature);\n            }\n            throw error;\n        }\n    }\n    /**\n   * Deactivate a payment link\n   */ async deactivateLink(linkId) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        try {\n            // Get nonce\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_3__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"deactivateSolanaLink\", [\n                linkId\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            // Create scheduled transaction\n            const { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Get recent blockhash\n            const { blockhash } = await this.connection.getLatestBlockhash();\n            scheduledTransaction.recentBlockhash = blockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            // Sign with wallet adapter\n            const signedTx = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            // Send transaction\n            await this.connection.sendRawTransaction(signedTx.serialize());\n            // Wait for transaction execution\n            const transactionStatus = await this.proxyApi.waitTransactionTreeExecution(this.solanaUser.neonWallet, nonce, 60000);\n            if (transactionStatus.length === 0 || transactionStatus[0].status !== \"Success\") {\n                throw new Error(\"Deactivation transaction failed to execute on Neon EVM\");\n            }\n            return {\n                txHash: transactionStatus[0].transactionHash\n            };\n        } catch (error) {\n            throw error;\n        }\n    }\n    /**\n   * Create a shareable URL for a payment link\n   */ createPaymentURL(linkId) {\n        return \"\".concat(window.location.origin, \"?pay=\").concat(linkId);\n    }\n    /**\n   * Extract link ID from URL\n   */ static extractLinkIdFromURL(url) {\n        try {\n            const urlObj = new URL(url);\n            return urlObj.searchParams.get(\"pay\");\n        } catch (e) {\n            return null;\n        }\n    }\n    /**\n   * Get the user's EVM address derived from Solana public key\n   */ getUserEVMAddress() {\n        var _this_solanaUser;\n        return ((_this_solanaUser = this.solanaUser) === null || _this_solanaUser === void 0 ? void 0 : _this_solanaUser.neonWallet) || null;\n    }\n    constructor(){\n        this.programAddress = null;\n        this.chainId = null;\n        this.contract = null;\n        this.connection = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Connection(SOLANA_RPC_URL, \"confirmed\");\n        this.proxyApi = new _neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__.NeonProxyRpcApi(NEON_PROXY_RPC_URL);\n    }\n}\n// Export singleton instance\nconst solanaNativeContract = new SolanaNativeContract();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3NvbGFuYS1uYXRpdmUtY29udHJhY3QudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQWdFO0FBQ3VCO0FBQ2pDO0FBRXRELDRDQUE0QztBQUM1QyxNQUFNTSxxQkFBcUI7SUFDekI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFRCxNQUFNQyxtQkFBbUJDLDRDQUFnRCxJQUFJO0FBQzdFLE1BQU1HLG9CQUFvQkgsNEJBQW9DLElBQUk7QUFDbEUsTUFBTUsscUJBQXFCLEdBQXFCLE9BQWxCRixtQkFBa0I7QUFDaEQsTUFBTUcsaUJBQWlCO0FBYWhCLE1BQU1DO0lBY1g7O0dBRUMsR0FDRCxNQUFNQyxxQkFBcUJDLGFBQWtCLEVBQWlCO1FBQzVELElBQUksQ0FBQ0EsY0FBY0MsU0FBUyxFQUFFO1lBQzVCLE1BQU0sSUFBSUMsTUFBTTtRQUNsQjtRQUVBLElBQUk7WUFDRiw2REFBNkQ7WUFDN0QsTUFBTUMsYUFBYSxNQUFNLElBQUksQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNMLGNBQWNDLFNBQVM7WUFFbkUsSUFBSSxDQUFDSyxPQUFPLEdBQUdILFdBQVdHLE9BQU87WUFDakMsSUFBSSxDQUFDQyxjQUFjLEdBQUdKLFdBQVdJLGNBQWM7WUFDL0MsSUFBSSxDQUFDQyxRQUFRLEdBQUdMLFdBQVdLLFFBQVE7WUFDbkMsSUFBSSxDQUFDQyxVQUFVLEdBQUdOLFdBQVdNLFVBQVU7WUFFdkMsb0RBQW9EO1lBQ3BELElBQUksQ0FBQ0EsVUFBVSxDQUFDVCxhQUFhLEdBQUdBO1lBRWhDLDJCQUEyQjtZQUMzQixJQUFJLENBQUNVLFFBQVEsR0FBRyxJQUFJeEIsNENBQWUsQ0FBQ0ksa0JBQWtCRCxvQkFBb0IsSUFBSSxDQUFDbUIsUUFBUTtZQUV2Riw4Q0FBOEM7WUFDOUMsSUFBSTtnQkFDRkksUUFBUUMsR0FBRyxDQUFDLGtDQUFrQ3ZCO2dCQUM5QyxNQUFNd0IsT0FBTyxN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QUNuQ0QsVUFBeUI7YUFDekJJLFdBQW1DO1FBR3pDLElBQUksQ0FBQ2UsVUFBVSxHQUFHLElBQUkxQyx1REFBVUEsQ0FBQ2MsZ0JBQWdCO1FBQ2pELElBQUksQ0FBQ08sUUFBUSxHQUFHLElBQUlwQixpRUFBZUEsQ0FBQ1k7SUFDdEM7QUErbkJGO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU04Syx1QkFBdUIsSUFBSTVLLHVCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy9zb2xhbmEtbmF0aXZlLWNvbnRyYWN0LnRzP2Q0YzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29ubmVjdGlvbiwgUHVibGljS2V5LCBLZXlwYWlyIH0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJ1xuaW1wb3J0IHsgTmVvblByb3h5UnBjQXBpLCBjcmVhdGVCYWxhbmNlQWNjb3VudEluc3RydWN0aW9uIH0gZnJvbSAnQG5lb25ldm0vc29sYW5hLXNpZ24nXG5pbXBvcnQgeyBldGhlcnMsIGhleGxpZnksIHplcm9QYWRWYWx1ZSB9IGZyb20gJ2V0aGVycydcblxuLy8gQ29udHJhY3QgQUJJIC0gb25seSB0aGUgZnVuY3Rpb25zIHdlIG5lZWRcbmNvbnN0IFNPTEFOQV9USVBDQVJEX0FCSSA9IFtcbiAgXCJmdW5jdGlvbiBjcmVhdGVTb2xhbmFQYXltZW50TGluayh1aW50NjQgX3N1Z2dlc3RlZEFtb3VudCwgYm9vbCBfaXNGbGV4aWJsZSwgc3RyaW5nIG1lbW9yeSBfZGVzY3JpcHRpb24pIGV4dGVybmFsIHJldHVybnMgKGJ5dGVzMzIpXCIsXG4gIFwiZnVuY3Rpb24gZ2V0U29sYW5hUGF5bWVudExpbmsoYnl0ZXMzMiBfbGlua0lkKSBleHRlcm5hbCB2aWV3IHJldHVybnMgKHR1cGxlKGFkZHJlc3MgZXZtQ3JlYXRvciwgYnl0ZXMzMiBzb2xhbmFDcmVhdG9yLCB1aW50NjQgYW1vdW50LCBib29sIGlzRmxleGlibGUsIGJvb2wgaXNBY3RpdmUsIHVpbnQ2NCB0b3RhbFJlY2VpdmVkLCB1aW50MzIgcGF5bWVudENvdW50LCBzdHJpbmcgZGVzY3JpcHRpb24pKVwiLFxuICBcImZ1bmN0aW9uIGdldFVzZXJTb2xhbmFMaW5rcyhhZGRyZXNzIF91c2VyKSBleHRlcm5hbCB2aWV3IHJldHVybnMgKGJ5dGVzMzJbXSBtZW1vcnkpXCIsXG4gIFwiZnVuY3Rpb24gcGF5U29sYW5hTGluayhieXRlczMyIF9saW5rSWQsIHVpbnQ2NCBfYW1vdW50LCBieXRlczMyIF9wYXllclNvbGFuYUFjY291bnQpIGV4dGVybmFsXCIsXG4gIFwiZnVuY3Rpb24gZGVhY3RpdmF0ZVNvbGFuYUxpbmsoYnl0ZXMzMiBfbGlua0lkKSBleHRlcm5hbFwiLFxuICBcImZ1bmN0aW9uIGdldFNvbGFuYVVzZXJBZGRyZXNzKGFkZHJlc3MgX2V2bUFkZHJlc3MpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAoYnl0ZXMzMilcIixcbiAgXCJmdW5jdGlvbiBpc1NvbGFuYVVzZXIoYWRkcmVzcyBfZXZtQWRkcmVzcykgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChib29sKVwiLFxuICBcImV2ZW50IFNvbGFuYUxpbmtDcmVhdGVkKGJ5dGVzMzIgaW5kZXhlZCBsaW5rSWQsIGFkZHJlc3MgaW5kZXhlZCBldm1DcmVhdG9yLCBieXRlczMyIGluZGV4ZWQgc29sYW5hQ3JlYXRvciwgdWludDY0IGFtb3VudCwgYm9vbCBpc0ZsZXhpYmxlLCBzdHJpbmcgZGVzY3JpcHRpb24pXCIsXG4gIFwiZXZlbnQgU29sYW5hUGF5bWVudFJlY2VpdmVkKGJ5dGVzMzIgaW5kZXhlZCBsaW5rSWQsIGJ5dGVzMzIgaW5kZXhlZCBwYXllclNvbGFuYSwgYnl0ZXMzMiBpbmRleGVkIHJlY2lwaWVudFNvbGFuYSwgdWludDY0IGFtb3VudClcIlxuXVxuXG5jb25zdCBDT05UUkFDVF9BRERSRVNTID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfVElQQ0FSRF9DT05UUkFDVF9BRERSRVNTIHx8ICcweDM4OEVkNzlGRTFBMEEwNWZhNWFkQzE0ODYzRUIxNTNhMzFFNGU0NjknXG5jb25zdCBORU9OX0NPUkVfUlBDX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX05FT05fUlBDX1VSTCB8fCAnaHR0cHM6Ly9kZXZuZXQubmVvbmV2bS5vcmcnXG5jb25zdCBORU9OX1BST1hZX1JQQ19VUkwgPSBgJHtORU9OX0NPUkVfUlBDX1VSTH0vc29sYFxuY29uc3QgU09MQU5BX1JQQ19VUkwgPSAnaHR0cHM6Ly9hcGkuZGV2bmV0LnNvbGFuYS5jb20nXG5cbmV4cG9ydCBpbnRlcmZhY2UgUGF5bWVudExpbmsge1xuICBldm1DcmVhdG9yOiBzdHJpbmdcbiAgc29sYW5hQ3JlYXRvcjogc3RyaW5nXG4gIGFtb3VudDogYmlnaW50XG4gIGlzRmxleGlibGU6IGJvb2xlYW5cbiAgaXNBY3RpdmU6IGJvb2xlYW5cbiAgdG90YWxSZWNlaXZlZDogYmlnaW50XG4gIHBheW1lbnRDb3VudDogbnVtYmVyXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcbn1cblxuZXhwb3J0IGNsYXNzIFNvbGFuYU5hdGl2ZUNvbnRyYWN0IHtcbiAgcHJpdmF0ZSBjb25uZWN0aW9uOiBDb25uZWN0aW9uXG4gIHByaXZhdGUgcHJveHlBcGk6IE5lb25Qcm94eVJwY0FwaVxuICBwcml2YXRlIHNvbGFuYVVzZXI6IGFueVxuICBwcml2YXRlIHByb3ZpZGVyOiBhbnlcbiAgcHJpdmF0ZSBwcm9ncmFtQWRkcmVzczogUHVibGljS2V5IHwgbnVsbCA9IG51bGxcbiAgcHJpdmF0ZSBjaGFpbklkOiBudW1iZXIgfCBudWxsID0gbnVsbFxuICBwcml2YXRlIGNvbnRyYWN0OiBldGhlcnMuQ29udHJhY3QgfCBudWxsID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldyBDb25uZWN0aW9uKFNPTEFOQV9SUENfVVJMLCAnY29uZmlybWVkJylcbiAgICB0aGlzLnByb3h5QXBpID0gbmV3IE5lb25Qcm94eVJwY0FwaShORU9OX1BST1hZX1JQQ19VUkwpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB3aXRoIFNvbGFuYSB3YWxsZXQgdXNpbmcgdGhlIE5hdGl2ZSBTREtcbiAgICovXG4gIGFzeW5jIGluaXRXaXRoU29sYW5hV2FsbGV0KHdhbGxldEFkYXB0ZXI6IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghd2FsbGV0QWRhcHRlci5wdWJsaWNLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBjb25uZWN0ZWQnKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBJbml0aWFsaXplIHRoZSBOZW9uIFByb3h5IEFQSSB3aXRoIHRoZSB3YWxsZXQncyBwdWJsaWMga2V5XG4gICAgICBjb25zdCBpbml0UmVzdWx0ID0gYXdhaXQgdGhpcy5wcm94eUFwaS5pbml0KHdhbGxldEFkYXB0ZXIucHVibGljS2V5KVxuICAgICAgXG4gICAgICB0aGlzLmNoYWluSWQgPSBpbml0UmVzdWx0LmNoYWluSWRcbiAgICAgIHRoaXMucHJvZ3JhbUFkZHJlc3MgPSBpbml0UmVzdWx0LnByb2dyYW1BZGRyZXNzXG4gICAgICB0aGlzLnByb3ZpZGVyID0gaW5pdFJlc3VsdC5wcm92aWRlclxuICAgICAgdGhpcy5zb2xhbmFVc2VyID0gaW5pdFJlc3VsdC5zb2xhbmFVc2VyXG4gICAgICBcbiAgICAgIC8vIEFkZCB3YWxsZXQgYWRhcHRlciB0byB0aGUgc29sYW5hIHVzZXIgZm9yIHNpZ25pbmdcbiAgICAgIHRoaXMuc29sYW5hVXNlci53YWxsZXRBZGFwdGVyID0gd2FsbGV0QWRhcHRlclxuXG4gICAgICAvLyBDcmVhdGUgY29udHJhY3QgaW5zdGFuY2VcbiAgICAgIHRoaXMuY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KENPTlRSQUNUX0FERFJFU1MsIFNPTEFOQV9USVBDQVJEX0FCSSwgdGhpcy5wcm92aWRlcilcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IGNvbnRyYWN0IGlzIGRlcGxveWVkIGF0IHRoaXMgYWRkcmVzc1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coJ1ZlcmlmeWluZyBjb250cmFjdCBhdCBhZGRyZXNzOicsIENPTlRSQUNUX0FERFJFU1MpXG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldENvZGUoQ09OVFJBQ1RfQUREUkVTUylcbiAgICAgICAgY29uc29sZS5sb2coJ0NvbnRyYWN0IGNvZGUgbGVuZ3RoOicsIGNvZGUubGVuZ3RoKVxuICAgICAgICBpZiAoY29kZSA9PT0gJzB4Jykge1xuICAgICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIE5vIGNvbnRyYWN0IGNvZGUgZm91bmQgYXQgYWRkcmVzczonLCBDT05UUkFDVF9BRERSRVNTKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCdUaGlzIG1pZ2h0IG1lYW4gdGhlIGNvbnRyYWN0IGlzIG5vdCBkZXBsb3llZCBvciBhZGRyZXNzIGlzIGluY29ycmVjdCcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBDb250cmFjdCBmb3VuZCBhdCBhZGRyZXNzJylcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBpZiB1c2VyJ3MgU29sYW5hIGFkZHJlc3MgaXMgcmVnaXN0ZXJlZCB3aXRoIE5lb24gRVZNXG4gICAgICAgICAgY29uc29sZS5sb2coJ0NoZWNraW5nIFNvbGFuYSB1c2VyIHJlZ2lzdHJhdGlvbi4uLicpXG4gICAgICAgICAgY29uc29sZS5sb2coJ1VzZXIgRVZNIGFkZHJlc3M6JywgdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQpXG4gICAgICAgICAgY29uc29sZS5sb2coJ1VzZXIgU29sYW5hIGFkZHJlc3M6JywgdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleS50b0Jhc2U1OCgpKVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdldCB0aGUgU29sYW5hIGFkZHJlc3MgdGhhdCBOZW9uIEVWTSBoYXMgcmVnaXN0ZXJlZCBmb3IgdGhpcyB1c2VyXG4gICAgICAgICAgY29uc3QgcmVnaXN0ZXJlZFNvbGFuYUFkZHIgPSBhd2FpdCB0aGlzLmNvbnRyYWN0LmdldFNvbGFuYVVzZXJBZGRyZXNzKHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0KVxuICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWdpc3RlcmVkIFNvbGFuYSBhZGRyZXNzIChmcm9tIGNvbnRyYWN0KTonLCByZWdpc3RlcmVkU29sYW5hQWRkcilcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBpc1VzZXJSZWdpc3RlcmVkID0gYXdhaXQgdGhpcy5jb250cmFjdC5pc1NvbGFuYVVzZXIodGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQpXG4gICAgICAgICAgY29uc29sZS5sb2coJ0lzIHVzZXIgcmVnaXN0ZXJlZCB3aXRoIGNvbnRyYWN0OicsIGlzVXNlclJlZ2lzdGVyZWQpXG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCFpc1VzZXJSZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBVc2VyIGlzIG5vdCByZWdpc3RlcmVkIGFzIFNvbGFuYSB1c2VyIHdpdGggTmVvbiBFVk0nKVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1RoaXMgbWF5IGhhcHBlbiBpZiB0aGUgU29sYW5hIE5hdGl2ZSBTREsgaW5pdGlhbGl6YXRpb24gZGlkIG5vdCBjb21wbGV0ZSBwcm9wZXJseScpXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVGhlIFNESyBzaG91bGQgYXV0b21hdGljYWxseSByZWdpc3RlciB0aGUgdXNlciBkdXJpbmcgaW5pdCgpIGNhbGwnKVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0F0dGVtcHRpbmcgdG8gY3JlYXRlIGJhbGFuY2UgYWNjb3VudCB0byBjb21wbGV0ZSByZWdpc3RyYXRpb24uLi4nKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBUcnkgdG8gY3JlYXRlIHRoZSBiYWxhbmNlIGFjY291bnQgd2hpY2ggc2hvdWxkIHJlZ2lzdGVyIHRoZSB1c2VyXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldEFjY291bnRJbmZvKHRoaXMuc29sYW5hVXNlci5iYWxhbmNlQWRkcmVzcylcbiAgICAgICAgICAgICAgaWYgKGFjY291bnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQmFsYW5jZSBhY2NvdW50IGRvZXMgbm90IGV4aXN0LCB3aWxsIGNyZWF0ZSBpdCBvbiBmaXJzdCB0cmFuc2FjdGlvbicpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0JhbGFuY2UgYWNjb3VudCBleGlzdHMsIHVzZXIgc2hvdWxkIGJlIHJlZ2lzdGVyZWQnKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChiYWxhbmNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0NvdWxkIG5vdCBjaGVjayBiYWxhbmNlIGFjY291bnQ6JywgYmFsYW5jZUVycm9yKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIFVzZXIgaXMgcHJvcGVybHkgcmVnaXN0ZXJlZCcpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoICh2ZXJpZnlFcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byB2ZXJpZnkgY29udHJhY3Q6JywgdmVyaWZ5RXJyb3IpXG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgU29sYW5hIE5hdGl2ZSBTREs6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBwYXltZW50IGxpbmsgdXNpbmcgU29sYW5hIE5hdGl2ZSBTREtcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVBheW1lbnRMaW5rKFxuICAgIHN1Z2dlc3RlZEFtb3VudFNPTDogbnVtYmVyLFxuICAgIGlzRmxleGlibGU6IGJvb2xlYW4sXG4gICAgZGVzY3JpcHRpb246IHN0cmluZ1xuICApOiBQcm9taXNlPHsgbGlua0lkOiBzdHJpbmc7IHR4SGFzaDogc3RyaW5nIH0+IHtcbiAgICBpZiAoIXRoaXMuc29sYW5hVXNlciB8fCAhdGhpcy5jb250cmFjdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgY29ubmVjdCB3YWxsZXQgZmlyc3QnKVxuICAgIH1cblxuICAgIC8vIENvbnZlcnQgU09MIHRvIGxhbXBvcnRzICgxIFNPTCA9IDFlOSBsYW1wb3J0cylcbiAgICBjb25zdCBhbW91bnRMYW1wb3J0cyA9IE1hdGguZmxvb3Ioc3VnZ2VzdGVkQW1vdW50U09MICogMWU5KVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBub25jZVxuICAgICAgY29uc3Qgbm9uY2UgPSBOdW1iZXIoYXdhaXQgdGhpcy5wcm94eUFwaS5nZXRUcmFuc2FjdGlvbkNvdW50KHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0KSlcblxuICAgICAgLy8gUHJlcGFyZSBjb250cmFjdCBjYWxsIGRhdGFcbiAgICAgIGNvbnN0IGlmYWNlID0gbmV3IGV0aGVycy5JbnRlcmZhY2UoU09MQU5BX1RJUENBUkRfQUJJKVxuICAgICAgY29uc3QgZGF0YSA9IGlmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YSgnY3JlYXRlU29sYW5hUGF5bWVudExpbmsnLCBbXG4gICAgICAgIGFtb3VudExhbXBvcnRzLFxuICAgICAgICBpc0ZsZXhpYmxlLFxuICAgICAgICBkZXNjcmlwdGlvblxuICAgICAgXSlcblxuICAgICAgLy8gQ3JlYXRlIHRyYW5zYWN0aW9uIGRhdGFcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uRGF0YSA9IHtcbiAgICAgICAgZnJvbTogdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsXG4gICAgICAgIHRvOiBDT05UUkFDVF9BRERSRVNTLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9XG5cbiAgICAgIC8vIEVzdGltYXRlIGdhc1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25HYXMgPSBhd2FpdCB0aGlzLnByb3h5QXBpLmVzdGltYXRlU2NoZWR1bGVkVHJhbnNhY3Rpb25HYXMoe1xuICAgICAgICBzb2xhbmFQYXllcjogdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleSxcbiAgICAgICAgdHJhbnNhY3Rpb25zOiBbdHJhbnNhY3Rpb25EYXRhXSxcbiAgICAgIH0pXG5cbiAgICAgIC8vIENyZWF0ZSBzY2hlZHVsZWQgdHJhbnNhY3Rpb25cbiAgICAgIGNvbnN0IHsgc2NoZWR1bGVkVHJhbnNhY3Rpb24gfSA9IGF3YWl0IHRoaXMucHJveHlBcGkuY3JlYXRlU2NoZWR1bGVkVHJhbnNhY3Rpb24oe1xuICAgICAgICB0cmFuc2FjdGlvbkdhcyxcbiAgICAgICAgdHJhbnNhY3Rpb25EYXRhLFxuICAgICAgICBub25jZVxuICAgICAgfSlcblxuICAgICAgLy8gQ2hlY2sgaWYgYmFsYW5jZSBhY2NvdW50IGV4aXN0cywgaWYgbm90IGNyZWF0ZSBpdFxuICAgICAgY29uc3QgYWNjb3VudCA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5nZXRBY2NvdW50SW5mbyh0aGlzLnNvbGFuYVVzZXIuYmFsYW5jZUFkZHJlc3MpXG4gICAgICBpZiAoYWNjb3VudCA9PT0gbnVsbCkge1xuICAgICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5pbnN0cnVjdGlvbnMudW5zaGlmdChcbiAgICAgICAgICBjcmVhdGVCYWxhbmNlQWNjb3VudEluc3RydWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5wcm9ncmFtQWRkcmVzcyEsXG4gICAgICAgICAgICB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LFxuICAgICAgICAgICAgdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsXG4gICAgICAgICAgICB0aGlzLmNoYWluSWQhXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIEdldCByZWNlbnQgYmxvY2toYXNoXG4gICAgICBjb25zdCB7IGJsb2NraGFzaCB9ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgpXG4gICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBibG9ja2hhc2hcbiAgICAgIHNjaGVkdWxlZFRyYW5zYWN0aW9uLmZlZVBheWVyID0gdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleVxuXG4gICAgICAvLyBTaWduIHdpdGggd2FsbGV0IGFkYXB0ZXJcbiAgICAgIGNvbnN0IHNpZ25lZFR4ID0gYXdhaXQgdGhpcy5zb2xhbmFVc2VyLndhbGxldEFkYXB0ZXIuc2lnblRyYW5zYWN0aW9uKHNjaGVkdWxlZFRyYW5zYWN0aW9uKVxuICAgICAgXG4gICAgICAvLyBTZW5kIHRyYW5zYWN0aW9uXG4gICAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uc2VuZFJhd1RyYW5zYWN0aW9uKHNpZ25lZFR4LnNlcmlhbGl6ZSgpKVxuXG4gICAgICAvLyBXYWl0IGZvciB0cmFuc2FjdGlvbiBleGVjdXRpb24gb24gTmVvbiBFVk1cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uU3RhdHVzID0gYXdhaXQgdGhpcy5wcm94eUFwaS53YWl0VHJhbnNhY3Rpb25UcmVlRXhlY3V0aW9uKFxuICAgICAgICB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCwgXG4gICAgICAgIG5vbmNlLCBcbiAgICAgICAgNjAwMDAgLy8gNjAgc2Vjb25kIHRpbWVvdXRcbiAgICAgIClcblxuICAgICAgY29uc29sZS5sb2coJ1RyYW5zYWN0aW9uIHN0YXR1czonLCB0cmFuc2FjdGlvblN0YXR1cylcblxuICAgICAgaWYgKHRyYW5zYWN0aW9uU3RhdHVzLmxlbmd0aCA9PT0gMCB8fCB0cmFuc2FjdGlvblN0YXR1c1swXS5zdGF0dXMgIT09ICdTdWNjZXNzJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIGZhaWxlZCB0byBleGVjdXRlIG9uIE5lb24gRVZNJylcbiAgICAgIH1cblxuICAgICAgY29uc3QgdHhIYXNoID0gdHJhbnNhY3Rpb25TdGF0dXNbMF0udHJhbnNhY3Rpb25IYXNoXG4gICAgICBjb25zb2xlLmxvZygnVHJhbnNhY3Rpb24gaGFzaDonLCB0eEhhc2gpXG5cbiAgICAgIC8vIEdldCB0aGUgbGluayBJRCBmcm9tIHRyYW5zYWN0aW9uIHJlY2VpcHRcbiAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3h5QXBpLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpXG4gICAgICBjb25zb2xlLmxvZygnRnVsbCB0cmFuc2FjdGlvbiByZWNlaXB0OicsIEpTT04uc3RyaW5naWZ5KHJlY2VpcHQsIG51bGwsIDIpKVxuICAgICAgXG4gICAgICBsZXQgbGlua0lkID0gJydcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIHRyYW5zYWN0aW9uIHdhcyBzdWNjZXNzZnVsXG4gICAgICBpZiAocmVjZWlwdC5yZXN1bHQ/LnN0YXR1cyAhPT0gJzB4MScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBmYWlsZWQgLSBzdGF0dXM6ICcgKyByZWNlaXB0LnJlc3VsdD8uc3RhdHVzKVxuICAgICAgfVxuXG4gICAgICAvLyBFbmhhbmNlZCBkZWJ1Z2dpbmcgb2YgdGhlIHJlY2VpcHQgc3RydWN0dXJlXG4gICAgICBjb25zb2xlLmxvZygnUmVjZWlwdCBzdGF0dXM6JywgcmVjZWlwdC5yZXN1bHQ/LnN0YXR1cylcbiAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXB0IGxvZ3MgYXJyYXk6JywgcmVjZWlwdC5yZXN1bHQ/LmxvZ3MpXG4gICAgICBjb25zb2xlLmxvZygnUmVjZWlwdCBsb2dzIGxlbmd0aDonLCByZWNlaXB0LnJlc3VsdD8ubG9ncz8ubGVuZ3RoKVxuICAgICAgY29uc29sZS5sb2coJ1JlY2VpcHQgbG9nc0Jsb29tOicsIHJlY2VpcHQucmVzdWx0Py5sb2dzQmxvb20pXG4gICAgICBjb25zb2xlLmxvZygnUmVjZWlwdCBjb250cmFjdEFkZHJlc3M6JywgcmVjZWlwdC5yZXN1bHQ/LmNvbnRyYWN0QWRkcmVzcylcbiAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXB0IGdhc1VzZWQ6JywgcmVjZWlwdC5yZXN1bHQ/Lmdhc1VzZWQpXG4gICAgICBjb25zb2xlLmxvZygnUmVjZWlwdCBlZmZlY3RpdmVHYXNQcmljZTonLCByZWNlaXB0LnJlc3VsdD8uZWZmZWN0aXZlR2FzUHJpY2UpXG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZXJlJ3MgYSBkaWZmZXJlbnQgbG9jYXRpb24gZm9yIGxvZ3NcbiAgICAgIGNvbnNvbGUubG9nKCdSYXcgdHJhbnNhY3Rpb24gZGF0YTonLCByZWNlaXB0LnJlc3VsdD8ubmVvblJhd1RyYW5zYWN0aW9uKVxuICAgICAgXG4gICAgICAvLyBHZXQgYWRkaXRpb25hbCB0cmFuc2FjdGlvbiBkZXRhaWxzXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB0eERldGFpbHMgPSBhd2FpdCB0aGlzLnByb3h5QXBpLmdldFRyYW5zYWN0aW9uKHR4SGFzaClcbiAgICAgICAgY29uc29sZS5sb2coJ0Z1bGwgdHJhbnNhY3Rpb24gZGV0YWlsczonLCBKU09OLnN0cmluZ2lmeSh0eERldGFpbHMsIG51bGwsIDIpKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnQ291bGQgbm90IGZldGNoIHRyYW5zYWN0aW9uIGRldGFpbHM6JywgZSlcbiAgICAgIH1cblxuICAgICAgLy8gRXh0cmFjdCBhbGwgbmVvbkxvZ3MgZnJvbSBzb2xhbmFUcmFuc2FjdGlvbnNcbiAgICAgIGNvbnN0IGFsbE5lb25Mb2dzOiBhbnlbXSA9IFtdXG4gICAgICBpZiAocmVjZWlwdC5yZXN1bHQ/LnNvbGFuYVRyYW5zYWN0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IHNvbFR4IG9mIHJlY2VpcHQucmVzdWx0LnNvbGFuYVRyYW5zYWN0aW9ucykge1xuICAgICAgICAgIGlmIChzb2xUeC5zb2xhbmFJbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5zdHJ1Y3Rpb24gb2Ygc29sVHguc29sYW5hSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5uZW9uTG9ncyAmJiBpbnN0cnVjdGlvbi5uZW9uTG9ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgYWxsTmVvbkxvZ3MucHVzaCguLi5pbnN0cnVjdGlvbi5uZW9uTG9ncylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnRm91bmQnLCBhbGxOZW9uTG9ncy5sZW5ndGgsICduZW9uTG9ncyB0byBwYXJzZScpXG5cbiAgICAgIC8vIFRyeSB0byBwYXJzZSBsb2dzIGZvciB0aGUgU29sYW5hTGlua0NyZWF0ZWQgZXZlbnRcbiAgICAgIGlmIChhbGxOZW9uTG9ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAoY29uc3QgbG9nIG9mIGFsbE5lb25Mb2dzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUcnlpbmcgdG8gcGFyc2UgbmVvbkxvZzonLCBsb2cpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgbG9nIGlzIGZyb20gb3VyIGNvbnRyYWN0XG4gICAgICAgICAgICBpZiAobG9nLmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gQ09OVFJBQ1RfQUREUkVTUy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdMb2cgaXMgZnJvbSBvdXIgY29udHJhY3QsIHBhcnNpbmcuLi4nKVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgbG9nIHRvIHRoZSBmb3JtYXQgZXhwZWN0ZWQgYnkgZXRoZXJzXG4gICAgICAgICAgICAgIGNvbnN0IGV0aGVyc0xvZyA9IHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBsb2cuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBkYXRhOiBsb2cuZGF0YSxcbiAgICAgICAgICAgICAgICB0b3BpY3M6IGxvZy50b3BpY3NcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgY29uc3QgcGFyc2VkTG9nID0gaWZhY2UucGFyc2VMb2coZXRoZXJzTG9nKVxuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUGFyc2VkIGxvZzonLCBwYXJzZWRMb2cpXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAocGFyc2VkTG9nPy5uYW1lID09PSAnU29sYW5hTGlua0NyZWF0ZWQnKSB7XG4gICAgICAgICAgICAgICAgbGlua0lkID0gcGFyc2VkTG9nLmFyZ3MubGlua0lkXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ+KchSBGb3VuZCBsaW5rIElEIGZyb20gU29sYW5hTGlua0NyZWF0ZWQgZXZlbnQ6JywgbGlua0lkKVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdMb2cgZnJvbSBkaWZmZXJlbnQgY29udHJhY3Q6JywgbG9nLmFkZHJlc3MpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCB0byBwYXJzZSBuZW9uTG9nOicsIGUpXG4gICAgICAgICAgICAvLyBTa2lwIGxvZ3MgdGhhdCBjYW4ndCBiZSBwYXJzZWRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybignTm8gbmVvbkxvZ3MgZm91bmQgaW4gdHJhbnNhY3Rpb24gcmVjZWlwdCEnKVxuICAgICAgICBjb25zb2xlLmxvZygnVGhpcyBtaWdodCBpbmRpY2F0ZTonKVxuICAgICAgICBjb25zb2xlLmxvZygnMS4gVGhlIGNvbnRyYWN0IGNhbGwgZmFpbGVkIHNpbGVudGx5JylcbiAgICAgICAgY29uc29sZS5sb2coJzIuIFRoZSBjb250cmFjdCBpcyBub3QgYXQgdGhlIGV4cGVjdGVkIGFkZHJlc3MnKVxuICAgICAgICBjb25zb2xlLmxvZygnMy4gVGhlIGNvbnRyYWN0IGZ1bmN0aW9uIGNhbGwgcmV2ZXJ0ZWQnKVxuICAgICAgICBjb25zb2xlLmxvZygnNC4gRXZlbnRzIGFyZSBub3QgYmVpbmcgZW1pdHRlZCBwcm9wZXJseScpXG4gICAgICAgIFxuICAgICAgICAvLyBUcnkgY2FsbGluZyB0aGUgY29udHJhY3QgcmVhZCBtZXRob2QgdG8gc2VlIGlmIGRhdGEgd2FzIGFjdHVhbGx5IHN0b3JlZFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIHRvIHJlYWQgcGF5bWVudCBsaW5rIHVzaW5nIHRyYW5zYWN0aW9uIGhhc2ggYXMgSUQuLi4nKVxuICAgICAgICAgIGNvbnN0IHRlc3REYXRhID0gYXdhaXQgdGhpcy5jb250cmFjdCEuZ2V0U29sYW5hUGF5bWVudExpbmsodHhIYXNoKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCdDb250cmFjdCByZWFkIHJlc3VsdDonLCB0ZXN0RGF0YSlcbiAgICAgICAgfSBjYXRjaCAocmVhZEVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0NvbnRyYWN0IHJlYWQgZmFpbGVkOicsIHJlYWRFcnJvcilcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSBjb3VsZG4ndCBleHRyYWN0IGZyb20gbG9ncywgaW52ZXN0aWdhdGUgZnVydGhlclxuICAgICAgaWYgKCFsaW5rSWQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQ291bGQgbm90IGV4dHJhY3QgbGluayBJRCBmcm9tIHRyYW5zYWN0aW9uIGV2ZW50cyEnKVxuICAgICAgICBjb25zb2xlLmxvZygnVGhpcyBzdWdnZXN0cyB0aGUgY29udHJhY3QgY2FsbCBtYXkgaGF2ZSBmYWlsZWQgc2lsZW50bHknKVxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHRyYW5zYWN0aW9uIGFjdHVhbGx5IHJldmVydGVkXG4gICAgICAgIGNvbnNvbGUubG9nKCdDaGVja2luZyBmb3IgcmV2ZXJ0IGRhdGEuLi4nKVxuICAgICAgICBpZiAocmVjZWlwdC5yZXN1bHQ/Lm5lb25SZXZlcnREYXRhKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1JldmVydCBkYXRhIGZvdW5kOicsIHJlY2VpcHQucmVzdWx0Lm5lb25SZXZlcnREYXRhKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gZGVjb2RlIHRoZSByZXZlcnQgcmVhc29uXG4gICAgICAgICAgICBjb25zdCByZXZlcnRSZWFzb24gPSBldGhlcnMudG9VdGY4U3RyaW5nKHJlY2VpcHQucmVzdWx0Lm5lb25SZXZlcnREYXRhKVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1JldmVydCByZWFzb246JywgcmV2ZXJ0UmVhc29uKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb250cmFjdCBjYWxsIHJldmVydGVkOiAke3JldmVydFJlYXNvbn1gKVxuICAgICAgICAgIH0gY2F0Y2ggKGRlY29kZUVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQ291bGQgbm90IGRlY29kZSByZXZlcnQgcmVhc29uOicsIGRlY29kZUVycm9yKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250cmFjdCBjYWxsIHJldmVydGVkIHdpdGggdW5rbm93biByZWFzb24nKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gTGV0J3MgdHJ5IHRvIHVuZGVyc3RhbmQgd2h5IHRoZSBldmVudCB3YXNuJ3QgZW1pdHRlZFxuICAgICAgICBjb25zb2xlLmxvZygnQW5hbHl6aW5nIGZ1bmN0aW9uIGNhbGwuLi4nKVxuICAgICAgICBjb25zb2xlLmxvZygnQ29udHJhY3QgYWRkcmVzczonLCBDT05UUkFDVF9BRERSRVNTKVxuICAgICAgICBjb25zb2xlLmxvZygnRnJvbSBhZGRyZXNzOicsIHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0KVxuICAgICAgICBjb25zb2xlLmxvZygnRnVuY3Rpb24gZGF0YSBpbiByYXcgdHg6JywgcmVjZWlwdC5yZXN1bHQ/Lm5lb25SYXdUcmFuc2FjdGlvbilcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHVzZXIgaXMgcmVnaXN0ZXJlZFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGlzUmVnaXN0ZXJlZCA9IGF3YWl0IHRoaXMuY29udHJhY3QhLmlzU29sYW5hVXNlcih0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldClcbiAgICAgICAgICBjb25zb2xlLmxvZygnSXMgdXNlciByZWdpc3RlcmVkIGFzIFNvbGFuYSB1c2VyOicsIGlzUmVnaXN0ZXJlZClcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIWlzUmVnaXN0ZXJlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVc2VyIGlzIG5vdCByZWdpc3RlcmVkIGFzIGEgU29sYW5hIHVzZXIgd2l0aCB0aGUgY29udHJhY3QuIFRoaXMgaXMgcmVxdWlyZWQgdG8gY3JlYXRlIHBheW1lbnQgbGlua3MuJylcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKHJlZ2lzdHJhdGlvbkVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNoZWNrIHVzZXIgcmVnaXN0cmF0aW9uOicsIHJlZ2lzdHJhdGlvbkVycm9yKVxuICAgICAgICAgIHRocm93IHJlZ2lzdHJhdGlvbkVycm9yXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIElmIHdlIGdldCBoZXJlLCBzb21ldGhpbmcgZWxzZSB3ZW50IHdyb25nXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGF5bWVudCBsaW5rIGNyZWF0aW9uIGZhaWxlZDogQ29udHJhY3QgY2FsbCBleGVjdXRlZCBidXQgbm8gZXZlbnQgd2FzIGVtaXR0ZWQuIFRoZSB0cmFuc2FjdGlvbiBtYXkgaGF2ZSBmYWlsZWQgc2lsZW50bHkuJylcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGlua0lkLFxuICAgICAgICB0eEhhc2hcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBwYXltZW50IGxpbms6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHJlYWQtb25seSBjb250cmFjdCBhY2Nlc3MgKHdpdGhvdXQgd2FsbGV0KVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBpbml0UmVhZE9ubHlDb250cmFjdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuY29udHJhY3QpIHtcbiAgICAgIC8vIENyZWF0ZSBhIHNpbXBsZSBKU09OIFJQQyBwcm92aWRlciBmb3IgcmVhZCBvcGVyYXRpb25zXG4gICAgICBjb25zdCByZWFkT25seVByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoTkVPTl9DT1JFX1JQQ19VUkwpXG4gICAgICB0aGlzLmNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChDT05UUkFDVF9BRERSRVNTLCBTT0xBTkFfVElQQ0FSRF9BQkksIHJlYWRPbmx5UHJvdmlkZXIpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBwYXltZW50IGxpbmsgZGV0YWlsc1xuICAgKi9cbiAgYXN5bmMgZ2V0UGF5bWVudExpbmsobGlua0lkOiBzdHJpbmcpOiBQcm9taXNlPFBheW1lbnRMaW5rPiB7XG4gICAgLy8gSW5pdGlhbGl6ZSBjb250cmFjdCBpZiBub3QgYWxyZWFkeSBkb25lXG4gICAgaWYgKCF0aGlzLmNvbnRyYWN0KSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRSZWFkT25seUNvbnRyYWN0KClcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jb250cmFjdCEuZ2V0U29sYW5hUGF5bWVudExpbmsobGlua0lkKVxuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBldm1DcmVhdG9yOiByZXN1bHQuZXZtQ3JlYXRvcixcbiAgICAgICAgc29sYW5hQ3JlYXRvcjogcmVzdWx0LnNvbGFuYUNyZWF0b3IsXG4gICAgICAgIGFtb3VudDogcmVzdWx0LmFtb3VudCxcbiAgICAgICAgaXNGbGV4aWJsZTogcmVzdWx0LmlzRmxleGlibGUsXG4gICAgICAgIGlzQWN0aXZlOiByZXN1bHQuaXNBY3RpdmUsXG4gICAgICAgIHRvdGFsUmVjZWl2ZWQ6IHJlc3VsdC50b3RhbFJlY2VpdmVkLFxuICAgICAgICBwYXltZW50Q291bnQ6IE51bWJlcihyZXN1bHQucGF5bWVudENvdW50KSxcbiAgICAgICAgZGVzY3JpcHRpb246IHJlc3VsdC5kZXNjcmlwdGlvblxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDb250cmFjdCBjYWxsIGVycm9yOicsIGVycm9yKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXltZW50IGxpbmsgbm90IGZvdW5kIG9yIGNvbnRyYWN0IGVycm9yJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHVzZXIncyBwYXltZW50IGxpbmtzXG4gICAqL1xuICBhc3luYyBnZXRVc2VyTGlua3ModXNlckVWTUFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICAvLyBJbml0aWFsaXplIGNvbnRyYWN0IGlmIG5vdCBhbHJlYWR5IGRvbmVcbiAgICBpZiAoIXRoaXMuY29udHJhY3QpIHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdFJlYWRPbmx5Q29udHJhY3QoKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb250cmFjdCEuZ2V0VXNlclNvbGFuYUxpbmtzKHVzZXJFVk1BZGRyZXNzKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHVzZXIgbGlua3M6JywgZXJyb3IpXG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGF5IGEgcGF5bWVudCBsaW5rIHVzaW5nIFNvbGFuYSBOYXRpdmUgU0RLXG4gICAqL1xuICBhc3luYyBwYXlMaW5rKFxuICAgIGxpbmtJZDogc3RyaW5nLFxuICAgIGFtb3VudFNPTDogbnVtYmVyXG4gICk6IFByb21pc2U8eyB0eEhhc2g6IHN0cmluZzsgdHJhbnNmZXJTaWduYXR1cmU/OiBzdHJpbmcgfT4ge1xuICAgIGlmICghdGhpcy5zb2xhbmFVc2VyIHx8ICF0aGlzLmNvbnRyYWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBjb25uZWN0IHdhbGxldCBmaXJzdCcpXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIHBheW1lbnQgcHJvY2Vzcy4uLicpXG4gICAgY29uc29sZS5sb2coJ0xpbmsgSUQ6JywgbGlua0lkKVxuICAgIGNvbnNvbGUubG9nKCdBbW91bnQgU09MOicsIGFtb3VudFNPTClcblxuICAgIC8vIEZpcnN0LCBnZXQgdGhlIHBheW1lbnQgbGluayBkZXRhaWxzIHRvIGZpbmQgdGhlIHJlY2lwaWVudFxuICAgIGNvbnN0IGxpbmtEYXRhID0gYXdhaXQgdGhpcy5nZXRQYXltZW50TGluayhsaW5rSWQpXG4gICAgY29uc29sZS5sb2coJ1BheW1lbnQgbGluayBkYXRhOicsIGxpbmtEYXRhKVxuXG4gICAgaWYgKCFsaW5rRGF0YS5pc0FjdGl2ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXltZW50IGxpbmsgaXMgbm8gbG9uZ2VyIGFjdGl2ZScpXG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBTT0wgdG8gbGFtcG9ydHNcbiAgICBjb25zdCBhbW91bnRMYW1wb3J0cyA9IE1hdGguZmxvb3IoYW1vdW50U09MICogMWU5KVxuICAgIFxuICAgIC8vIENvbnZlcnQgcmVjaXBpZW50IFNvbGFuYSBhZGRyZXNzIGZyb20gYnl0ZXMzMiB0byBQdWJsaWNLZXlcbiAgICBjb25zdCByZWNpcGllbnRCeXRlcyA9IGxpbmtEYXRhLnNvbGFuYUNyZWF0b3Iuc3RhcnRzV2l0aCgnMHgnKSBcbiAgICAgID8gbGlua0RhdGEuc29sYW5hQ3JlYXRvci5zbGljZSgyKSBcbiAgICAgIDogbGlua0RhdGEuc29sYW5hQ3JlYXRvclxuICAgIFxuICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGFuZCBjb252ZXJ0IHRvIFB1YmxpY0tleVxuICAgIGNvbnN0IHJlY2lwaWVudFB1YmtleUJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMzIpXG4gICAgY29uc3QgaGV4Qnl0ZXMgPSByZWNpcGllbnRCeXRlcy5tYXRjaCgvLnsyfS9nKSB8fCBbXVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4oaGV4Qnl0ZXMubGVuZ3RoLCAzMik7IGkrKykge1xuICAgICAgcmVjaXBpZW50UHVia2V5Qnl0ZXNbaV0gPSBwYXJzZUludChoZXhCeXRlc1tpXSwgMTYpXG4gICAgfVxuICAgIFxuICAgIGxldCB0cmFuc2ZlclNpZ25hdHVyZTogc3RyaW5nIHwgdW5kZWZpbmVkXG5cbiAgICB0cnkge1xuICAgICAgLy8gU3RlcCAxOiBQZXJmb3JtIHRoZSBhY3R1YWwgU09MIHRyYW5zZmVyIGZpcnN0XG4gICAgICBjb25zb2xlLmxvZygnU3RlcCAxOiBQZXJmb3JtaW5nIFNPTCB0cmFuc2Zlci4uLicpXG4gICAgICBjb25zb2xlLmxvZygnRnJvbTonLCB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LnRvQmFzZTU4KCkpXG4gICAgICBjb25zb2xlLmxvZygnVG8gcmVjaXBpZW50IGJ5dGVzMzI6JywgbGlua0RhdGEuc29sYW5hQ3JlYXRvcilcbiAgICAgIGNvbnNvbGUubG9nKCdBbW91bnQgbGFtcG9ydHM6JywgYW1vdW50TGFtcG9ydHMpXG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgU09MIHRyYW5zZmVyIHRyYW5zYWN0aW9uXG4gICAgICBjb25zdCB7IFN5c3RlbVByb2dyYW0sIFRyYW5zYWN0aW9uIH0gPSBhd2FpdCBpbXBvcnQoJ0Bzb2xhbmEvd2ViMy5qcycpXG4gICAgICBcbiAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IG5vbi16ZXJvIGJ5dGUgdG8gZGV0ZXJtaW5lIGFjdHVhbCBwdWJsaWMga2V5IGxlbmd0aFxuICAgICAgbGV0IGFjdHVhbEtleVN0YXJ0ID0gMFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWNpcGllbnRQdWJrZXlCeXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVjaXBpZW50UHVia2V5Qnl0ZXNbaV0gIT09IDApIHtcbiAgICAgICAgICBhY3R1YWxLZXlTdGFydCA9IGlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEV4dHJhY3QgdGhlIDMyLWJ5dGUgcHVibGljIGtleSAoc2hvdWxkIGJlIHRoZSBsYXN0IDMyIGJ5dGVzIGlmIHBhZGRlZClcbiAgICAgIGNvbnN0IGFjdHVhbEtleUJ5dGVzID0gcmVjaXBpZW50UHVia2V5Qnl0ZXMuc2xpY2UoYWN0dWFsS2V5U3RhcnQpXG4gICAgICBpZiAoYWN0dWFsS2V5Qnl0ZXMubGVuZ3RoICE9PSAzMikge1xuICAgICAgICAvLyBJZiBub3QgMzIgYnl0ZXMsIHRha2UgdGhlIGxhc3QgMzIgYnl0ZXNcbiAgICAgICAgY29uc3QgcGFkZGVkS2V5ID0gbmV3IFVpbnQ4QXJyYXkoMzIpXG4gICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gTWF0aC5tYXgoMCwgMzIgLSBhY3R1YWxLZXlCeXRlcy5sZW5ndGgpXG4gICAgICAgIHBhZGRlZEtleS5zZXQoYWN0dWFsS2V5Qnl0ZXMsIHN0YXJ0T2Zmc2V0KVxuICAgICAgICByZWNpcGllbnRQdWJrZXlCeXRlcy5zZXQocGFkZGVkS2V5KVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZWNpcGllbnRQdWJrZXkgPSBuZXcgKGF3YWl0IGltcG9ydCgnQHNvbGFuYS93ZWIzLmpzJykpLlB1YmxpY0tleShyZWNpcGllbnRQdWJrZXlCeXRlcylcbiAgICAgIGNvbnNvbGUubG9nKCdSZWNpcGllbnQgUHVibGljS2V5OicsIHJlY2lwaWVudFB1YmtleS50b0Jhc2U1OCgpKVxuXG4gICAgICAvLyBDcmVhdGUgdHJhbnNmZXIgaW5zdHJ1Y3Rpb25cbiAgICAgIGNvbnN0IHRyYW5zZmVySXggPSBTeXN0ZW1Qcm9ncmFtLnRyYW5zZmVyKHtcbiAgICAgICAgZnJvbVB1YmtleTogdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleSxcbiAgICAgICAgdG9QdWJrZXk6IHJlY2lwaWVudFB1YmtleSxcbiAgICAgICAgbGFtcG9ydHM6IGFtb3VudExhbXBvcnRzXG4gICAgICB9KVxuXG4gICAgICAvLyBDcmVhdGUgdHJhbnNhY3Rpb25cbiAgICAgIGNvbnN0IHRyYW5zZmVyVHggPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQodHJhbnNmZXJJeClcbiAgICAgIFxuICAgICAgLy8gR2V0IHJlY2VudCBibG9ja2hhc2hcbiAgICAgIGNvbnN0IHsgYmxvY2toYXNoIH0gPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKClcbiAgICAgIHRyYW5zZmVyVHgucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoXG4gICAgICB0cmFuc2ZlclR4LmZlZVBheWVyID0gdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleVxuXG4gICAgICAvLyBTaWduIGFuZCBzZW5kIHRoZSBTT0wgdHJhbnNmZXJcbiAgICAgIGNvbnN0IHNpZ25lZFRyYW5zZmVyVHggPSBhd2FpdCB0aGlzLnNvbGFuYVVzZXIud2FsbGV0QWRhcHRlci5zaWduVHJhbnNhY3Rpb24odHJhbnNmZXJUeClcbiAgICAgIHRyYW5zZmVyU2lnbmF0dXJlID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihzaWduZWRUcmFuc2ZlclR4LnNlcmlhbGl6ZSgpKVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnU09MIHRyYW5zZmVyIHNlbnQ6JywgdHJhbnNmZXJTaWduYXR1cmUpXG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIHRyYW5zZmVyIGNvbmZpcm1hdGlvblxuICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih0cmFuc2ZlclNpZ25hdHVyZSwgJ2NvbmZpcm1lZCcpXG4gICAgICBjb25zb2xlLmxvZygnU09MIHRyYW5zZmVyIGNvbmZpcm1lZCcpXG5cbiAgICAgIC8vIFN0ZXAgMjogUmVjb3JkIHRoZSBwYXltZW50IGluIHRoZSBjb250cmFjdFxuICAgICAgY29uc29sZS5sb2coJ1N0ZXAgMjogUmVjb3JkaW5nIHBheW1lbnQgaW4gY29udHJhY3QuLi4nKVxuICAgICAgXG4gICAgICAvLyBDb252ZXJ0IFNvbGFuYSBQdWJsaWNLZXkgdG8gYnl0ZXMzMlxuICAgICAgY29uc3QgcGF5ZXJTb2xhbmFCeXRlczMyID0gemVyb1BhZFZhbHVlKGhleGxpZnkodGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleS50b0J5dGVzKCkpLCAzMilcblxuICAgICAgLy8gR2V0IG5vbmNlXG4gICAgICBjb25zdCBub25jZSA9IE51bWJlcihhd2FpdCB0aGlzLnByb3h5QXBpLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQpKVxuXG4gICAgICAvLyBQcmVwYXJlIGNvbnRyYWN0IGNhbGwgZGF0YVxuICAgICAgY29uc3QgaWZhY2UgPSBuZXcgZXRoZXJzLkludGVyZmFjZShTT0xBTkFfVElQQ0FSRF9BQkkpXG4gICAgICBjb25zdCBkYXRhID0gaWZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKCdwYXlTb2xhbmFMaW5rJywgW1xuICAgICAgICBsaW5rSWQsXG4gICAgICAgIGFtb3VudExhbXBvcnRzLFxuICAgICAgICBwYXllclNvbGFuYUJ5dGVzMzJcbiAgICAgIF0pXG5cbiAgICAgIC8vIENyZWF0ZSB0cmFuc2FjdGlvbiBkYXRhXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkRhdGEgPSB7XG4gICAgICAgIGZyb206IHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0LFxuICAgICAgICB0bzogQ09OVFJBQ1RfQUREUkVTUyxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfVxuXG4gICAgICAvLyBFc3RpbWF0ZSBnYXNcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uR2FzID0gYXdhaXQgdGhpcy5wcm94eUFwaS5lc3RpbWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uR2FzKHtcbiAgICAgICAgc29sYW5hUGF5ZXI6IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXksXG4gICAgICAgIHRyYW5zYWN0aW9uczogW3RyYW5zYWN0aW9uRGF0YV0sXG4gICAgICB9KVxuXG4gICAgICAvLyBDcmVhdGUgc2NoZWR1bGVkIHRyYW5zYWN0aW9uXG4gICAgICBjb25zdCB7IHNjaGVkdWxlZFRyYW5zYWN0aW9uIH0gPSBhd2FpdCB0aGlzLnByb3h5QXBpLmNyZWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgdHJhbnNhY3Rpb25HYXMsXG4gICAgICAgIHRyYW5zYWN0aW9uRGF0YSxcbiAgICAgICAgbm9uY2VcbiAgICAgIH0pXG5cbiAgICAgIC8vIEdldCByZWNlbnQgYmxvY2toYXNoXG4gICAgICBjb25zdCBjb250cmFjdEJsb2NraGFzaCA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goKVxuICAgICAgc2NoZWR1bGVkVHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gY29udHJhY3RCbG9ja2hhc2guYmxvY2toYXNoXG4gICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5mZWVQYXllciA9IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXlcblxuICAgICAgLy8gU2lnbiB3aXRoIHdhbGxldCBhZGFwdGVyXG4gICAgICBjb25zdCBzaWduZWRUeCA9IGF3YWl0IHRoaXMuc29sYW5hVXNlci53YWxsZXRBZGFwdGVyLnNpZ25UcmFuc2FjdGlvbihzY2hlZHVsZWRUcmFuc2FjdGlvbilcbiAgICAgIFxuICAgICAgLy8gU2VuZCB0cmFuc2FjdGlvblxuICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihzaWduZWRUeC5zZXJpYWxpemUoKSlcblxuICAgICAgLy8gV2FpdCBmb3IgdHJhbnNhY3Rpb24gZXhlY3V0aW9uIG9uIE5lb24gRVZNXG4gICAgICBjb25zdCB0cmFuc2FjdGlvblN0YXR1cyA9IGF3YWl0IHRoaXMucHJveHlBcGkud2FpdFRyYW5zYWN0aW9uVHJlZUV4ZWN1dGlvbihcbiAgICAgICAgdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsIFxuICAgICAgICBub25jZSwgXG4gICAgICAgIDYwMDAwXG4gICAgICApXG5cbiAgICAgIGlmICh0cmFuc2FjdGlvblN0YXR1cy5sZW5ndGggPT09IDAgfHwgdHJhbnNhY3Rpb25TdGF0dXNbMF0uc3RhdHVzICE9PSAnU3VjY2VzcycpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDb250cmFjdCBwYXltZW50IHJlY29yZGluZyBmYWlsZWQsIGJ1dCBTT0wgdHJhbnNmZXIgc3VjY2VlZGVkJylcbiAgICAgICAgY29uc29sZS5sb2coJ1RyYW5zZmVyIHNpZ25hdHVyZTonLCB0cmFuc2ZlclNpZ25hdHVyZSlcbiAgICAgICAgLy8gRG9uJ3QgdGhyb3cgZXJyb3IgLSB0aGUgcGF5bWVudCB3ZW50IHRocm91Z2ggZXZlbiBpZiByZWNvcmRpbmcgZmFpbGVkXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdQYXltZW50IGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkhJylcbiAgICAgIGNvbnNvbGUubG9nKCdTT0wgdHJhbnNmZXI6JywgdHJhbnNmZXJTaWduYXR1cmUpXG4gICAgICBjb25zb2xlLmxvZygnQ29udHJhY3QgcmVjb3JkOicsIHRyYW5zYWN0aW9uU3RhdHVzWzBdPy50cmFuc2FjdGlvbkhhc2gpXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR4SGFzaDogdHJhbnNhY3Rpb25TdGF0dXNbMF0/LnRyYW5zYWN0aW9uSGFzaCB8fCAnY29udHJhY3QtcmVjb3JkaW5nLWZhaWxlZCcsXG4gICAgICAgIHRyYW5zZmVyU2lnbmF0dXJlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGF5aW5nIGxpbms6JywgZXJyb3IpXG4gICAgICBpZiAodHJhbnNmZXJTaWduYXR1cmUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ05vdGU6IFNPTCB0cmFuc2ZlciBtYXkgaGF2ZSBzdWNjZWVkZWQ6JywgdHJhbnNmZXJTaWduYXR1cmUpXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWFjdGl2YXRlIGEgcGF5bWVudCBsaW5rXG4gICAqL1xuICBhc3luYyBkZWFjdGl2YXRlTGluayhsaW5rSWQ6IHN0cmluZyk6IFByb21pc2U8eyB0eEhhc2g6IHN0cmluZyB9PiB7XG4gICAgaWYgKCF0aGlzLnNvbGFuYVVzZXIgfHwgIXRoaXMuY29udHJhY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIGNvbm5lY3Qgd2FsbGV0IGZpcnN0JylcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gR2V0IG5vbmNlXG4gICAgICBjb25zdCBub25jZSA9IE51bWJlcihhd2FpdCB0aGlzLnByb3h5QXBpLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQpKVxuXG4gICAgICAvLyBQcmVwYXJlIGNvbnRyYWN0IGNhbGwgZGF0YVxuICAgICAgY29uc3QgaWZhY2UgPSBuZXcgZXRoZXJzLkludGVyZmFjZShTT0xBTkFfVElQQ0FSRF9BQkkpXG4gICAgICBjb25zdCBkYXRhID0gaWZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKCdkZWFjdGl2YXRlU29sYW5hTGluaycsIFtsaW5rSWRdKVxuXG4gICAgICAvLyBDcmVhdGUgdHJhbnNhY3Rpb24gZGF0YVxuICAgICAgY29uc3QgdHJhbnNhY3Rpb25EYXRhID0ge1xuICAgICAgICBmcm9tOiB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCxcbiAgICAgICAgdG86IENPTlRSQUNUX0FERFJFU1MsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH1cblxuICAgICAgLy8gRXN0aW1hdGUgZ2FzXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkdhcyA9IGF3YWl0IHRoaXMucHJveHlBcGkuZXN0aW1hdGVTY2hlZHVsZWRUcmFuc2FjdGlvbkdhcyh7XG4gICAgICAgIHNvbGFuYVBheWVyOiB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LFxuICAgICAgICB0cmFuc2FjdGlvbnM6IFt0cmFuc2FjdGlvbkRhdGFdLFxuICAgICAgfSlcblxuICAgICAgLy8gQ3JlYXRlIHNjaGVkdWxlZCB0cmFuc2FjdGlvblxuICAgICAgY29uc3QgeyBzY2hlZHVsZWRUcmFuc2FjdGlvbiB9ID0gYXdhaXQgdGhpcy5wcm94eUFwaS5jcmVhdGVTY2hlZHVsZWRUcmFuc2FjdGlvbih7XG4gICAgICAgIHRyYW5zYWN0aW9uR2FzLFxuICAgICAgICB0cmFuc2FjdGlvbkRhdGEsXG4gICAgICAgIG5vbmNlXG4gICAgICB9KVxuXG4gICAgICAvLyBHZXQgcmVjZW50IGJsb2NraGFzaFxuICAgICAgY29uc3QgeyBibG9ja2hhc2ggfSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goKVxuICAgICAgc2NoZWR1bGVkVHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoXG4gICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5mZWVQYXllciA9IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXlcblxuICAgICAgLy8gU2lnbiB3aXRoIHdhbGxldCBhZGFwdGVyXG4gICAgICBjb25zdCBzaWduZWRUeCA9IGF3YWl0IHRoaXMuc29sYW5hVXNlci53YWxsZXRBZGFwdGVyLnNpZ25UcmFuc2FjdGlvbihzY2hlZHVsZWRUcmFuc2FjdGlvbilcbiAgICAgIFxuICAgICAgLy8gU2VuZCB0cmFuc2FjdGlvblxuICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihzaWduZWRUeC5zZXJpYWxpemUoKSlcblxuICAgICAgLy8gV2FpdCBmb3IgdHJhbnNhY3Rpb24gZXhlY3V0aW9uXG4gICAgICBjb25zdCB0cmFuc2FjdGlvblN0YXR1cyA9IGF3YWl0IHRoaXMucHJveHlBcGkud2FpdFRyYW5zYWN0aW9uVHJlZUV4ZWN1dGlvbihcbiAgICAgICAgdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsIFxuICAgICAgICBub25jZSwgXG4gICAgICAgIDYwMDAwXG4gICAgICApXG5cbiAgICAgIGlmICh0cmFuc2FjdGlvblN0YXR1cy5sZW5ndGggPT09IDAgfHwgdHJhbnNhY3Rpb25TdGF0dXNbMF0uc3RhdHVzICE9PSAnU3VjY2VzcycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWFjdGl2YXRpb24gdHJhbnNhY3Rpb24gZmFpbGVkIHRvIGV4ZWN1dGUgb24gTmVvbiBFVk0nKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eEhhc2g6IHRyYW5zYWN0aW9uU3RhdHVzWzBdLnRyYW5zYWN0aW9uSGFzaFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNoYXJlYWJsZSBVUkwgZm9yIGEgcGF5bWVudCBsaW5rXG4gICAqL1xuICBjcmVhdGVQYXltZW50VVJMKGxpbmtJZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn0/cGF5PSR7bGlua0lkfWBcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IGxpbmsgSUQgZnJvbSBVUkxcbiAgICovXG4gIHN0YXRpYyBleHRyYWN0TGlua0lkRnJvbVVSTCh1cmw6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1cmxPYmogPSBuZXcgVVJMKHVybClcbiAgICAgIHJldHVybiB1cmxPYmouc2VhcmNoUGFyYW1zLmdldCgncGF5JylcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdXNlcidzIEVWTSBhZGRyZXNzIGRlcml2ZWQgZnJvbSBTb2xhbmEgcHVibGljIGtleVxuICAgKi9cbiAgZ2V0VXNlckVWTUFkZHJlc3MoKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuc29sYW5hVXNlcj8ubmVvbldhbGxldCB8fCBudWxsXG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IHNvbGFuYU5hdGl2ZUNvbnRyYWN0ID0gbmV3IFNvbGFuYU5hdGl2ZUNvbnRyYWN0KCkiXSwibmFtZXMiOlsiQ29ubmVjdGlvbiIsIk5lb25Qcm94eVJwY0FwaSIsImNyZWF0ZUJhbGFuY2VBY2NvdW50SW5zdHJ1Y3Rpb24iLCJldGhlcnMiLCJoZXhsaWZ5IiwiemVyb1BhZFZhbHVlIiwiU09MQU5BX1RJUENBUkRfQUJJIiwiQ09OVFJBQ1RfQUREUkVTUyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19USVBDQVJEX0NPTlRSQUNUX0FERFJFU1MiLCJORU9OX0NPUkVfUlBDX1VSTCIsIk5FWFRfUFVCTElDX05FT05fUlBDX1VSTCIsIk5FT05fUFJPWFlfUlBDX1VSTCIsIlNPTEFOQV9SUENfVVJMIiwiU29sYW5hTmF0aXZlQ29udHJhY3QiLCJpbml0V2l0aFNvbGFuYVdhbGxldCIsIndhbGxldEFkYXB0ZXIiLCJwdWJsaWNLZXkiLCJFcnJvciIsImluaXRSZXN1bHQiLCJwcm94eUFwaSIsImluaXQiLCJjaGFpbklkIiwicHJvZ3JhbUFkZHJlc3MiLCJwcm92aWRlciIsInNvbGFuYVVzZXIiLCJjb250cmFjdCIsIkNvbnRyYWN0IiwiY29uc29sZSIsImxvZyIsImNvZGUiLCJnZXRDb2RlIiwibGVuZ3RoIiwid2FybiIsIm5lb25XYWxsZXQiLCJ0b0Jhc2U1OCIsInJlZ2lzdGVyZWRTb2xhbmFBZGRyIiwiZ2V0U29sYW5hVXNlckFkZHJlc3MiLCJpc1VzZXJSZWdpc3RlcmVkIiwiaXNTb2xhbmFVc2VyIiwiYWNjb3VudCIsImNvbm5lY3Rpb24iLCJnZXRBY2NvdW50SW5mbyIsImJhbGFuY2VBZGRyZXNzIiwiYmFsYW5jZUVycm9yIiwidmVyaWZ5RXJyb3IiLCJlcnJvciIsImNyZWF0ZVBheW1lbnRMaW5rIiwic3VnZ2VzdGVkQW1vdW50U09MIiwiaXNGbGV4aWJsZSIsImRlc2NyaXB0aW9uIiwiYW1vdW50TGFtcG9ydHMiLCJNYXRoIiwiZmxvb3IiLCJyZWNlaXB0Iiwibm9uY2UiLCJOdW1iZXIiLCJnZXRUcmFuc2FjdGlvbkNvdW50IiwiaWZhY2UiLCJJbnRlcmZhY2UiLCJkYXRhIiwiZW5jb2RlRnVuY3Rpb25EYXRhIiwidHJhbnNhY3Rpb25EYXRhIiwiZnJvbSIsInRvIiwidHJhbnNhY3Rpb25HYXMiLCJlc3RpbWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uR2FzIiwic29sYW5hUGF5ZXIiLCJ0cmFuc2FjdGlvbnMiLCJzY2hlZHVsZWRUcmFuc2FjdGlvbiIsImNyZWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uIiwiaW5zdHJ1Y3Rpb25zIiwidW5zaGlmdCIsImJsb2NraGFzaCIsImdldExhdGVzdEJsb2NraGFzaCIsInJlY2VudEJsb2NraGFzaCIsImZlZVBheWVyIiwic2lnbmVkVHgiLCJzaWduVHJhbnNhY3Rpb24iLCJzZW5kUmF3VHJhbnNhY3Rpb24iLCJzZXJpYWxpemUiLCJ0cmFuc2FjdGlvblN0YXR1cyIsIndhaXRUcmFuc2FjdGlvblRyZWVFeGVjdXRpb24iLCJzdGF0dXMiLCJ0eEhhc2giLCJ0cmFuc2FjdGlvbkhhc2giLCJnZXRUcmFuc2FjdGlvblJlY2VpcHQiLCJKU09OIiwic3RyaW5naWZ5IiwibGlua0lkIiwicmVzdWx0IiwibG9ncyIsImxvZ3NCbG9vbSIsImNvbnRyYWN0QWRkcmVzcyIsImdhc1VzZWQiLCJlZmZlY3RpdmVHYXNQcmljZSIsIm5lb25SYXdUcmFuc2FjdGlvbiIsInR4RGV0YWlscyIsImdldFRyYW5zYWN0aW9uIiwiZSIsImFsbE5lb25Mb2dzIiwic29sYW5hVHJhbnNhY3Rpb25zIiwic29sVHgiLCJzb2xhbmFJbnN0cnVjdGlvbnMiLCJpbnN0cnVjdGlvbiIsIm5lb25Mb2dzIiwicHVzaCIsImFkZHJlc3MiLCJ0b0xvd2VyQ2FzZSIsImV0aGVyc0xvZyIsInRvcGljcyIsInBhcnNlZExvZyIsInBhcnNlTG9nIiwibmFtZSIsImFyZ3MiLCJ0ZXN0RGF0YSIsImdldFNvbGFuYVBheW1lbnRMaW5rIiwicmVhZEVycm9yIiwibmVvblJldmVydERhdGEiLCJyZXZlcnRSZWFzb24iLCJ0b1V0ZjhTdHJpbmciLCJkZWNvZGVFcnJvciIsImlzUmVnaXN0ZXJlZCIsInJlZ2lzdHJhdGlvbkVycm9yIiwiaW5pdFJlYWRPbmx5Q29udHJhY3QiLCJyZWFkT25seVByb3ZpZGVyIiwiSnNvblJwY1Byb3ZpZGVyIiwiZ2V0UGF5bWVudExpbmsiLCJldm1DcmVhdG9yIiwic29sYW5hQ3JlYXRvciIsImFtb3VudCIsImlzQWN0aXZlIiwidG90YWxSZWNlaXZlZCIsInBheW1lbnRDb3VudCIsImdldFVzZXJMaW5rcyIsInVzZXJFVk1BZGRyZXNzIiwiZ2V0VXNlclNvbGFuYUxpbmtzIiwicGF5TGluayIsImFtb3VudFNPTCIsImxpbmtEYXRhIiwicmVjaXBpZW50Qnl0ZXMiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJyZWNpcGllbnRQdWJrZXlCeXRlcyIsIlVpbnQ4QXJyYXkiLCJoZXhCeXRlcyIsIm1hdGNoIiwiaSIsIm1pbiIsInBhcnNlSW50IiwidHJhbnNmZXJTaWduYXR1cmUiLCJTeXN0ZW1Qcm9ncmFtIiwiVHJhbnNhY3Rpb24iLCJhY3R1YWxLZXlTdGFydCIsImFjdHVhbEtleUJ5dGVzIiwicGFkZGVkS2V5Iiwic3RhcnRPZmZzZXQiLCJtYXgiLCJzZXQiLCJyZWNpcGllbnRQdWJrZXkiLCJQdWJsaWNLZXkiLCJ0cmFuc2Zlckl4IiwidHJhbnNmZXIiLCJmcm9tUHVia2V5IiwidG9QdWJrZXkiLCJsYW1wb3J0cyIsInRyYW5zZmVyVHgiLCJhZGQiLCJzaWduZWRUcmFuc2ZlclR4IiwiY29uZmlybVRyYW5zYWN0aW9uIiwicGF5ZXJTb2xhbmFCeXRlczMyIiwidG9CeXRlcyIsImNvbnRyYWN0QmxvY2toYXNoIiwiZGVhY3RpdmF0ZUxpbmsiLCJjcmVhdGVQYXltZW50VVJMIiwid2luZG93IiwibG9jYXRpb24iLCJvcmlnaW4iLCJleHRyYWN0TGlua0lkRnJvbVVSTCIsInVybCIsInVybE9iaiIsIlVSTCIsInNlYXJjaFBhcmFtcyIsImdldCIsImdldFVzZXJFVk1BZGRyZXNzIiwiY29uc3RydWN0b3IiLCJzb2xhbmFOYXRpdmVDb250cmFjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/solana-native-contract.ts\n"));

/***/ })

});