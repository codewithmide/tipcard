"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/solana-native-contract.ts":
/*!*****************************************!*\
  !*** ./utils/solana-native-contract.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaNativeContract: function() { return /* binding */ SolanaNativeContract; },\n/* harmony export */   solanaNativeContract: function() { return /* binding */ solanaNativeContract; }\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var _neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @neonevm/solana-sign */ \"(app-pages-browser)/./node_modules/@neonevm/solana-sign/dist/esm/index.mjs\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/units.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _contractABI_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contractABI.json */ \"(app-pages-browser)/./utils/contractABI.json\");\n\n\n\n\n// Use the actual deployed contract ABI\nconst SOLANA_TIPCARD_ABI = _contractABI_json__WEBPACK_IMPORTED_MODULE_2__;\nconst CONTRACT_ADDRESS = \"0xCFE03c7c67456D094C0162F9030393FC2cCc40Cb\" || 0;\nconst NEON_CORE_RPC_URL = \"https://devnet.neonevm.org\" || 0;\nconst NEON_PROXY_RPC_URL = \"\".concat(NEON_CORE_RPC_URL, \"/sol\");\nconst SOLANA_RPC_URL = \"https://api.devnet.solana.com\";\nclass SolanaNativeContract {\n    /**\n   * Initialize with Solana wallet using the recommended SolanaNeonAccount approach\n   */ async initWithSolanaWallet(walletAdapter) {\n        if (!walletAdapter.publicKey) {\n            throw new Error(\"Wallet not connected\");\n        }\n        try {\n            var _this_solanaUser_balanceAddress;\n            console.log(\"\\uD83D\\uDD27 Using recommended SolanaNeonAccount approach...\");\n            console.log(\"Wallet public key:\", walletAdapter.publicKey.toBase58());\n            // Use proxyApi.init with just the public key (like demo)\n            const { provider, chainId, solanaUser, tokenMintAddress, programAddress } = await this.proxyApi.init(walletAdapter.publicKey);\n            console.log(\"- Chain ID:\", chainId);\n            console.log(\"- Neon EVM Program:\", programAddress.toBase58());\n            // Store the result with wallet adapter for signing\n            this.chainId = chainId;\n            this.solanaUser = {\n                ...solanaUser,\n                walletAdapter: walletAdapter // Add wallet adapter for signing\n            };\n            // Create balance address if it doesn't exist (using SolanaNeonAccount approach)\n            if (!this.solanaUser.balanceAddress) {\n                const { SolanaNeonAccount } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @neonevm/solana-sign */ \"(app-pages-browser)/./node_modules/@neonevm/solana-sign/dist/esm/index.mjs\"));\n                const account = new SolanaNeonAccount(this.solanaUser.publicKey, this.solanaUser.neonEvmProgram, this.solanaUser.tokenMint, this.solanaUser.chainId);\n                this.solanaUser.balanceAddress = account.balanceAddress;\n            }\n            // Verify they match\n            if (walletAdapter.publicKey.toBase58() === this.solanaUser.publicKey.toBase58()) {\n                console.log(\"✅ Wallet public keys match correctly!\");\n            } else {\n                console.error(\"❌ MISMATCH: Wallet adapter and solana user have different public keys!\");\n                console.error(\"Wallet adapter:\", walletAdapter.publicKey.toBase58());\n                console.error(\"Solana user:\", this.solanaUser.publicKey.toBase58());\n            }\n            console.log(\"\\uD83D\\uDCB0 Final balance address:\", ((_this_solanaUser_balanceAddress = this.solanaUser.balanceAddress) === null || _this_solanaUser_balanceAddress === void 0 ? void 0 : _this_solanaUser_balanceAddress.toBase58()) || \"Still not available\");\n            // Create contract instance\n            const readOnlyProvider = new ethers__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider(NEON_CORE_RPC_URL);\n            this.contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.Contract(CONTRACT_ADDRESS, SOLANA_TIPCARD_ABI, readOnlyProvider);\n            try {\n                // Check if this EVM address has been used before (has transaction history)\n                const txCount = await readOnlyProvider.getTransactionCount(this.solanaUser.neonWallet);\n                console.log(\"\\uD83D\\uDCCA EVM address transaction count:\", txCount);\n                if (txCount > 0) {\n                    console.log(\"✅ This EVM address has transaction history - it exists on-chain!\");\n                } else {\n                    console.log(\"ℹ️ This EVM address is new (no transaction history yet)\");\n                    console.log(\"ℹ️ The address will be registered on-chain when first transaction is made\");\n                }\n            } catch (verifyError) {\n                console.log(\"⚠️ Could not verify EVM address:\", verifyError);\n            }\n            // Verify contract is deployed at this address\n            try {\n                const code = await readOnlyProvider.getCode(CONTRACT_ADDRESS);\n                if (code === \"0x\") {\n                    console.warn(\"⚠️ No contract code found at address:\", CONTRACT_ADDRESS);\n                    console.log(\"This might mean the contract is not deployed or address is incorrect\");\n                } else {\n                    console.log(\"✅ Contract found at address\");\n                    console.log(\"✅ Contract found and ready for transactions\");\n                }\n            } catch (verifyError) {\n                console.warn(\"Failed to verify contract:\", verifyError);\n            }\n        } catch (error) {\n            console.error(\"Failed to initialize Solana Native SDK:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Create a payment link using Solana Native SDK\n   */ async createPaymentLink(suggestedAmountSOL, isFlexible, description) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        // Convert SOL to lamports (1 SOL = 1e9 lamports)\n        const amountLamports = Math.floor(suggestedAmountSOL * 1e9);\n        let signature = \"\";\n        try {\n            // Get current nonce (exactly like working examples)\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Current nonce:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"createSolanaPaymentLink\", [\n                amountLamports,\n                isFlexible,\n                description\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Check if balance account exists, if not create it\n            const account = await this.connection.getAccountInfo(this.solanaUser.balanceAddress);\n            if (account === null) {\n                scheduledTransaction.instructions.unshift((0,_neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__.createBalanceAccountInstruction)(this.solanaUser.neonEvmProgram, this.solanaUser.publicKey, this.solanaUser.neonWallet, this.chainId));\n            }\n            // Sign and send transaction using exact test pattern\n            const { blockhash } = await this.connection.getLatestBlockhash();\n            scheduledTransaction.recentBlockhash = blockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            const signedTransaction = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            console.log(\"Submitting transaction...\");\n            signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n            console.log(\"\\uD83D\\uDD17 Signature:\", signature);\n            // Wait for Solana confirmation first (like the test)\n            console.log(\"Waiting for Solana confirmation...\");\n            await this.connection.confirmTransaction({\n                signature: signature,\n                ...await this.connection.getLatestBlockhash()\n            });\n            console.log(\"✅ Solana transaction confirmed\");\n            // Wait additional time for Neon processing (like the test)\n            console.log(\"Waiting for Neon EVM processing...\");\n            await new Promise((resolve)=>setTimeout(resolve, 3000)); // Wait 3 more seconds like test\n            // Check transaction status\n            try {\n                console.log(\"Getting Neon EVM transaction details...\");\n                const neonTxResponse = await fetch(\"https://devnet.neonevm.org/sol\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        method: \"neon_getTransactionBySenderNonce\",\n                        params: [\n                            this.solanaUser.neonWallet,\n                            nonce\n                        ],\n                        id: 1,\n                        jsonrpc: \"2.0\"\n                    })\n                });\n                const neonTxResult = await neonTxResponse.json();\n                console.log(\"Neon EVM txn result: \", neonTxResult);\n                if (neonTxResult.result && neonTxResult.result.hash) {\n                    const neonTxHash = neonTxResult.result.hash;\n                    console.log(\"✅ Neon EVM payment hash: \".concat(neonTxHash));\n                    // Retry getting the transaction receipt with proper waiting\n                    let actualLinkId = null;\n                    for(let attempt = 1; attempt <= 5; attempt++){\n                        console.log(\"Getting transaction receipt (attempt \".concat(attempt, \"/5)...\"));\n                        try {\n                            const receiptResponse = await fetch(\"https://devnet.neonevm.org/sol\", {\n                                method: \"POST\",\n                                headers: {\n                                    \"Content-Type\": \"application/json\"\n                                },\n                                body: JSON.stringify({\n                                    method: \"eth_getTransactionReceipt\",\n                                    params: [\n                                        neonTxHash\n                                    ],\n                                    id: 1,\n                                    jsonrpc: \"2.0\"\n                                })\n                            });\n                            const receiptResult = await receiptResponse.json();\n                            if (receiptResult.result && receiptResult.result.logs) {\n                                console.log(\"\\uD83D\\uDCCB Transaction receipt found with \".concat(receiptResult.result.logs.length, \" logs\"));\n                                // Look for SolanaLinkCreated event to extract the actual link ID\n                                for (const log of receiptResult.result.logs){\n                                    try {\n                                        const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(SOLANA_TIPCARD_ABI);\n                                        const decoded = iface.parseLog(log);\n                                        if (decoded && decoded.name === \"SolanaLinkCreated\") {\n                                            actualLinkId = decoded.args.linkId;\n                                            console.log(\"\\uD83C\\uDF89 Found SolanaLinkCreated event!\");\n                                            console.log(\"   Actual Link ID: \".concat(actualLinkId));\n                                            console.log(\"   Creator: \".concat(decoded.args.evmCreator));\n                                            console.log(\"   Amount: \".concat(ethers__WEBPACK_IMPORTED_MODULE_6__.formatUnits(decoded.args.amount, 9), \" SOL\"));\n                                            console.log('   Description: \"'.concat(decoded.args.description, '\"'));\n                                            return {\n                                                linkId: actualLinkId,\n                                                txHash: neonTxHash // Keep transaction hash for reference\n                                            };\n                                        }\n                                    } catch (parseError) {\n                                    // Not our event, continue\n                                    }\n                                }\n                                console.log(\"⚠️ SolanaLinkCreated event not found in transaction logs\");\n                                break; // Receipt exists but no event - don't retry\n                            } else {\n                                console.log(\"⚠️ No transaction receipt found yet (attempt \".concat(attempt, \"/5)\"));\n                                if (attempt < 5) {\n                                    console.log(\"Waiting 5 seconds before next attempt...\");\n                                    await new Promise((resolve)=>setTimeout(resolve, 5000));\n                                }\n                            }\n                        } catch (receiptError) {\n                            console.log(\"⚠️ Receipt fetch error (attempt \".concat(attempt, \"/5): \").concat(receiptError.message));\n                            if (attempt < 5) {\n                                await new Promise((resolve)=>setTimeout(resolve, 5000));\n                            }\n                        }\n                    }\n                    // Fallback to transaction hash if we can't find the event\n                    console.log(\"Using transaction hash as fallback link ID\");\n                    return {\n                        linkId: neonTxHash,\n                        txHash: neonTxHash\n                    };\n                } else {\n                    console.log(\"ℹ️ Neon EVM payment transaction not found yet (may still be processing)\");\n                }\n            } catch (neonError) {\n                console.log(\"ℹ️ Could not get Neon payment details: \".concat(neonError.message));\n            }\n        } catch (confirmError) {\n            console.log(\"ℹ️ Payment confirmation check: \".concat(confirmError.message));\n        }\n        console.log(\"\\uD83C\\uDF89 Payment transaction completed!\");\n        // Return signature as fallback\n        return {\n            linkId: signature,\n            txHash: signature\n        };\n    }\n    catch(error) {\n        console.error(\"Error creating payment link:\", error);\n        throw error;\n    }\n    /**\n   * Initialize read-only contract access (without wallet)\n   */ async initReadOnlyContract() {\n        if (!this.contract) {\n            // Create a simple JSON RPC provider for read operations\n            const readOnlyProvider = new ethers__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider(NEON_CORE_RPC_URL);\n            this.contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.Contract(CONTRACT_ADDRESS, SOLANA_TIPCARD_ABI, readOnlyProvider);\n        }\n    }\n    /**\n   * Get payment link details\n   */ async getPaymentLink(linkId) {\n        // Initialize contract if not already done\n        if (!this.contract) {\n            await this.initReadOnlyContract();\n        }\n        console.log(\"Getting payment link with ID:\", linkId);\n        console.log(\"Contract address:\", CONTRACT_ADDRESS);\n        try {\n            const result = await this.contract.getSolanaPaymentLink(linkId);\n            console.log(\"Raw contract result:\", result);\n            const paymentLink = {\n                evmCreator: result.evmCreator,\n                solanaCreator: result.solanaCreator,\n                amount: result.amount,\n                isFlexible: result.isFlexible,\n                isActive: result.isActive,\n                totalReceived: result.totalReceived,\n                paymentCount: Number(result.paymentCount),\n                description: result.description\n            };\n            // Check if this looks like an empty/non-existent link (transaction not processed yet)\n            if (result.evmCreator === \"0x0000000000000000000000000000000000000000\" && result.amount === BigInt(0) && !result.isActive) {\n                console.warn(\"Payment link appears to be empty/non-existent\");\n                // If this looks like a transaction hash (66 chars, starts with 0x), provide helpful info\n                if (linkId.length === 66 && linkId.startsWith(\"0x\")) {\n                    console.log(\"\\uD83D\\uDCA1 This appears to be a transaction hash - the payment link may still be processing\");\n                    console.log(\"\\uD83D\\uDCA1 Neon operators will eventually process this transaction and create the payment link\");\n                    console.log(\"\\uD83D\\uDCA1 You can bookmark this link and try again in a few minutes\");\n                    // For now, don't throw an error - let the UI handle the empty data gracefully\n                    console.log(\"Returning empty payment link data - transaction may still be processing\");\n                }\n            }\n            return paymentLink;\n        } catch (error) {\n            console.error(\"Contract call error:\", error);\n            throw new Error(\"Payment link not found or contract error\");\n        }\n    }\n    /**\n   * Get user's payment links\n   */ async getUserLinks(userEVMAddress) {\n        // Initialize contract if not already done\n        if (!this.contract) {\n            await this.initReadOnlyContract();\n        }\n        try {\n            return await this.contract.getUserSolanaLinks(userEVMAddress);\n        } catch (error) {\n            console.error(\"Error getting user links:\", error);\n            return [];\n        }\n    }\n    /**\n   * Pay a payment link using Solana Native SDK\n   */ async payLink(linkId, amountSOL) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        console.log(\"Starting payment process...\");\n        console.log(\"Link ID:\", linkId);\n        console.log(\"Amount SOL:\", amountSOL);\n        // First, get the payment link details to find the recipient\n        const linkData = await this.getPaymentLink(linkId);\n        console.log(\"Payment link data:\", linkData);\n        if (!linkData.isActive) {\n            throw new Error(\"Payment link is no longer active\");\n        }\n        // Convert SOL to lamports\n        const amountLamports = Math.floor(amountSOL * 1e9);\n        let transferSignature;\n        try {\n            var _hexString_match, _transactionStatus_, _transactionStatus_1;\n            // Step 1: Perform the actual SOL transfer first\n            console.log(\"Step 1: Performing SOL transfer...\");\n            console.log(\"From:\", this.solanaUser.publicKey.toBase58());\n            console.log(\"To recipient bytes32:\", linkData.solanaCreator);\n            console.log(\"Amount lamports:\", amountLamports);\n            // Convert recipient Solana address from bytes32 to PublicKey\n            // Remove '0x' prefix if present\n            const hexString = linkData.solanaCreator.startsWith(\"0x\") ? linkData.solanaCreator.slice(2) : linkData.solanaCreator;\n            // Convert hex string to byte array\n            const bytes = new Uint8Array(((_hexString_match = hexString.match(/.{2}/g)) === null || _hexString_match === void 0 ? void 0 : _hexString_match.map((byte)=>parseInt(byte, 16))) || []);\n            // For bytes32 from Solana addresses, we need to find the actual 32-byte public key\n            // The bytes32 should contain the 32-byte Solana public key, possibly with leading zeros\n            let recipientPubkey;\n            if (bytes.length === 32) {\n                // Direct conversion from 32 bytes\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(bytes);\n            } else if (bytes.length > 32) {\n                // Take the last 32 bytes if it's longer\n                const last32Bytes = bytes.slice(-32);\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(last32Bytes);\n            } else {\n                // Pad with leading zeros if shorter\n                const paddedBytes = new Uint8Array(32);\n                paddedBytes.set(bytes, 32 - bytes.length);\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(paddedBytes);\n            }\n            console.log(\"Recipient PublicKey:\", recipientPubkey.toBase58());\n            // Create the SOL transfer transaction\n            const { SystemProgram, Transaction } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"));\n            // Create transfer instruction\n            const transferIx = SystemProgram.transfer({\n                fromPubkey: this.solanaUser.publicKey,\n                toPubkey: recipientPubkey,\n                lamports: amountLamports\n            });\n            // Create transaction\n            const transferTx = new Transaction().add(transferIx);\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for SOL transfer...\");\n            const { blockhash, lastValidBlockHeight: transferBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh SOL transfer blockhash:\", blockhash);\n            console.log(\"Last valid block height:\", transferBlockHeight);\n            transferTx.recentBlockhash = blockhash;\n            transferTx.feePayer = this.solanaUser.publicKey;\n            // Sign and send the SOL transfer immediately\n            console.log(\"Signing and sending SOL transfer with fresh blockhash...\");\n            const signedTransferTx = await this.solanaUser.walletAdapter.signTransaction(transferTx);\n            transferSignature = await this.connection.sendRawTransaction(signedTransferTx.serialize());\n            console.log(\"SOL transfer sent:\", transferSignature);\n            // Wait for transfer confirmation using the modern API\n            await this.connection.confirmTransaction({\n                signature: transferSignature,\n                ...await this.connection.getLatestBlockhash()\n            });\n            console.log(\"SOL transfer confirmed\");\n            // Step 2: Record the payment in the contract\n            console.log(\"Step 2: Recording payment in contract...\");\n            // Convert Solana PublicKey to bytes32\n            const payerSolanaBytes32 = (0,ethers__WEBPACK_IMPORTED_MODULE_7__.zeroPadValue)((0,ethers__WEBPACK_IMPORTED_MODULE_7__.hexlify)(this.solanaUser.publicKey.toBytes()), 32);\n            // Get current nonce\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Current nonce:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"paySolanaLink\", [\n                linkId,\n                amountLamports,\n                payerSolanaBytes32\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for contract call...\");\n            const { blockhash: contractBlockhash, lastValidBlockHeight: contractBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh contract call blockhash:\", contractBlockhash);\n            console.log(\"Last valid block height:\", contractBlockHeight);\n            scheduledTransaction.recentBlockhash = contractBlockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            // Sign with wallet adapter (frontend approach)\n            console.log(\"Signing contract call with fresh blockhash...\");\n            const signedTx = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            // Send transaction immediately\n            console.log(\"Sending contract call transaction immediately...\");\n            await this.connection.sendRawTransaction(signedTx.serialize());\n            // Wait for transaction execution on Neon EVM\n            const transactionStatus = await this.proxyApi.waitTransactionTreeExecution(this.solanaUser.neonWallet, nonce, 60000);\n            if (transactionStatus.length === 0 || transactionStatus[0].status !== \"Success\") {\n                console.warn(\"Contract payment recording failed, but SOL transfer succeeded\");\n                console.log(\"Transfer signature:\", transferSignature);\n            // Don't throw error - the payment went through even if recording failed\n            }\n            console.log(\"Payment completed successfully!\");\n            console.log(\"SOL transfer:\", transferSignature);\n            console.log(\"Contract record:\", (_transactionStatus_ = transactionStatus[0]) === null || _transactionStatus_ === void 0 ? void 0 : _transactionStatus_.transactionHash);\n            return {\n                txHash: ((_transactionStatus_1 = transactionStatus[0]) === null || _transactionStatus_1 === void 0 ? void 0 : _transactionStatus_1.transactionHash) || \"contract-recording-failed\",\n                transferSignature\n            };\n        } catch (error) {\n            console.error(\"Error paying link:\", error);\n            if (transferSignature) {\n                console.log(\"Note: SOL transfer may have succeeded:\", transferSignature);\n            }\n            throw error;\n        }\n    }\n    /**\n   * Deactivate a payment link\n   */ async deactivateLink(linkId) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        try {\n            // Get current nonce\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Current nonce:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"deactivateSolanaLink\", [\n                linkId\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for deactivate transaction...\");\n            const { blockhash, lastValidBlockHeight: deactivateBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh deactivate blockhash:\", blockhash);\n            console.log(\"Last valid block height:\", deactivateBlockHeight);\n            scheduledTransaction.recentBlockhash = blockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            // Sign with wallet adapter (frontend approach)\n            console.log(\"Signing deactivate transaction with fresh blockhash...\");\n            const signedTx = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            // Send transaction immediately\n            console.log(\"Sending deactivate transaction immediately...\");\n            await this.connection.sendRawTransaction(signedTx.serialize());\n            // Wait for transaction execution\n            const transactionStatus = await this.proxyApi.waitTransactionTreeExecution(this.solanaUser.neonWallet, nonce, 60000);\n            if (transactionStatus.length === 0 || transactionStatus[0].status !== \"Success\") {\n                throw new Error(\"Deactivation transaction failed to execute on Neon EVM\");\n            }\n            return {\n                txHash: transactionStatus[0].transactionHash\n            };\n        } catch (error) {\n            throw error;\n        }\n    }\n    /**\n   * Create a shareable URL for a payment link\n   */ createPaymentURL(linkId) {\n        return \"\".concat(window.location.origin, \"?pay=\").concat(linkId);\n    }\n    /**\n   * Extract link ID from URL\n   */ static extractLinkIdFromURL(url) {\n        try {\n            const urlObj = new URL(url);\n            return urlObj.searchParams.get(\"pay\");\n        } catch (e) {\n            return null;\n        }\n    }\n    /**\n   * Get the user's EVM address derived from Solana public key\n   */ getUserEVMAddress() {\n        var _this_solanaUser;\n        return ((_this_solanaUser = this.solanaUser) === null || _this_solanaUser === void 0 ? void 0 : _this_solanaUser.neonWallet) || null;\n    }\n    constructor(){\n        this.chainId = null;\n        this.contract = null;\n        this.connection = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Connection(SOLANA_RPC_URL, \"confirmed\");\n        this.proxyApi = new _neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__.NeonProxyRpcApi(NEON_PROXY_RPC_URL);\n    }\n}\n// Export singleton instance\nconst solanaNativeContract = new SolanaNativeContract();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3NvbGFuYS1uYXRpdmUtY29udHJhY3QudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFnRTtBQUMwQztBQUNwRDtBQUNWO0FBRTVDLHVDQUF1QztBQUN2QyxNQUFNTyxxQkFBcUJELDhDQUFXQTtBQUV0QyxNQUFNRSxtQkFBbUJDLDRDQUFnRCxJQUFJO0FBQzdFLE1BQU1HLG9CQUFvQkgsNEJBQW9DLElBQUk7QUFDbEUsTUFBTUsscUJBQXFCLEdBQXFCLE9BQWxCRixtQkFBa0I7QUFDaEQsTUFBTUcsaUJBQWlCO0FBYWhCLE1BQU1DO0lBYVg7O0dBRUMsR0FDRCxNQUFNQyxxQkFBcUJDLGFBQWtCLEVBQWlCO1FBQzVELElBQUksQ0FBQ0EsY0FBY0MsU0FBUyxFQUFFO1lBQzVCLE1BQU0sSUFBSUMsTUFBTTtRQUNsQjtRQUVBLElBQUk7Z0JBMkN1QztZQTFDekNDLFFBQVFDLEdBQUcsQ0FBQztZQUNaRCxRQUFRQyxHQUFHLENBQUMsc0JBQXNCSixjQUFjQyxTQUFTLENBQUNJLFFBQVE7WUFFbEUseURBQXlEO1lBQ3pELE1BQU0sRUFDSkMsUUFBUSxFQUNSQyxPQUFPLEVBQ1BDLFVBQVUsRUFDVkMsZ0JBQWdCLEVBQ2hCQyxjQUFjLEVBQ2YsR0FBRyxNQUFNLElBQUksQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNaLGNBQWNDLFNBQVM7WUFFcERFLFFBQVFDLEdBQUcsQ0FBQyxlQUFlRztZQUMzQkosUUFBUUMsR0FBRyxDQUFDLHVCQUF1Qk0sZUFBZUwsUUFBUTtZQUUxRCxtREFBbUQ7WUFDbkQsSUFBSSxDQUFDRSxPQUFPLEdBQUdBO1lBQ2YsSUFBSSxDQUFDQyxVQUFVLEdBQUc7Z0JBQ2hCLEdBQUdBLFVBQVU7Z0JBQ2JSLGVBQWVBLGNBQWMsaUNBQWlDO1lBQ2hFO1lBRUEsZ0ZBQWdGO1lBQ2hGLElBQUksQ0FBQyxJQUFJLENBQUNRLFVBQVUsQ0FBQ0ssY0FBYyxFQUFFO2dCQUNuQyxNQUFNLEVBQUVD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aUIsQ0FBQyxFQUFFLENBQUMrQixNQUFNLEtBQUssV0FBVztnQkFDL0UsTUFBTSxJQUFJeEosTUFBTTtZQUNsQjtZQUVBLE9BQU87Z0JBQ0xnRyxRQUFReUIsaUJBQWlCLENBQUMsRUFBRSxDQUFDZ0MsZUFBZTtZQUM5QztRQUNGLEVBQUUsT0FBT3pJLE9BQVk7WUFDbkIsTUFBTUE7UUFDUjtJQUNGO0lBRUE7O0dBRUMsR0FDRDRJLGlCQUFpQmhFLE1BQWMsRUFBVTtRQUN2QyxPQUFPLEdBQWlDQSxPQUE5QmlFLE9BQU9DLFFBQVEsQ0FBQ0MsTUFBTSxFQUFDLFNBQWMsT0FBUG5FO0lBQzFDO0lBRUE7O0dBRUMsR0FDRCxPQUFPb0UscUJBQXFCQyxHQUFXLEVBQWlCO1FBQ3RELElBQUk7WUFDRixNQUFNQyxTQUFTLElBQUlDLElBQUlGO1lBQ3ZCLE9BQU9DLE9BQU9FLFlBQVksQ0FBQ0MsR0FBRyxDQUFDO1FBQ2pDLEVBQUUsVUFBTTtZQUNOLE9BQU87UUFDVDtJQUNGO0lBRUE7O0dBRUMsR0FDREMsb0JBQW1DO1lBQzFCO1FBQVAsT0FBTyx5QkFBSSxDQUFDaEssVUFBVSxjQUFmLHdEQUFpQmlCLFVBQVUsS0FBSTtJQUN4QztJQXRwQkFnSixhQUFjO2FBSE5sSyxVQUF5QjthQUN6QmMsV0FBbUM7UUFHekMsSUFBSSxDQUFDZ0MsVUFBVSxHQUFHLElBQUl2RSx1REFBVUEsQ0FBQ2UsZ0JBQWdCO1FBQ2pELElBQUksQ0FBQ2MsUUFBUSxHQUFHLElBQUk1QixpRUFBZUEsQ0FBQ2E7SUFDdEM7QUFvcEJGO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU04Syx1QkFBdUIsSUFBSTVLLHVCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy9zb2xhbmEtbmF0aXZlLWNvbnRyYWN0LnRzP2Q0YzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29ubmVjdGlvbiwgUHVibGljS2V5LCBLZXlwYWlyIH0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJ1xuaW1wb3J0IHsgTmVvblByb3h5UnBjQXBpLCBjcmVhdGVCYWxhbmNlQWNjb3VudEluc3RydWN0aW9uLCBTb2xhbmFOZW9uQWNjb3VudCB9IGZyb20gJ0BuZW9uZXZtL3NvbGFuYS1zaWduJ1xuaW1wb3J0IHsgZXRoZXJzLCBoZXhsaWZ5LCB6ZXJvUGFkVmFsdWUgfSBmcm9tICdldGhlcnMnXG5pbXBvcnQgQ29udHJhY3RBQkkgZnJvbSAnLi9jb250cmFjdEFCSS5qc29uJ1xuXG4vLyBVc2UgdGhlIGFjdHVhbCBkZXBsb3llZCBjb250cmFjdCBBQklcbmNvbnN0IFNPTEFOQV9USVBDQVJEX0FCSSA9IENvbnRyYWN0QUJJXG5cbmNvbnN0IENPTlRSQUNUX0FERFJFU1MgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19USVBDQVJEX0NPTlRSQUNUX0FERFJFU1MgfHwgJzB4Q0ZFMDNjN2M2NzQ1NkQwOTRDMDE2MkY5MDMwMzkzRkMyY0NjNDBDYidcbmNvbnN0IE5FT05fQ09SRV9SUENfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfTkVPTl9SUENfVVJMIHx8ICdodHRwczovL2Rldm5ldC5uZW9uZXZtLm9yZydcbmNvbnN0IE5FT05fUFJPWFlfUlBDX1VSTCA9IGAke05FT05fQ09SRV9SUENfVVJMfS9zb2xgXG5jb25zdCBTT0xBTkFfUlBDX1VSTCA9ICdodHRwczovL2FwaS5kZXZuZXQuc29sYW5hLmNvbSdcblxuZXhwb3J0IGludGVyZmFjZSBQYXltZW50TGluayB7XG4gIGV2bUNyZWF0b3I6IHN0cmluZ1xuICBzb2xhbmFDcmVhdG9yOiBzdHJpbmdcbiAgYW1vdW50OiBiaWdpbnRcbiAgaXNGbGV4aWJsZTogYm9vbGVhblxuICBpc0FjdGl2ZTogYm9vbGVhblxuICB0b3RhbFJlY2VpdmVkOiBiaWdpbnRcbiAgcGF5bWVudENvdW50OiBudW1iZXJcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xufVxuXG5leHBvcnQgY2xhc3MgU29sYW5hTmF0aXZlQ29udHJhY3Qge1xuICBwcml2YXRlIGNvbm5lY3Rpb246IENvbm5lY3Rpb25cbiAgcHJpdmF0ZSBwcm94eUFwaTogTmVvblByb3h5UnBjQXBpXG4gIHByaXZhdGUgc29sYW5hVXNlcjogYW55XG4gIHByaXZhdGUgY2hhaW5JZDogbnVtYmVyIHwgbnVsbCA9IG51bGxcbiAgcHJpdmF0ZSBjb250cmFjdDogZXRoZXJzLkNvbnRyYWN0IHwgbnVsbCA9IG51bGxcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdGlvbihTT0xBTkFfUlBDX1VSTCwgJ2NvbmZpcm1lZCcpXG4gICAgdGhpcy5wcm94eUFwaSA9IG5ldyBOZW9uUHJveHlScGNBcGkoTkVPTl9QUk9YWV9SUENfVVJMKVxuICB9XG5cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB3aXRoIFNvbGFuYSB3YWxsZXQgdXNpbmcgdGhlIHJlY29tbWVuZGVkIFNvbGFuYU5lb25BY2NvdW50IGFwcHJvYWNoXG4gICAqL1xuICBhc3luYyBpbml0V2l0aFNvbGFuYVdhbGxldCh3YWxsZXRBZGFwdGVyOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXdhbGxldEFkYXB0ZXIucHVibGljS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBub3QgY29ubmVjdGVkJylcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/CflKcgVXNpbmcgcmVjb21tZW5kZWQgU29sYW5hTmVvbkFjY291bnQgYXBwcm9hY2guLi4nKVxuICAgICAgY29uc29sZS5sb2coJ1dhbGxldCBwdWJsaWMga2V5OicsIHdhbGxldEFkYXB0ZXIucHVibGljS2V5LnRvQmFzZTU4KCkpXG5cbiAgICAgIC8vIFVzZSBwcm94eUFwaS5pbml0IHdpdGgganVzdCB0aGUgcHVibGljIGtleSAobGlrZSBkZW1vKVxuICAgICAgY29uc3Qge1xuICAgICAgICBwcm92aWRlcixcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgc29sYW5hVXNlcixcbiAgICAgICAgdG9rZW5NaW50QWRkcmVzcyxcbiAgICAgICAgcHJvZ3JhbUFkZHJlc3NcbiAgICAgIH0gPSBhd2FpdCB0aGlzLnByb3h5QXBpLmluaXQod2FsbGV0QWRhcHRlci5wdWJsaWNLZXkpXG5cbiAgICAgIGNvbnNvbGUubG9nKCctIENoYWluIElEOicsIGNoYWluSWQpXG4gICAgICBjb25zb2xlLmxvZygnLSBOZW9uIEVWTSBQcm9ncmFtOicsIHByb2dyYW1BZGRyZXNzLnRvQmFzZTU4KCkpXG5cbiAgICAgIC8vIFN0b3JlIHRoZSByZXN1bHQgd2l0aCB3YWxsZXQgYWRhcHRlciBmb3Igc2lnbmluZ1xuICAgICAgdGhpcy5jaGFpbklkID0gY2hhaW5JZFxuICAgICAgdGhpcy5zb2xhbmFVc2VyID0ge1xuICAgICAgICAuLi5zb2xhbmFVc2VyLFxuICAgICAgICB3YWxsZXRBZGFwdGVyOiB3YWxsZXRBZGFwdGVyIC8vIEFkZCB3YWxsZXQgYWRhcHRlciBmb3Igc2lnbmluZ1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYmFsYW5jZSBhZGRyZXNzIGlmIGl0IGRvZXNuJ3QgZXhpc3QgKHVzaW5nIFNvbGFuYU5lb25BY2NvdW50IGFwcHJvYWNoKVxuICAgICAgaWYgKCF0aGlzLnNvbGFuYVVzZXIuYmFsYW5jZUFkZHJlc3MpIHtcbiAgICAgICAgY29uc3QgeyBTb2xhbmFOZW9uQWNjb3VudCB9ID0gYXdhaXQgaW1wb3J0KCdAbmVvbmV2bS9zb2xhbmEtc2lnbicpXG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBuZXcgU29sYW5hTmVvbkFjY291bnQoXG4gICAgICAgICAgdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleSxcbiAgICAgICAgICB0aGlzLnNvbGFuYVVzZXIubmVvbkV2bVByb2dyYW0sXG4gICAgICAgICAgdGhpcy5zb2xhbmFVc2VyLnRva2VuTWludCxcbiAgICAgICAgICB0aGlzLnNvbGFuYVVzZXIuY2hhaW5JZFxuICAgICAgICApXG4gICAgICAgIHRoaXMuc29sYW5hVXNlci5iYWxhbmNlQWRkcmVzcyA9IGFjY291bnQuYmFsYW5jZUFkZHJlc3NcbiAgICAgIH1cblxuICAgICAgLy8gVmVyaWZ5IHRoZXkgbWF0Y2hcbiAgICAgIGlmICh3YWxsZXRBZGFwdGVyLnB1YmxpY0tleS50b0Jhc2U1OCgpID09PSB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LnRvQmFzZTU4KCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBXYWxsZXQgcHVibGljIGtleXMgbWF0Y2ggY29ycmVjdGx5IScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgTUlTTUFUQ0g6IFdhbGxldCBhZGFwdGVyIGFuZCBzb2xhbmEgdXNlciBoYXZlIGRpZmZlcmVudCBwdWJsaWMga2V5cyEnKVxuICAgICAgICBjb25zb2xlLmVycm9yKCdXYWxsZXQgYWRhcHRlcjonLCB3YWxsZXRBZGFwdGVyLnB1YmxpY0tleS50b0Jhc2U1OCgpKVxuICAgICAgICBjb25zb2xlLmVycm9yKCdTb2xhbmEgdXNlcjonLCB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LnRvQmFzZTU4KCkpXG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZygn8J+SsCBGaW5hbCBiYWxhbmNlIGFkZHJlc3M6JywgdGhpcy5zb2xhbmFVc2VyLmJhbGFuY2VBZGRyZXNzPy50b0Jhc2U1OCgpIHx8ICdTdGlsbCBub3QgYXZhaWxhYmxlJylcblxuICAgICAgLy8gQ3JlYXRlIGNvbnRyYWN0IGluc3RhbmNlXG4gICAgICBjb25zdCByZWFkT25seVByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoTkVPTl9DT1JFX1JQQ19VUkwpXG4gICAgICB0aGlzLmNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChDT05UUkFDVF9BRERSRVNTLCBTT0xBTkFfVElQQ0FSRF9BQkksIHJlYWRPbmx5UHJvdmlkZXIpXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgRVZNIGFkZHJlc3MgaGFzIGJlZW4gdXNlZCBiZWZvcmUgKGhhcyB0cmFuc2FjdGlvbiBoaXN0b3J5KVxuICAgICAgICBjb25zdCB0eENvdW50ID0gYXdhaXQgcmVhZE9ubHlQcm92aWRlci5nZXRUcmFuc2FjdGlvbkNvdW50KHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0KVxuICAgICAgICBjb25zb2xlLmxvZygn8J+TiiBFVk0gYWRkcmVzcyB0cmFuc2FjdGlvbiBjb3VudDonLCB0eENvdW50KVxuXG4gICAgICAgIGlmICh0eENvdW50ID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgVGhpcyBFVk0gYWRkcmVzcyBoYXMgdHJhbnNhY3Rpb24gaGlzdG9yeSAtIGl0IGV4aXN0cyBvbi1jaGFpbiEnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfihLnvuI8gVGhpcyBFVk0gYWRkcmVzcyBpcyBuZXcgKG5vIHRyYW5zYWN0aW9uIGhpc3RvcnkgeWV0KScpXG4gICAgICAgICAgY29uc29sZS5sb2coJ+KEue+4jyBUaGUgYWRkcmVzcyB3aWxsIGJlIHJlZ2lzdGVyZWQgb24tY2hhaW4gd2hlbiBmaXJzdCB0cmFuc2FjdGlvbiBpcyBtYWRlJylcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAodmVyaWZ5RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KaoO+4jyBDb3VsZCBub3QgdmVyaWZ5IEVWTSBhZGRyZXNzOicsIHZlcmlmeUVycm9yKVxuICAgICAgfVxuXG4gICAgICAvLyBWZXJpZnkgY29udHJhY3QgaXMgZGVwbG95ZWQgYXQgdGhpcyBhZGRyZXNzXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgcmVhZE9ubHlQcm92aWRlci5nZXRDb2RlKENPTlRSQUNUX0FERFJFU1MpXG4gICAgICAgIGlmIChjb2RlID09PSAnMHgnKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gTm8gY29udHJhY3QgY29kZSBmb3VuZCBhdCBhZGRyZXNzOicsIENPTlRSQUNUX0FERFJFU1MpXG4gICAgICAgICAgY29uc29sZS5sb2coJ1RoaXMgbWlnaHQgbWVhbiB0aGUgY29udHJhY3QgaXMgbm90IGRlcGxveWVkIG9yIGFkZHJlc3MgaXMgaW5jb3JyZWN0JylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIENvbnRyYWN0IGZvdW5kIGF0IGFkZHJlc3MnKVxuXG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBDb250cmFjdCBmb3VuZCBhbmQgcmVhZHkgZm9yIHRyYW5zYWN0aW9ucycpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHZlcmlmeUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHZlcmlmeSBjb250cmFjdDonLCB2ZXJpZnlFcnJvcilcbiAgICAgIH1cblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBTb2xhbmEgTmF0aXZlIFNESzonLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHBheW1lbnQgbGluayB1c2luZyBTb2xhbmEgTmF0aXZlIFNES1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlUGF5bWVudExpbmsoXG4gICAgc3VnZ2VzdGVkQW1vdW50U09MOiBudW1iZXIsXG4gICAgaXNGbGV4aWJsZTogYm9vbGVhbixcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gICk6IFByb21pc2U8eyBsaW5rSWQ6IHN0cmluZzsgdHhIYXNoOiBzdHJpbmcgfT4ge1xuICAgIGlmICghdGhpcy5zb2xhbmFVc2VyIHx8ICF0aGlzLmNvbnRyYWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBjb25uZWN0IHdhbGxldCBmaXJzdCcpXG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBTT0wgdG8gbGFtcG9ydHMgKDEgU09MID0gMWU5IGxhbXBvcnRzKVxuICAgIGNvbnN0IGFtb3VudExhbXBvcnRzID0gTWF0aC5mbG9vcihzdWdnZXN0ZWRBbW91bnRTT0wgKiAxZTkpXG4gICAgbGV0IHNpZ25hdHVyZTogc3RyaW5nID0gJydcblxuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgY3VycmVudCBub25jZSAoZXhhY3RseSBsaWtlIHdvcmtpbmcgZXhhbXBsZXMpXG4gICAgICBjb25zdCBub25jZSA9IE51bWJlcihhd2FpdCB0aGlzLnByb3h5QXBpLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQpKVxuICAgICAgY29uc29sZS5sb2coJ0N1cnJlbnQgbm9uY2U6Jywgbm9uY2UpXG5cbiAgICAgIC8vIFByZXBhcmUgY29udHJhY3QgY2FsbCBkYXRhXG4gICAgICBjb25zdCBpZmFjZSA9IG5ldyBldGhlcnMuSW50ZXJmYWNlKFNPTEFOQV9USVBDQVJEX0FCSSlcbiAgICAgIGNvbnN0IGRhdGEgPSBpZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoJ2NyZWF0ZVNvbGFuYVBheW1lbnRMaW5rJywgW1xuICAgICAgICBhbW91bnRMYW1wb3J0cyxcbiAgICAgICAgaXNGbGV4aWJsZSxcbiAgICAgICAgZGVzY3JpcHRpb25cbiAgICAgIF0pXG5cbiAgICAgIC8vIENyZWF0ZSB0cmFuc2FjdGlvbiBkYXRhXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkRhdGEgPSB7XG4gICAgICAgIGZyb206IHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0LFxuICAgICAgICB0bzogQ09OVFJBQ1RfQUREUkVTUyxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfVxuXG4gICAgICAvLyBFc3RpbWF0ZSBnYXNcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uR2FzID0gYXdhaXQgdGhpcy5wcm94eUFwaS5lc3RpbWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uR2FzKHtcbiAgICAgICAgc29sYW5hUGF5ZXI6IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXksXG4gICAgICAgIHRyYW5zYWN0aW9uczogW3RyYW5zYWN0aW9uRGF0YV0sXG4gICAgICB9KVxuXG4gICAgICAvLyBDcmVhdGUgc2NoZWR1bGVkIHRyYW5zYWN0aW9uXG4gICAgICBsZXQgeyBzY2hlZHVsZWRUcmFuc2FjdGlvbiB9ID0gYXdhaXQgdGhpcy5wcm94eUFwaS5jcmVhdGVTY2hlZHVsZWRUcmFuc2FjdGlvbih7XG4gICAgICAgIHRyYW5zYWN0aW9uR2FzLFxuICAgICAgICB0cmFuc2FjdGlvbkRhdGEsXG4gICAgICAgIG5vbmNlXG4gICAgICB9KVxuXG4gICAgICAvLyBDaGVjayBpZiBiYWxhbmNlIGFjY291bnQgZXhpc3RzLCBpZiBub3QgY3JlYXRlIGl0XG4gICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldEFjY291bnRJbmZvKHRoaXMuc29sYW5hVXNlci5iYWxhbmNlQWRkcmVzcylcbiAgICAgIGlmIChhY2NvdW50ID09PSBudWxsKSB7XG4gICAgICAgIHNjaGVkdWxlZFRyYW5zYWN0aW9uLmluc3RydWN0aW9ucy51bnNoaWZ0KFxuICAgICAgICAgIGNyZWF0ZUJhbGFuY2VBY2NvdW50SW5zdHJ1Y3Rpb24oXG4gICAgICAgICAgICB0aGlzLnNvbGFuYVVzZXIubmVvbkV2bVByb2dyYW0sXG4gICAgICAgICAgICB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LFxuICAgICAgICAgICAgdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsXG4gICAgICAgICAgICB0aGlzLmNoYWluSWQhXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIFNpZ24gYW5kIHNlbmQgdHJhbnNhY3Rpb24gdXNpbmcgZXhhY3QgdGVzdCBwYXR0ZXJuXG4gICAgICBjb25zdCB7IGJsb2NraGFzaCB9ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgpXG4gICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBibG9ja2hhc2hcbiAgICAgIHNjaGVkdWxlZFRyYW5zYWN0aW9uLmZlZVBheWVyID0gdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleVxuXG4gICAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMuc29sYW5hVXNlci53YWxsZXRBZGFwdGVyLnNpZ25UcmFuc2FjdGlvbihzY2hlZHVsZWRUcmFuc2FjdGlvbilcblxuICAgICAgY29uc29sZS5sb2coJ1N1Ym1pdHRpbmcgdHJhbnNhY3Rpb24uLi4nKVxuICAgICAgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbi5zZXJpYWxpemUoKSlcblxuICAgICAgY29uc29sZS5sb2coJ/CflJcgU2lnbmF0dXJlOicsIHNpZ25hdHVyZSlcblxuICAgICAgLy8gV2FpdCBmb3IgU29sYW5hIGNvbmZpcm1hdGlvbiBmaXJzdCAobGlrZSB0aGUgdGVzdClcbiAgICAgIGNvbnNvbGUubG9nKGBXYWl0aW5nIGZvciBTb2xhbmEgY29uZmlybWF0aW9uLi4uYCk7XG4gICAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHtcbiAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUsXG4gICAgICAgIC4uLihhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCkpXG4gICAgICB9KTtcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgU29sYW5hIHRyYW5zYWN0aW9uIGNvbmZpcm1lZGApO1xuXG4gICAgICAvLyBXYWl0IGFkZGl0aW9uYWwgdGltZSBmb3IgTmVvbiBwcm9jZXNzaW5nIChsaWtlIHRoZSB0ZXN0KVxuICAgICAgY29uc29sZS5sb2coYFdhaXRpbmcgZm9yIE5lb24gRVZNIHByb2Nlc3NpbmcuLi5gKTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDAwKSk7IC8vIFdhaXQgMyBtb3JlIHNlY29uZHMgbGlrZSB0ZXN0XG5cbiAgICAgIC8vIENoZWNrIHRyYW5zYWN0aW9uIHN0YXR1c1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coYEdldHRpbmcgTmVvbiBFVk0gdHJhbnNhY3Rpb24gZGV0YWlscy4uLmApO1xuXG4gICAgICAgIGNvbnN0IG5lb25UeFJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vZGV2bmV0Lm5lb25ldm0ub3JnL3NvbCcsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBtZXRob2Q6IFwibmVvbl9nZXRUcmFuc2FjdGlvbkJ5U2VuZGVyTm9uY2VcIixcbiAgICAgICAgICAgIHBhcmFtczogW3RoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0LCBub25jZV0sXG4gICAgICAgICAgICBpZDogMSxcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBuZW9uVHhSZXN1bHQgPSBhd2FpdCBuZW9uVHhSZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiTmVvbiBFVk0gdHhuIHJlc3VsdDogXCIsIG5lb25UeFJlc3VsdCk7XG5cbiAgICAgICAgaWYgKG5lb25UeFJlc3VsdC5yZXN1bHQgJiYgbmVvblR4UmVzdWx0LnJlc3VsdC5oYXNoKSB7XG4gICAgICAgICAgY29uc3QgbmVvblR4SGFzaCA9IG5lb25UeFJlc3VsdC5yZXN1bHQuaGFzaDtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIE5lb24gRVZNIHBheW1lbnQgaGFzaDogJHtuZW9uVHhIYXNofWApO1xuXG4gICAgICAgICAgLy8gUmV0cnkgZ2V0dGluZyB0aGUgdHJhbnNhY3Rpb24gcmVjZWlwdCB3aXRoIHByb3BlciB3YWl0aW5nXG4gICAgICAgICAgbGV0IGFjdHVhbExpbmtJZDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgXG4gICAgICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDE7IGF0dGVtcHQgPD0gNTsgYXR0ZW1wdCsrKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgR2V0dGluZyB0cmFuc2FjdGlvbiByZWNlaXB0IChhdHRlbXB0ICR7YXR0ZW1wdH0vNSkuLi5gKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVjZWlwdFJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vZGV2bmV0Lm5lb25ldm0ub3JnL3NvbCcsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdFwiLFxuICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbbmVvblR4SGFzaF0sXG4gICAgICAgICAgICAgICAgICBpZDogMSxcbiAgICAgICAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGNvbnN0IHJlY2VpcHRSZXN1bHQgPSBhd2FpdCByZWNlaXB0UmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKHJlY2VpcHRSZXN1bHQucmVzdWx0ICYmIHJlY2VpcHRSZXN1bHQucmVzdWx0LmxvZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TiyBUcmFuc2FjdGlvbiByZWNlaXB0IGZvdW5kIHdpdGggJHtyZWNlaXB0UmVzdWx0LnJlc3VsdC5sb2dzLmxlbmd0aH0gbG9nc2ApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIExvb2sgZm9yIFNvbGFuYUxpbmtDcmVhdGVkIGV2ZW50IHRvIGV4dHJhY3QgdGhlIGFjdHVhbCBsaW5rIElEXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBsb2cgb2YgcmVjZWlwdFJlc3VsdC5yZXN1bHQubG9ncykge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWZhY2UgPSBuZXcgZXRoZXJzLkludGVyZmFjZShTT0xBTkFfVElQQ0FSRF9BQkkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNvZGVkID0gaWZhY2UucGFyc2VMb2cobG9nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlY29kZWQgJiYgZGVjb2RlZC5uYW1lID09PSAnU29sYW5hTGlua0NyZWF0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWN0dWFsTGlua0lkID0gZGVjb2RlZC5hcmdzLmxpbmtJZDtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+OiSBGb3VuZCBTb2xhbmFMaW5rQ3JlYXRlZCBldmVudCFgKTtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgQWN0dWFsIExpbmsgSUQ6ICR7YWN0dWFsTGlua0lkfWApO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBDcmVhdG9yOiAke2RlY29kZWQuYXJncy5ldm1DcmVhdG9yfWApO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBBbW91bnQ6ICR7ZXRoZXJzLmZvcm1hdFVuaXRzKGRlY29kZWQuYXJncy5hbW91bnQsIDkpfSBTT0xgKTtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgRGVzY3JpcHRpb246IFwiJHtkZWNvZGVkLmFyZ3MuZGVzY3JpcHRpb259XCJgKTtcbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlua0lkOiBhY3R1YWxMaW5rSWQsICAvLyBSZXR1cm4gdGhlIGFjdHVhbCBsaW5rIElEIGZyb20gdGhlIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB0eEhhc2g6IG5lb25UeEhhc2ggICAgLy8gS2VlcCB0cmFuc2FjdGlvbiBoYXNoIGZvciByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBvdXIgZXZlbnQsIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDimqDvuI8gU29sYW5hTGlua0NyZWF0ZWQgZXZlbnQgbm90IGZvdW5kIGluIHRyYW5zYWN0aW9uIGxvZ3NgKTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gUmVjZWlwdCBleGlzdHMgYnV0IG5vIGV2ZW50IC0gZG9uJ3QgcmV0cnlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg4pqg77iPIE5vIHRyYW5zYWN0aW9uIHJlY2VpcHQgZm91bmQgeWV0IChhdHRlbXB0ICR7YXR0ZW1wdH0vNSlgKTtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdCA8IDUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBXYWl0aW5nIDUgc2Vjb25kcyBiZWZvcmUgbmV4dCBhdHRlbXB0Li4uYCk7XG4gICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwMCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAocmVjZWlwdEVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBSZWNlaXB0IGZldGNoIGVycm9yIChhdHRlbXB0ICR7YXR0ZW1wdH0vNSk6ICR7cmVjZWlwdEVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgIGlmIChhdHRlbXB0IDwgNSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDAwKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBGYWxsYmFjayB0byB0cmFuc2FjdGlvbiBoYXNoIGlmIHdlIGNhbid0IGZpbmQgdGhlIGV2ZW50XG4gICAgICAgICAgY29uc29sZS5sb2coYFVzaW5nIHRyYW5zYWN0aW9uIGhhc2ggYXMgZmFsbGJhY2sgbGluayBJRGApO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5rSWQ6IG5lb25UeEhhc2gsXG4gICAgICAgICAgICB0eEhhc2g6IG5lb25UeEhhc2hcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDihLnvuI8gTmVvbiBFVk0gcGF5bWVudCB0cmFuc2FjdGlvbiBub3QgZm91bmQgeWV0IChtYXkgc3RpbGwgYmUgcHJvY2Vzc2luZylgKTtcbiAgICAgICAgfVxuXG4gICAgICB9IGNhdGNoIChuZW9uRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coYOKEue+4jyBDb3VsZCBub3QgZ2V0IE5lb24gcGF5bWVudCBkZXRhaWxzOiAkeyhuZW9uRXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2V9YCk7XG4gICAgICB9XG5cbiAgICB9IGNhdGNoIChjb25maXJtRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKGDihLnvuI8gUGF5bWVudCBjb25maXJtYXRpb24gY2hlY2s6ICR7KGNvbmZpcm1FcnJvciBhcyBFcnJvcikubWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhg8J+OiSBQYXltZW50IHRyYW5zYWN0aW9uIGNvbXBsZXRlZCFgKTtcblxuICAgIC8vIFJldHVybiBzaWduYXR1cmUgYXMgZmFsbGJhY2tcbiAgICByZXR1cm4ge1xuICAgICAgbGlua0lkOiBzaWduYXR1cmUsXG4gICAgICB0eEhhc2g6IHNpZ25hdHVyZVxuICAgIH07XG4gIH0gY2F0Y2goZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHBheW1lbnQgbGluazonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHJlYWQtb25seSBjb250cmFjdCBhY2Nlc3MgKHdpdGhvdXQgd2FsbGV0KVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBpbml0UmVhZE9ubHlDb250cmFjdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuY29udHJhY3QpIHtcbiAgICAgIC8vIENyZWF0ZSBhIHNpbXBsZSBKU09OIFJQQyBwcm92aWRlciBmb3IgcmVhZCBvcGVyYXRpb25zXG4gICAgICBjb25zdCByZWFkT25seVByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoTkVPTl9DT1JFX1JQQ19VUkwpXG4gICAgICB0aGlzLmNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChDT05UUkFDVF9BRERSRVNTLCBTT0xBTkFfVElQQ0FSRF9BQkksIHJlYWRPbmx5UHJvdmlkZXIpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBwYXltZW50IGxpbmsgZGV0YWlsc1xuICAgKi9cbiAgYXN5bmMgZ2V0UGF5bWVudExpbmsobGlua0lkOiBzdHJpbmcpOiBQcm9taXNlPFBheW1lbnRMaW5rPiB7XG4gICAgLy8gSW5pdGlhbGl6ZSBjb250cmFjdCBpZiBub3QgYWxyZWFkeSBkb25lXG4gICAgaWYgKCF0aGlzLmNvbnRyYWN0KSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRSZWFkT25seUNvbnRyYWN0KClcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnR2V0dGluZyBwYXltZW50IGxpbmsgd2l0aCBJRDonLCBsaW5rSWQpXG4gICAgY29uc29sZS5sb2coJ0NvbnRyYWN0IGFkZHJlc3M6JywgQ09OVFJBQ1RfQUREUkVTUylcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0IS5nZXRTb2xhbmFQYXltZW50TGluayhsaW5rSWQpXG4gICAgICBjb25zb2xlLmxvZygnUmF3IGNvbnRyYWN0IHJlc3VsdDonLCByZXN1bHQpXG5cbiAgICAgIGNvbnN0IHBheW1lbnRMaW5rID0ge1xuICAgICAgICBldm1DcmVhdG9yOiByZXN1bHQuZXZtQ3JlYXRvcixcbiAgICAgICAgc29sYW5hQ3JlYXRvcjogcmVzdWx0LnNvbGFuYUNyZWF0b3IsXG4gICAgICAgIGFtb3VudDogcmVzdWx0LmFtb3VudCxcbiAgICAgICAgaXNGbGV4aWJsZTogcmVzdWx0LmlzRmxleGlibGUsXG4gICAgICAgIGlzQWN0aXZlOiByZXN1bHQuaXNBY3RpdmUsXG4gICAgICAgIHRvdGFsUmVjZWl2ZWQ6IHJlc3VsdC50b3RhbFJlY2VpdmVkLFxuICAgICAgICBwYXltZW50Q291bnQ6IE51bWJlcihyZXN1bHQucGF5bWVudENvdW50KSxcbiAgICAgICAgZGVzY3JpcHRpb246IHJlc3VsdC5kZXNjcmlwdGlvblxuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGxvb2tzIGxpa2UgYW4gZW1wdHkvbm9uLWV4aXN0ZW50IGxpbmsgKHRyYW5zYWN0aW9uIG5vdCBwcm9jZXNzZWQgeWV0KVxuICAgICAgaWYgKHJlc3VsdC5ldm1DcmVhdG9yID09PSAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyAmJlxuICAgICAgICByZXN1bHQuYW1vdW50ID09PSBCaWdJbnQoMCkgJiZcbiAgICAgICAgIXJlc3VsdC5pc0FjdGl2ZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1BheW1lbnQgbGluayBhcHBlYXJzIHRvIGJlIGVtcHR5L25vbi1leGlzdGVudCcpXG5cbiAgICAgICAgLy8gSWYgdGhpcyBsb29rcyBsaWtlIGEgdHJhbnNhY3Rpb24gaGFzaCAoNjYgY2hhcnMsIHN0YXJ0cyB3aXRoIDB4KSwgcHJvdmlkZSBoZWxwZnVsIGluZm9cbiAgICAgICAgaWYgKGxpbmtJZC5sZW5ndGggPT09IDY2ICYmIGxpbmtJZC5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ/CfkqEgVGhpcyBhcHBlYXJzIHRvIGJlIGEgdHJhbnNhY3Rpb24gaGFzaCAtIHRoZSBwYXltZW50IGxpbmsgbWF5IHN0aWxsIGJlIHByb2Nlc3NpbmcnKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5KhIE5lb24gb3BlcmF0b3JzIHdpbGwgZXZlbnR1YWxseSBwcm9jZXNzIHRoaXMgdHJhbnNhY3Rpb24gYW5kIGNyZWF0ZSB0aGUgcGF5bWVudCBsaW5rJylcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+SoSBZb3UgY2FuIGJvb2ttYXJrIHRoaXMgbGluayBhbmQgdHJ5IGFnYWluIGluIGEgZmV3IG1pbnV0ZXMnKVxuXG4gICAgICAgICAgLy8gRm9yIG5vdywgZG9uJ3QgdGhyb3cgYW4gZXJyb3IgLSBsZXQgdGhlIFVJIGhhbmRsZSB0aGUgZW1wdHkgZGF0YSBncmFjZWZ1bGx5XG4gICAgICAgICAgY29uc29sZS5sb2coJ1JldHVybmluZyBlbXB0eSBwYXltZW50IGxpbmsgZGF0YSAtIHRyYW5zYWN0aW9uIG1heSBzdGlsbCBiZSBwcm9jZXNzaW5nJylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF5bWVudExpbmtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQ29udHJhY3QgY2FsbCBlcnJvcjonLCBlcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGF5bWVudCBsaW5rIG5vdCBmb3VuZCBvciBjb250cmFjdCBlcnJvcicpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB1c2VyJ3MgcGF5bWVudCBsaW5rc1xuICAgKi9cbiAgYXN5bmMgZ2V0VXNlckxpbmtzKHVzZXJFVk1BZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgLy8gSW5pdGlhbGl6ZSBjb250cmFjdCBpZiBub3QgYWxyZWFkeSBkb25lXG4gICAgaWYgKCF0aGlzLmNvbnRyYWN0KSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRSZWFkT25seUNvbnRyYWN0KClcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29udHJhY3QhLmdldFVzZXJTb2xhbmFMaW5rcyh1c2VyRVZNQWRkcmVzcylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB1c2VyIGxpbmtzOicsIGVycm9yKVxuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBheSBhIHBheW1lbnQgbGluayB1c2luZyBTb2xhbmEgTmF0aXZlIFNES1xuICAgKi9cbiAgYXN5bmMgcGF5TGluayhcbiAgICBsaW5rSWQ6IHN0cmluZyxcbiAgICBhbW91bnRTT0w6IG51bWJlclxuICApOiBQcm9taXNlPHsgdHhIYXNoOiBzdHJpbmc7IHRyYW5zZmVyU2lnbmF0dXJlPzogc3RyaW5nIH0+IHtcbiAgICBpZiAoIXRoaXMuc29sYW5hVXNlciB8fCAhdGhpcy5jb250cmFjdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgY29ubmVjdCB3YWxsZXQgZmlyc3QnKVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdTdGFydGluZyBwYXltZW50IHByb2Nlc3MuLi4nKVxuICAgIGNvbnNvbGUubG9nKCdMaW5rIElEOicsIGxpbmtJZClcbiAgICBjb25zb2xlLmxvZygnQW1vdW50IFNPTDonLCBhbW91bnRTT0wpXG5cbiAgICAvLyBGaXJzdCwgZ2V0IHRoZSBwYXltZW50IGxpbmsgZGV0YWlscyB0byBmaW5kIHRoZSByZWNpcGllbnRcbiAgICBjb25zdCBsaW5rRGF0YSA9IGF3YWl0IHRoaXMuZ2V0UGF5bWVudExpbmsobGlua0lkKVxuICAgIGNvbnNvbGUubG9nKCdQYXltZW50IGxpbmsgZGF0YTonLCBsaW5rRGF0YSlcblxuICAgIGlmICghbGlua0RhdGEuaXNBY3RpdmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGF5bWVudCBsaW5rIGlzIG5vIGxvbmdlciBhY3RpdmUnKVxuICAgIH1cblxuICAgIC8vIENvbnZlcnQgU09MIHRvIGxhbXBvcnRzXG4gICAgY29uc3QgYW1vdW50TGFtcG9ydHMgPSBNYXRoLmZsb29yKGFtb3VudFNPTCAqIDFlOSlcblxuICAgIGxldCB0cmFuc2ZlclNpZ25hdHVyZTogc3RyaW5nIHwgdW5kZWZpbmVkXG5cbiAgICB0cnkge1xuICAgICAgLy8gU3RlcCAxOiBQZXJmb3JtIHRoZSBhY3R1YWwgU09MIHRyYW5zZmVyIGZpcnN0XG4gICAgICBjb25zb2xlLmxvZygnU3RlcCAxOiBQZXJmb3JtaW5nIFNPTCB0cmFuc2Zlci4uLicpXG4gICAgICBjb25zb2xlLmxvZygnRnJvbTonLCB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LnRvQmFzZTU4KCkpXG4gICAgICBjb25zb2xlLmxvZygnVG8gcmVjaXBpZW50IGJ5dGVzMzI6JywgbGlua0RhdGEuc29sYW5hQ3JlYXRvcilcbiAgICAgIGNvbnNvbGUubG9nKCdBbW91bnQgbGFtcG9ydHM6JywgYW1vdW50TGFtcG9ydHMpXG5cbiAgICAgIC8vIENvbnZlcnQgcmVjaXBpZW50IFNvbGFuYSBhZGRyZXNzIGZyb20gYnl0ZXMzMiB0byBQdWJsaWNLZXlcbiAgICAgIC8vIFJlbW92ZSAnMHgnIHByZWZpeCBpZiBwcmVzZW50XG4gICAgICBjb25zdCBoZXhTdHJpbmcgPSBsaW5rRGF0YS5zb2xhbmFDcmVhdG9yLnN0YXJ0c1dpdGgoJzB4JylcbiAgICAgICAgPyBsaW5rRGF0YS5zb2xhbmFDcmVhdG9yLnNsaWNlKDIpXG4gICAgICAgIDogbGlua0RhdGEuc29sYW5hQ3JlYXRvclxuXG4gICAgICAvLyBDb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheVxuICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShoZXhTdHJpbmcubWF0Y2goLy57Mn0vZyk/Lm1hcChieXRlID0+IHBhcnNlSW50KGJ5dGUsIDE2KSkgfHwgW10pXG5cbiAgICAgIC8vIEZvciBieXRlczMyIGZyb20gU29sYW5hIGFkZHJlc3Nlcywgd2UgbmVlZCB0byBmaW5kIHRoZSBhY3R1YWwgMzItYnl0ZSBwdWJsaWMga2V5XG4gICAgICAvLyBUaGUgYnl0ZXMzMiBzaG91bGQgY29udGFpbiB0aGUgMzItYnl0ZSBTb2xhbmEgcHVibGljIGtleSwgcG9zc2libHkgd2l0aCBsZWFkaW5nIHplcm9zXG4gICAgICBsZXQgcmVjaXBpZW50UHVia2V5XG5cbiAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDMyKSB7XG4gICAgICAgIC8vIERpcmVjdCBjb252ZXJzaW9uIGZyb20gMzIgYnl0ZXNcbiAgICAgICAgcmVjaXBpZW50UHVia2V5ID0gbmV3IChhd2FpdCBpbXBvcnQoJ0Bzb2xhbmEvd2ViMy5qcycpKS5QdWJsaWNLZXkoYnl0ZXMpXG4gICAgICB9IGVsc2UgaWYgKGJ5dGVzLmxlbmd0aCA+IDMyKSB7XG4gICAgICAgIC8vIFRha2UgdGhlIGxhc3QgMzIgYnl0ZXMgaWYgaXQncyBsb25nZXJcbiAgICAgICAgY29uc3QgbGFzdDMyQnl0ZXMgPSBieXRlcy5zbGljZSgtMzIpXG4gICAgICAgIHJlY2lwaWVudFB1YmtleSA9IG5ldyAoYXdhaXQgaW1wb3J0KCdAc29sYW5hL3dlYjMuanMnKSkuUHVibGljS2V5KGxhc3QzMkJ5dGVzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUGFkIHdpdGggbGVhZGluZyB6ZXJvcyBpZiBzaG9ydGVyXG4gICAgICAgIGNvbnN0IHBhZGRlZEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMzIpXG4gICAgICAgIHBhZGRlZEJ5dGVzLnNldChieXRlcywgMzIgLSBieXRlcy5sZW5ndGgpXG4gICAgICAgIHJlY2lwaWVudFB1YmtleSA9IG5ldyAoYXdhaXQgaW1wb3J0KCdAc29sYW5hL3dlYjMuanMnKSkuUHVibGljS2V5KHBhZGRlZEJ5dGVzKVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnUmVjaXBpZW50IFB1YmxpY0tleTonLCByZWNpcGllbnRQdWJrZXkudG9CYXNlNTgoKSlcblxuICAgICAgLy8gQ3JlYXRlIHRoZSBTT0wgdHJhbnNmZXIgdHJhbnNhY3Rpb25cbiAgICAgIGNvbnN0IHsgU3lzdGVtUHJvZ3JhbSwgVHJhbnNhY3Rpb24gfSA9IGF3YWl0IGltcG9ydCgnQHNvbGFuYS93ZWIzLmpzJylcblxuICAgICAgLy8gQ3JlYXRlIHRyYW5zZmVyIGluc3RydWN0aW9uXG4gICAgICBjb25zdCB0cmFuc2Zlckl4ID0gU3lzdGVtUHJvZ3JhbS50cmFuc2Zlcih7XG4gICAgICAgIGZyb21QdWJrZXk6IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXksXG4gICAgICAgIHRvUHVia2V5OiByZWNpcGllbnRQdWJrZXksXG4gICAgICAgIGxhbXBvcnRzOiBhbW91bnRMYW1wb3J0c1xuICAgICAgfSlcblxuICAgICAgLy8gQ3JlYXRlIHRyYW5zYWN0aW9uXG4gICAgICBjb25zdCB0cmFuc2ZlclR4ID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHRyYW5zZmVySXgpXG5cbiAgICAgIC8vIEdldCBmcmVzaCByZWNlbnQgYmxvY2toYXNoIHJpZ2h0IGJlZm9yZSBzaWduaW5nXG4gICAgICBjb25zb2xlLmxvZygnR2V0dGluZyBmcmVzaCBibG9ja2hhc2ggZm9yIFNPTCB0cmFuc2Zlci4uLicpXG4gICAgICBjb25zdCB7IGJsb2NraGFzaCwgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IHRyYW5zZmVyQmxvY2tIZWlnaHQgfSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goJ2NvbmZpcm1lZCcpXG4gICAgICBjb25zb2xlLmxvZygnRnJlc2ggU09MIHRyYW5zZmVyIGJsb2NraGFzaDonLCBibG9ja2hhc2gpXG4gICAgICBjb25zb2xlLmxvZygnTGFzdCB2YWxpZCBibG9jayBoZWlnaHQ6JywgdHJhbnNmZXJCbG9ja0hlaWdodClcblxuICAgICAgdHJhbnNmZXJUeC5yZWNlbnRCbG9ja2hhc2ggPSBibG9ja2hhc2hcbiAgICAgIHRyYW5zZmVyVHguZmVlUGF5ZXIgPSB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5XG5cbiAgICAgIC8vIFNpZ24gYW5kIHNlbmQgdGhlIFNPTCB0cmFuc2ZlciBpbW1lZGlhdGVseVxuICAgICAgY29uc29sZS5sb2coJ1NpZ25pbmcgYW5kIHNlbmRpbmcgU09MIHRyYW5zZmVyIHdpdGggZnJlc2ggYmxvY2toYXNoLi4uJylcbiAgICAgIGNvbnN0IHNpZ25lZFRyYW5zZmVyVHggPSBhd2FpdCB0aGlzLnNvbGFuYVVzZXIud2FsbGV0QWRhcHRlci5zaWduVHJhbnNhY3Rpb24odHJhbnNmZXJUeClcbiAgICAgIHRyYW5zZmVyU2lnbmF0dXJlID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihzaWduZWRUcmFuc2ZlclR4LnNlcmlhbGl6ZSgpKVxuXG4gICAgICBjb25zb2xlLmxvZygnU09MIHRyYW5zZmVyIHNlbnQ6JywgdHJhbnNmZXJTaWduYXR1cmUpXG5cbiAgICAgIC8vIFdhaXQgZm9yIHRyYW5zZmVyIGNvbmZpcm1hdGlvbiB1c2luZyB0aGUgbW9kZXJuIEFQSVxuICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XG4gICAgICAgIHNpZ25hdHVyZTogdHJhbnNmZXJTaWduYXR1cmUsXG4gICAgICAgIC4uLihhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCkpXG4gICAgICB9KVxuICAgICAgY29uc29sZS5sb2coJ1NPTCB0cmFuc2ZlciBjb25maXJtZWQnKVxuXG4gICAgICAvLyBTdGVwIDI6IFJlY29yZCB0aGUgcGF5bWVudCBpbiB0aGUgY29udHJhY3RcbiAgICAgIGNvbnNvbGUubG9nKCdTdGVwIDI6IFJlY29yZGluZyBwYXltZW50IGluIGNvbnRyYWN0Li4uJylcblxuICAgICAgLy8gQ29udmVydCBTb2xhbmEgUHVibGljS2V5IHRvIGJ5dGVzMzJcbiAgICAgIGNvbnN0IHBheWVyU29sYW5hQnl0ZXMzMiA9IHplcm9QYWRWYWx1ZShoZXhsaWZ5KHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXkudG9CeXRlcygpKSwgMzIpXG5cbiAgICAgIC8vIEdldCBjdXJyZW50IG5vbmNlXG4gICAgICBjb25zdCBub25jZSA9IE51bWJlcihhd2FpdCB0aGlzLnByb3h5QXBpLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQpKVxuICAgICAgY29uc29sZS5sb2coJ0N1cnJlbnQgbm9uY2U6Jywgbm9uY2UpXG5cbiAgICAgIC8vIFByZXBhcmUgY29udHJhY3QgY2FsbCBkYXRhXG4gICAgICBjb25zdCBpZmFjZSA9IG5ldyBldGhlcnMuSW50ZXJmYWNlKFNPTEFOQV9USVBDQVJEX0FCSSlcbiAgICAgIGNvbnN0IGRhdGEgPSBpZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoJ3BheVNvbGFuYUxpbmsnLCBbXG4gICAgICAgIGxpbmtJZCxcbiAgICAgICAgYW1vdW50TGFtcG9ydHMsXG4gICAgICAgIHBheWVyU29sYW5hQnl0ZXMzMlxuICAgICAgXSlcblxuICAgICAgLy8gQ3JlYXRlIHRyYW5zYWN0aW9uIGRhdGFcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uRGF0YSA9IHtcbiAgICAgICAgZnJvbTogdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsXG4gICAgICAgIHRvOiBDT05UUkFDVF9BRERSRVNTLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9XG5cbiAgICAgIC8vIEVzdGltYXRlIGdhc1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25HYXMgPSBhd2FpdCB0aGlzLnByb3h5QXBpLmVzdGltYXRlU2NoZWR1bGVkVHJhbnNhY3Rpb25HYXMoe1xuICAgICAgICBzb2xhbmFQYXllcjogdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleSxcbiAgICAgICAgdHJhbnNhY3Rpb25zOiBbdHJhbnNhY3Rpb25EYXRhXSxcbiAgICAgIH0pXG5cbiAgICAgIC8vIENyZWF0ZSBzY2hlZHVsZWQgdHJhbnNhY3Rpb25cbiAgICAgIGxldCB7IHNjaGVkdWxlZFRyYW5zYWN0aW9uIH0gPSBhd2FpdCB0aGlzLnByb3h5QXBpLmNyZWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgdHJhbnNhY3Rpb25HYXMsXG4gICAgICAgIHRyYW5zYWN0aW9uRGF0YSxcbiAgICAgICAgbm9uY2VcbiAgICAgIH0pXG5cbiAgICAgIC8vIEdldCBmcmVzaCByZWNlbnQgYmxvY2toYXNoIHJpZ2h0IGJlZm9yZSBzaWduaW5nXG4gICAgICBjb25zb2xlLmxvZygnR2V0dGluZyBmcmVzaCBibG9ja2hhc2ggZm9yIGNvbnRyYWN0IGNhbGwuLi4nKVxuICAgICAgY29uc3QgeyBibG9ja2hhc2g6IGNvbnRyYWN0QmxvY2toYXNoLCBsYXN0VmFsaWRCbG9ja0hlaWdodDogY29udHJhY3RCbG9ja0hlaWdodCB9ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgnY29uZmlybWVkJylcbiAgICAgIGNvbnNvbGUubG9nKCdGcmVzaCBjb250cmFjdCBjYWxsIGJsb2NraGFzaDonLCBjb250cmFjdEJsb2NraGFzaClcbiAgICAgIGNvbnNvbGUubG9nKCdMYXN0IHZhbGlkIGJsb2NrIGhlaWdodDonLCBjb250cmFjdEJsb2NrSGVpZ2h0KVxuXG4gICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBjb250cmFjdEJsb2NraGFzaFxuICAgICAgc2NoZWR1bGVkVHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5XG5cbiAgICAgIC8vIFNpZ24gd2l0aCB3YWxsZXQgYWRhcHRlciAoZnJvbnRlbmQgYXBwcm9hY2gpXG4gICAgICBjb25zb2xlLmxvZygnU2lnbmluZyBjb250cmFjdCBjYWxsIHdpdGggZnJlc2ggYmxvY2toYXNoLi4uJylcbiAgICAgIGNvbnN0IHNpZ25lZFR4ID0gYXdhaXQgdGhpcy5zb2xhbmFVc2VyLndhbGxldEFkYXB0ZXIuc2lnblRyYW5zYWN0aW9uKHNjaGVkdWxlZFRyYW5zYWN0aW9uKVxuXG4gICAgICAvLyBTZW5kIHRyYW5zYWN0aW9uIGltbWVkaWF0ZWx5XG4gICAgICBjb25zb2xlLmxvZygnU2VuZGluZyBjb250cmFjdCBjYWxsIHRyYW5zYWN0aW9uIGltbWVkaWF0ZWx5Li4uJylcbiAgICAgIGF3YWl0IHRoaXMuY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24oc2lnbmVkVHguc2VyaWFsaXplKCkpXG5cbiAgICAgIC8vIFdhaXQgZm9yIHRyYW5zYWN0aW9uIGV4ZWN1dGlvbiBvbiBOZW9uIEVWTVxuICAgICAgY29uc3QgdHJhbnNhY3Rpb25TdGF0dXMgPSBhd2FpdCB0aGlzLnByb3h5QXBpLndhaXRUcmFuc2FjdGlvblRyZWVFeGVjdXRpb24oXG4gICAgICAgIHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0LFxuICAgICAgICBub25jZSxcbiAgICAgICAgNjAwMDBcbiAgICAgIClcblxuICAgICAgaWYgKHRyYW5zYWN0aW9uU3RhdHVzLmxlbmd0aCA9PT0gMCB8fCB0cmFuc2FjdGlvblN0YXR1c1swXS5zdGF0dXMgIT09ICdTdWNjZXNzJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0NvbnRyYWN0IHBheW1lbnQgcmVjb3JkaW5nIGZhaWxlZCwgYnV0IFNPTCB0cmFuc2ZlciBzdWNjZWVkZWQnKVxuICAgICAgICBjb25zb2xlLmxvZygnVHJhbnNmZXIgc2lnbmF0dXJlOicsIHRyYW5zZmVyU2lnbmF0dXJlKVxuICAgICAgICAvLyBEb24ndCB0aHJvdyBlcnJvciAtIHRoZSBwYXltZW50IHdlbnQgdGhyb3VnaCBldmVuIGlmIHJlY29yZGluZyBmYWlsZWRcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ1BheW1lbnQgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSEnKVxuICAgICAgY29uc29sZS5sb2coJ1NPTCB0cmFuc2ZlcjonLCB0cmFuc2ZlclNpZ25hdHVyZSlcbiAgICAgIGNvbnNvbGUubG9nKCdDb250cmFjdCByZWNvcmQ6JywgdHJhbnNhY3Rpb25TdGF0dXNbMF0/LnRyYW5zYWN0aW9uSGFzaClcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHhIYXNoOiB0cmFuc2FjdGlvblN0YXR1c1swXT8udHJhbnNhY3Rpb25IYXNoIHx8ICdjb250cmFjdC1yZWNvcmRpbmctZmFpbGVkJyxcbiAgICAgICAgdHJhbnNmZXJTaWduYXR1cmVcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXlpbmcgbGluazonLCBlcnJvcilcbiAgICAgIGlmICh0cmFuc2ZlclNpZ25hdHVyZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnTm90ZTogU09MIHRyYW5zZmVyIG1heSBoYXZlIHN1Y2NlZWRlZDonLCB0cmFuc2ZlclNpZ25hdHVyZSlcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlYWN0aXZhdGUgYSBwYXltZW50IGxpbmtcbiAgICovXG4gIGFzeW5jIGRlYWN0aXZhdGVMaW5rKGxpbmtJZDogc3RyaW5nKTogUHJvbWlzZTx7IHR4SGFzaDogc3RyaW5nIH0+IHtcbiAgICBpZiAoIXRoaXMuc29sYW5hVXNlciB8fCAhdGhpcy5jb250cmFjdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgY29ubmVjdCB3YWxsZXQgZmlyc3QnKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgY3VycmVudCBub25jZVxuICAgICAgY29uc3Qgbm9uY2UgPSBOdW1iZXIoYXdhaXQgdGhpcy5wcm94eUFwaS5nZXRUcmFuc2FjdGlvbkNvdW50KHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0KSlcbiAgICAgIGNvbnNvbGUubG9nKCdDdXJyZW50IG5vbmNlOicsIG5vbmNlKVxuXG4gICAgICAvLyBQcmVwYXJlIGNvbnRyYWN0IGNhbGwgZGF0YVxuICAgICAgY29uc3QgaWZhY2UgPSBuZXcgZXRoZXJzLkludGVyZmFjZShTT0xBTkFfVElQQ0FSRF9BQkkpXG4gICAgICBjb25zdCBkYXRhID0gaWZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKCdkZWFjdGl2YXRlU29sYW5hTGluaycsIFtsaW5rSWRdKVxuXG4gICAgICAvLyBDcmVhdGUgdHJhbnNhY3Rpb24gZGF0YVxuICAgICAgY29uc3QgdHJhbnNhY3Rpb25EYXRhID0ge1xuICAgICAgICBmcm9tOiB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCxcbiAgICAgICAgdG86IENPTlRSQUNUX0FERFJFU1MsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH1cblxuICAgICAgLy8gRXN0aW1hdGUgZ2FzXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkdhcyA9IGF3YWl0IHRoaXMucHJveHlBcGkuZXN0aW1hdGVTY2hlZHVsZWRUcmFuc2FjdGlvbkdhcyh7XG4gICAgICAgIHNvbGFuYVBheWVyOiB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LFxuICAgICAgICB0cmFuc2FjdGlvbnM6IFt0cmFuc2FjdGlvbkRhdGFdLFxuICAgICAgfSlcblxuICAgICAgLy8gQ3JlYXRlIHNjaGVkdWxlZCB0cmFuc2FjdGlvblxuICAgICAgbGV0IHsgc2NoZWR1bGVkVHJhbnNhY3Rpb24gfSA9IGF3YWl0IHRoaXMucHJveHlBcGkuY3JlYXRlU2NoZWR1bGVkVHJhbnNhY3Rpb24oe1xuICAgICAgICB0cmFuc2FjdGlvbkdhcyxcbiAgICAgICAgdHJhbnNhY3Rpb25EYXRhLFxuICAgICAgICBub25jZVxuICAgICAgfSlcblxuICAgICAgLy8gR2V0IGZyZXNoIHJlY2VudCBibG9ja2hhc2ggcmlnaHQgYmVmb3JlIHNpZ25pbmdcbiAgICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIGZyZXNoIGJsb2NraGFzaCBmb3IgZGVhY3RpdmF0ZSB0cmFuc2FjdGlvbi4uLicpXG4gICAgICBjb25zdCB7IGJsb2NraGFzaCwgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IGRlYWN0aXZhdGVCbG9ja0hlaWdodCB9ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgnY29uZmlybWVkJylcbiAgICAgIGNvbnNvbGUubG9nKCdGcmVzaCBkZWFjdGl2YXRlIGJsb2NraGFzaDonLCBibG9ja2hhc2gpXG4gICAgICBjb25zb2xlLmxvZygnTGFzdCB2YWxpZCBibG9jayBoZWlnaHQ6JywgZGVhY3RpdmF0ZUJsb2NrSGVpZ2h0KVxuXG4gICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBibG9ja2hhc2hcbiAgICAgIHNjaGVkdWxlZFRyYW5zYWN0aW9uLmZlZVBheWVyID0gdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleVxuXG4gICAgICAvLyBTaWduIHdpdGggd2FsbGV0IGFkYXB0ZXIgKGZyb250ZW5kIGFwcHJvYWNoKVxuICAgICAgY29uc29sZS5sb2coJ1NpZ25pbmcgZGVhY3RpdmF0ZSB0cmFuc2FjdGlvbiB3aXRoIGZyZXNoIGJsb2NraGFzaC4uLicpXG4gICAgICBjb25zdCBzaWduZWRUeCA9IGF3YWl0IHRoaXMuc29sYW5hVXNlci53YWxsZXRBZGFwdGVyLnNpZ25UcmFuc2FjdGlvbihzY2hlZHVsZWRUcmFuc2FjdGlvbilcblxuICAgICAgLy8gU2VuZCB0cmFuc2FjdGlvbiBpbW1lZGlhdGVseVxuICAgICAgY29uc29sZS5sb2coJ1NlbmRpbmcgZGVhY3RpdmF0ZSB0cmFuc2FjdGlvbiBpbW1lZGlhdGVseS4uLicpXG4gICAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uc2VuZFJhd1RyYW5zYWN0aW9uKHNpZ25lZFR4LnNlcmlhbGl6ZSgpKVxuXG4gICAgICAvLyBXYWl0IGZvciB0cmFuc2FjdGlvbiBleGVjdXRpb25cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uU3RhdHVzID0gYXdhaXQgdGhpcy5wcm94eUFwaS53YWl0VHJhbnNhY3Rpb25UcmVlRXhlY3V0aW9uKFxuICAgICAgICB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCxcbiAgICAgICAgbm9uY2UsXG4gICAgICAgIDYwMDAwXG4gICAgICApXG5cbiAgICAgIGlmICh0cmFuc2FjdGlvblN0YXR1cy5sZW5ndGggPT09IDAgfHwgdHJhbnNhY3Rpb25TdGF0dXNbMF0uc3RhdHVzICE9PSAnU3VjY2VzcycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWFjdGl2YXRpb24gdHJhbnNhY3Rpb24gZmFpbGVkIHRvIGV4ZWN1dGUgb24gTmVvbiBFVk0nKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eEhhc2g6IHRyYW5zYWN0aW9uU3RhdHVzWzBdLnRyYW5zYWN0aW9uSGFzaFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNoYXJlYWJsZSBVUkwgZm9yIGEgcGF5bWVudCBsaW5rXG4gICAqL1xuICBjcmVhdGVQYXltZW50VVJMKGxpbmtJZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn0/cGF5PSR7bGlua0lkfWBcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IGxpbmsgSUQgZnJvbSBVUkxcbiAgICovXG4gIHN0YXRpYyBleHRyYWN0TGlua0lkRnJvbVVSTCh1cmw6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1cmxPYmogPSBuZXcgVVJMKHVybClcbiAgICAgIHJldHVybiB1cmxPYmouc2VhcmNoUGFyYW1zLmdldCgncGF5JylcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdXNlcidzIEVWTSBhZGRyZXNzIGRlcml2ZWQgZnJvbSBTb2xhbmEgcHVibGljIGtleVxuICAgKi9cbiAgZ2V0VXNlckVWTUFkZHJlc3MoKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuc29sYW5hVXNlcj8ubmVvbldhbGxldCB8fCBudWxsXG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IHNvbGFuYU5hdGl2ZUNvbnRyYWN0ID0gbmV3IFNvbGFuYU5hdGl2ZUNvbnRyYWN0KCkiXSwibmFtZXMiOlsiQ29ubmVjdGlvbiIsIk5lb25Qcm94eVJwY0FwaSIsImNyZWF0ZUJhbGFuY2VBY2NvdW50SW5zdHJ1Y3Rpb24iLCJldGhlcnMiLCJoZXhsaWZ5IiwiemVyb1BhZFZhbHVlIiwiQ29udHJhY3RBQkkiLCJTT0xBTkFfVElQQ0FSRF9BQkkiLCJDT05UUkFDVF9BRERSRVNTIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1RJUENBUkRfQ09OVFJBQ1RfQUREUkVTUyIsIk5FT05fQ09SRV9SUENfVVJMIiwiTkVYVF9QVUJMSUNfTkVPTl9SUENfVVJMIiwiTkVPTl9QUk9YWV9SUENfVVJMIiwiU09MQU5BX1JQQ19VUkwiLCJTb2xhbmFOYXRpdmVDb250cmFjdCIsImluaXRXaXRoU29sYW5hV2FsbGV0Iiwid2FsbGV0QWRhcHRlciIsInB1YmxpY0tleSIsIkVycm9yIiwiY29uc29sZSIsImxvZyIsInRvQmFzZTU4IiwicHJvdmlkZXIiLCJjaGFpbklkIiwic29sYW5hVXNlciIsInRva2VuTWludEFkZHJlc3MiLCJwcm9ncmFtQWRkcmVzcyIsInByb3h5QXBpIiwiaW5pdCIsImJhbGFuY2VBZGRyZXNzIiwiU29sYW5hTmVvbkFjY291bnQiLCJhY2NvdW50IiwibmVvbkV2bVByb2dyYW0iLCJ0b2tlbk1pbnQiLCJlcnJvciIsInJlYWRPbmx5UHJvdmlkZXIiLCJKc29uUnBjUHJvdmlkZXIiLCJjb250cmFjdCIsIkNvbnRyYWN0IiwidHhDb3VudCIsImdldFRyYW5zYWN0aW9uQ291bnQiLCJuZW9uV2FsbGV0IiwidmVyaWZ5RXJyb3IiLCJjb2RlIiwiZ2V0Q29kZSIsIndhcm4iLCJjcmVhdGVQYXltZW50TGluayIsInN1Z2dlc3RlZEFtb3VudFNPTCIsImlzRmxleGlibGUiLCJkZXNjcmlwdGlvbiIsImFtb3VudExhbXBvcnRzIiwiTWF0aCIsImZsb29yIiwic2lnbmF0dXJlIiwibm9uY2UiLCJOdW1iZXIiLCJpZmFjZSIsIkludGVyZmFjZSIsImRhdGEiLCJlbmNvZGVGdW5jdGlvbkRhdGEiLCJ0cmFuc2FjdGlvbkRhdGEiLCJmcm9tIiwidG8iLCJ0cmFuc2FjdGlvbkdhcyIsImVzdGltYXRlU2NoZWR1bGVkVHJhbnNhY3Rpb25HYXMiLCJzb2xhbmFQYXllciIsInRyYW5zYWN0aW9ucyIsInNjaGVkdWxlZFRyYW5zYWN0aW9uIiwiY3JlYXRlU2NoZWR1bGVkVHJhbnNhY3Rpb24iLCJjb25uZWN0aW9uIiwiZ2V0QWNjb3VudEluZm8iLCJpbnN0cnVjdGlvbnMiLCJ1bnNoaWZ0IiwiYmxvY2toYXNoIiwiZ2V0TGF0ZXN0QmxvY2toYXNoIiwicmVjZW50QmxvY2toYXNoIiwiZmVlUGF5ZXIiLCJzaWduZWRUcmFuc2FjdGlvbiIsInNpZ25UcmFuc2FjdGlvbiIsInNlbmRSYXdUcmFuc2FjdGlvbiIsInNlcmlhbGl6ZSIsImNvbmZpcm1UcmFuc2FjdGlvbiIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsIm5lb25UeFJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJwYXJhbXMiLCJpZCIsImpzb25ycGMiLCJuZW9uVHhSZXN1bHQiLCJqc29uIiwicmVzdWx0IiwiaGFzaCIsIm5lb25UeEhhc2giLCJhY3R1YWxMaW5rSWQiLCJhdHRlbXB0IiwicmVjZWlwdFJlc3BvbnNlIiwicmVjZWlwdFJlc3VsdCIsImxvZ3MiLCJsZW5ndGgiLCJkZWNvZGVkIiwicGFyc2VMb2ciLCJuYW1lIiwiYXJncyIsImxpbmtJZCIsImV2bUNyZWF0b3IiLCJmb3JtYXRVbml0cyIsImFtb3VudCIsInR4SGFzaCIsInBhcnNlRXJyb3IiLCJyZWNlaXB0RXJyb3IiLCJtZXNzYWdlIiwibmVvbkVycm9yIiwiY29uZmlybUVycm9yIiwiY2F0Y2giLCJpbml0UmVhZE9ubHlDb250cmFjdCIsImdldFBheW1lbnRMaW5rIiwiZ2V0U29sYW5hUGF5bWVudExpbmsiLCJwYXltZW50TGluayIsInNvbGFuYUNyZWF0b3IiLCJpc0FjdGl2ZSIsInRvdGFsUmVjZWl2ZWQiLCJwYXltZW50Q291bnQiLCJCaWdJbnQiLCJzdGFydHNXaXRoIiwiZ2V0VXNlckxpbmtzIiwidXNlckVWTUFkZHJlc3MiLCJnZXRVc2VyU29sYW5hTGlua3MiLCJwYXlMaW5rIiwiYW1vdW50U09MIiwibGlua0RhdGEiLCJ0cmFuc2ZlclNpZ25hdHVyZSIsImhleFN0cmluZyIsInRyYW5zYWN0aW9uU3RhdHVzIiwic2xpY2UiLCJieXRlcyIsIlVpbnQ4QXJyYXkiLCJtYXRjaCIsIm1hcCIsImJ5dGUiLCJwYXJzZUludCIsInJlY2lwaWVudFB1YmtleSIsIlB1YmxpY0tleSIsImxhc3QzMkJ5dGVzIiwicGFkZGVkQnl0ZXMiLCJzZXQiLCJTeXN0ZW1Qcm9ncmFtIiwiVHJhbnNhY3Rpb24iLCJ0cmFuc2Zlckl4IiwidHJhbnNmZXIiLCJmcm9tUHVia2V5IiwidG9QdWJrZXkiLCJsYW1wb3J0cyIsInRyYW5zZmVyVHgiLCJhZGQiLCJsYXN0VmFsaWRCbG9ja0hlaWdodCIsInRyYW5zZmVyQmxvY2tIZWlnaHQiLCJzaWduZWRUcmFuc2ZlclR4IiwicGF5ZXJTb2xhbmFCeXRlczMyIiwidG9CeXRlcyIsImNvbnRyYWN0QmxvY2toYXNoIiwiY29udHJhY3RCbG9ja0hlaWdodCIsInNpZ25lZFR4Iiwid2FpdFRyYW5zYWN0aW9uVHJlZUV4ZWN1dGlvbiIsInN0YXR1cyIsInRyYW5zYWN0aW9uSGFzaCIsImRlYWN0aXZhdGVMaW5rIiwiZGVhY3RpdmF0ZUJsb2NrSGVpZ2h0IiwiY3JlYXRlUGF5bWVudFVSTCIsIndpbmRvdyIsImxvY2F0aW9uIiwib3JpZ2luIiwiZXh0cmFjdExpbmtJZEZyb21VUkwiLCJ1cmwiLCJ1cmxPYmoiLCJVUkwiLCJzZWFyY2hQYXJhbXMiLCJnZXQiLCJnZXRVc2VyRVZNQWRkcmVzcyIsImNvbnN0cnVjdG9yIiwic29sYW5hTmF0aXZlQ29udHJhY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/solana-native-contract.ts\n"));

/***/ })

});