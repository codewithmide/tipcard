"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/solana-native-contract.ts":
/*!*****************************************!*\
  !*** ./utils/solana-native-contract.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaNativeContract: function() { return /* binding */ SolanaNativeContract; },\n/* harmony export */   solanaNativeContract: function() { return /* binding */ solanaNativeContract; }\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var _neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @neonevm/solana-sign */ \"(app-pages-browser)/./node_modules/@neonevm/solana-sign/dist/esm/index.mjs\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _contractABI_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contractABI.json */ \"(app-pages-browser)/./utils/contractABI.json\");\n\n\n\n\n// Use the actual deployed contract ABI\nconst SOLANA_TIPCARD_ABI = _contractABI_json__WEBPACK_IMPORTED_MODULE_2__;\nconst CONTRACT_ADDRESS = \"0xCFE03c7c67456D094C0162F9030393FC2cCc40Cb\" || 0;\nconst NEON_CORE_RPC_URL = \"https://devnet.neonevm.org\" || 0;\nconst NEON_PROXY_RPC_URL = \"\".concat(NEON_CORE_RPC_URL, \"/sol\");\nconst SOLANA_RPC_URL = \"https://api.devnet.solana.com\";\nclass SolanaNativeContract {\n    /**\n   * Get Neon EVM chain ID\n   */ async getChainId() {\n        try {\n            // Use the proxy API to get chain information\n            const response = await fetch(NEON_PROXY_RPC_URL, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    id: 1,\n                    jsonrpc: \"2.0\",\n                    method: \"eth_chainId\",\n                    params: []\n                })\n            });\n            const result = await response.json();\n            return parseInt(result.result, 16) // Convert hex to decimal\n            ;\n        } catch (error) {\n            console.warn(\"Could not get chain ID, using default:\", error);\n            return 245022927 // Neon Devnet default\n            ;\n        }\n    }\n    /**\n   * Get Neon EVM program address using a temporary initialization\n   */ async getNeonEvmProgram() {\n        try {\n            var _initResult_solanaUser;\n            console.log(\"Attempting to get Neon EVM program via temporary keypair initialization...\");\n            // Create a temporary keypair just to get the program information\n            const { Keypair } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"));\n            const tempKeypair = Keypair.generate();\n            // Use the existing proxyApi to get the information\n            const initResult = await this.proxyApi.init(tempKeypair);\n            console.log(\"Temporary init result:\", initResult);\n            if ((_initResult_solanaUser = initResult.solanaUser) === null || _initResult_solanaUser === void 0 ? void 0 : _initResult_solanaUser.neonEvmProgram) {\n                return initResult.solanaUser.neonEvmProgram;\n            } else {\n                throw new Error(\"No neonEvmProgram in init result\");\n            }\n        } catch (error) {\n            console.warn(\"Temporary init failed, trying direct API call:\", error);\n            try {\n                var _result_result, _result_result1;\n                // Fallback to direct API call\n                const response = await fetch(NEON_PROXY_RPC_URL, {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        id: 1,\n                        jsonrpc: \"2.0\",\n                        method: \"neon_getEvmParams\",\n                        params: []\n                    })\n                });\n                const result = await response.json();\n                console.log(\"Direct API response:\", result);\n                // Check different possible response structures\n                let programAddress;\n                if ((_result_result = result.result) === null || _result_result === void 0 ? void 0 : _result_result.neonEvmProgram) {\n                    programAddress = result.result.neonEvmProgram;\n                } else if ((_result_result1 = result.result) === null || _result_result1 === void 0 ? void 0 : _result_result1.programId) {\n                    programAddress = result.result.programId;\n                } else if (result.result && typeof result.result === \"string\") {\n                    programAddress = result.result;\n                } else {\n                    throw new Error(\"Unexpected response structure\");\n                }\n                console.log(\"Extracted program address:\", programAddress);\n                return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(programAddress);\n            } catch (apiError) {\n                console.warn(\"Direct API call also failed, using default:\", apiError);\n                // Default Neon EVM program for devnet\n                return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(\"eeLSJgWzzxrqKv1UxtRVVH8FX3qCQWUs9QuAjJpETGSm\");\n            }\n        }\n    }\n    /**\n   * Initialize with Solana wallet using the recommended SolanaNeonAccount approach\n   */ async initWithSolanaWallet(walletAdapter) {\n        if (!walletAdapter.publicKey) {\n            throw new Error(\"Wallet not connected\");\n        }\n        try {\n            console.log(\"\\uD83D\\uDD27 Using recommended SolanaNeonAccount approach...\");\n            console.log(\"Wallet public key:\", walletAdapter.publicKey.toBase58());\n            // Use proxyApi.init with just the public key (like demo)\n            const { provider, chainId, solanaUser, tokenMintAddress, programAddress } = await this.proxyApi.init(walletAdapter.publicKey);\n            console.log(\"- Chain ID:\", chainId);\n            console.log(\"- Neon EVM Program:\", programAddress.toBase58());\n            // Store the result with wallet adapter for signing\n            this.chainId = chainId;\n            this.solanaUser = {\n                ...solanaUser,\n                walletAdapter: walletAdapter // Add wallet adapter for signing\n            };\n            console.log(\"✅ Wallet initialized using test pattern!\");\n            console.log(\"\\uD83D\\uDCCD Connected wallet public key:\", walletAdapter.publicKey.toBase58());\n            console.log(\"\\uD83D\\uDCCD Solana user public key:\", this.solanaUser.publicKey.toBase58());\n            console.log(\"\\uD83D\\uDCCD Derived EVM address:\", this.solanaUser.neonWallet);\n            console.log(\"\\uD83D\\uDCB0 Balance address:\", this.solanaUser.balanceAddress.toBase58());\n            // Verify they match\n            if (walletAdapter.publicKey.toBase58() === this.solanaUser.publicKey.toBase58()) {\n                console.log(\"✅ Wallet public keys match correctly!\");\n            } else {\n                console.error(\"❌ MISMATCH: Wallet adapter and solana user have different public keys!\");\n                console.error(\"Wallet adapter:\", walletAdapter.publicKey.toBase58());\n                console.error(\"Solana user:\", this.solanaUser.publicKey.toBase58());\n            }\n            console.log(\"Solana User Balance Address:\", this.solanaUser.balanceAddress.toBase58());\n            // Create contract instance\n            const readOnlyProvider = new ethers__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider(NEON_CORE_RPC_URL);\n            this.contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.Contract(CONTRACT_ADDRESS, SOLANA_TIPCARD_ABI, readOnlyProvider);\n            // Verify the derived EVM address is valid\n            console.log(\"\\uD83D\\uDD0D Verifying derived EVM address...\");\n            try {\n                // Check if this EVM address has been used before (has transaction history)\n                const txCount = await readOnlyProvider.getTransactionCount(this.solanaUser.neonWallet);\n                console.log(\"\\uD83D\\uDCCA EVM address transaction count:\", txCount);\n                if (txCount > 0) {\n                    console.log(\"✅ This EVM address has transaction history - it exists on-chain!\");\n                } else {\n                    console.log(\"ℹ️ This EVM address is new (no transaction history yet)\");\n                    console.log(\"ℹ️ The address will be registered on-chain when first transaction is made\");\n                }\n            } catch (verifyError) {\n                console.log(\"⚠️ Could not verify EVM address:\", verifyError);\n            }\n            // Verify contract is deployed at this address\n            try {\n                console.log(\"Verifying contract at address:\", CONTRACT_ADDRESS);\n                const code = await readOnlyProvider.getCode(CONTRACT_ADDRESS);\n                console.log(\"Contract code length:\", code.length);\n                if (code === \"0x\") {\n                    console.warn(\"⚠️ No contract code found at address:\", CONTRACT_ADDRESS);\n                    console.log(\"This might mean the contract is not deployed or address is incorrect\");\n                } else {\n                    console.log(\"✅ Contract found at address\");\n                    console.log(\"✅ Contract found and ready for transactions\");\n                }\n            } catch (verifyError) {\n                console.warn(\"Failed to verify contract:\", verifyError);\n            }\n        } catch (error) {\n            console.error(\"Failed to initialize Solana Native SDK:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Create a payment link using Solana Native SDK\n   */ async createPaymentLink(suggestedAmountSOL, isFlexible, description) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        // Convert SOL to lamports (1 SOL = 1e9 lamports)\n        const amountLamports = Math.floor(suggestedAmountSOL * 1e9);\n        try {\n            var _this_solanaUser_walletAdapter_publicKey, _scheduledTransaction_feePayer, _this_solanaUser_walletAdapter_publicKey1, _receipt_result, _receipt_result1, _receipt_result2, _receipt_result_logs, _receipt_result3, _receipt_result4, _receipt_result5, _receipt_result6, _receipt_result7, _receipt_result8, _receipt_result9;\n            // Get current nonce (exactly like working examples)\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Current nonce:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"createSolanaPaymentLink\", [\n                amountLamports,\n                isFlexible,\n                description\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Debug: Check what solanaPayer we're using\n            console.log(\"\\uD83D\\uDD0D Transaction creation debug:\");\n            console.log(\"- solanaPayer for gas estimation:\", this.solanaUser.publicKey.toBase58());\n            console.log(\"- from address in transactionData:\", transactionData.from);\n            console.log(\"- nonce:\", nonce);\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            console.log(\"Gas estimation completed\");\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            console.log(\"Scheduled transaction created\");\n            // Check if balance account exists, if not create it\n            const account = await this.connection.getAccountInfo(this.solanaUser.balanceAddress);\n            if (account === null) {\n                scheduledTransaction.instructions.unshift((0,_neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__.createBalanceAccountInstruction)(this.solanaUser.neonEvmProgram, this.solanaUser.publicKey, this.solanaUser.neonWallet, this.chainId));\n            }\n            // Sign and send transaction (exactly like working examples)\n            const { blockhash } = await this.connection.getLatestBlockhash();\n            scheduledTransaction.recentBlockhash = blockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            console.log(\"\\uD83D\\uDD0D Pre-signing debug:\");\n            console.log(\"- Connected wallet:\", (_this_solanaUser_walletAdapter_publicKey = this.solanaUser.walletAdapter.publicKey) === null || _this_solanaUser_walletAdapter_publicKey === void 0 ? void 0 : _this_solanaUser_walletAdapter_publicKey.toBase58());\n            console.log(\"- Solana user:\", this.solanaUser.publicKey.toBase58());\n            console.log(\"- Transaction feePayer:\", (_scheduledTransaction_feePayer = scheduledTransaction.feePayer) === null || _scheduledTransaction_feePayer === void 0 ? void 0 : _scheduledTransaction_feePayer.toBase58());\n            console.log(\"- Are they the same?\", ((_this_solanaUser_walletAdapter_publicKey1 = this.solanaUser.walletAdapter.publicKey) === null || _this_solanaUser_walletAdapter_publicKey1 === void 0 ? void 0 : _this_solanaUser_walletAdapter_publicKey1.toBase58()) === this.solanaUser.publicKey.toBase58());\n            // Analyze all signers required by this transaction\n            console.log(\"\\uD83D\\uDD0D Transaction signers analysis:\");\n            console.log(\"- Number of instructions:\", scheduledTransaction.instructions.length);\n            const requiredSigners = [];\n            scheduledTransaction.instructions.forEach((instruction, index)=>{\n                console.log(\"- Instruction \".concat(index, \":\"));\n                console.log(\"  - Program ID: \".concat(instruction.programId.toBase58()));\n                console.log(\"  - Keys: \".concat(instruction.keys.length));\n                instruction.keys.forEach((key, keyIndex)=>{\n                    console.log(\"    - Key \".concat(keyIndex, \": \").concat(key.pubkey.toBase58(), \" (signer: \").concat(key.isSigner, \", writable: \").concat(key.isWritable, \")\"));\n                    if (key.isSigner) {\n                        requiredSigners.push(key.pubkey.toBase58());\n                    }\n                });\n            });\n            console.log(\"\\uD83D\\uDD0D Required signers summary:\");\n            console.log(\"- Total signers needed:\", requiredSigners.length);\n            requiredSigners.forEach((signer, index)=>{\n                console.log(\"  - Signer \".concat(index, \": \").concat(signer));\n                if (signer === this.solanaUser.publicKey.toBase58()) {\n                    console.log(\"    ✅ This is our connected wallet\");\n                } else if (signer === this.solanaUser.balanceAddress.toBase58()) {\n                    console.log(\"    \\uD83D\\uDCCA This is our balance address\");\n                } else {\n                    console.log(\"    ❓ Unknown signer - needs investigation\");\n                }\n            });\n            // Check what type of transaction we have and try to use Neon's direct serialization\n            console.log(\"\\uD83D\\uDD0D Transaction type analysis:\");\n            console.log(\"- Transaction constructor:\", scheduledTransaction.constructor.name);\n            console.log(\"- Has serialize method:\", typeof scheduledTransaction.serialize === \"function\");\n            console.log(\"- Has sign method:\", typeof scheduledTransaction.sign === \"function\");\n            console.log(\"- Has neonSubType:\", \"neonSubType\" in scheduledTransaction);\n            let signature;\n            if (typeof scheduledTransaction.serialize === \"function\" && \"neonSubType\" in scheduledTransaction) {\n                // This is a Neon ScheduledTransaction - try to use it directly like the test\n                console.log(\"✅ Detected Neon ScheduledTransaction - using direct serialization\");\n                console.log(\"Submitting transaction with Neon serialization...\");\n                signature = await this.connection.sendRawTransaction(scheduledTransaction.serialize());\n            } else {\n                // Fallback to wallet adapter signing\n                console.log(\"\\uD83D\\uDCDD Using wallet adapter signing fallback...\");\n                const signedTx = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n                console.log(\"Submitting transaction...\");\n                signature = await this.connection.sendRawTransaction(signedTx.serialize());\n            }\n            console.log(\"✅ Transaction submitted!\");\n            console.log(\"\\uD83D\\uDD17 Signature:\", signature);\n            // Wait a bit for processing (like working examples)\n            console.log(\"Waiting for confirmation...\");\n            await new Promise((resolve)=>setTimeout(resolve, 5000));\n            // Wait for transaction execution on Neon EVM\n            const transactionStatus = await this.proxyApi.waitTransactionTreeExecution(this.solanaUser.neonWallet, nonce, 60000 // 60 second timeout\n            );\n            console.log(\"Transaction status:\", transactionStatus);\n            if (transactionStatus.length === 0) {\n                throw new Error(\"No transaction status returned - transaction may not have been processed\");\n            }\n            const txStatus = transactionStatus[0];\n            console.log(\"Transaction execution status:\", txStatus.status);\n            if (txStatus.status === \"NotStarted\") {\n                console.warn(\"⚠️ Transaction was scheduled but not yet executed by Neon operators\");\n                console.log(\"This is expected - Neon will process it eventually\");\n                console.log(\"Transaction hash:\", txStatus.transactionHash);\n                // Since we have a transaction hash, proceed with using it as the payment link ID\n                // The transaction will be processed by Neon operators eventually\n                console.log(\"✅ Using transaction hash as payment link ID - Neon will process it when ready\");\n                return {\n                    linkId: txStatus.transactionHash,\n                    txHash: txStatus.transactionHash\n                };\n            } else if (txStatus.status === \"Failed\") {\n                throw new Error(\"Transaction execution failed. Hash: \".concat(txStatus.transactionHash));\n            } else if (txStatus.status !== \"Success\") {\n                console.warn(\"Transaction finished with unexpected status:\", txStatus.status);\n                // Still try to return the transaction hash in case it's usable\n                return {\n                    linkId: txStatus.transactionHash,\n                    txHash: txStatus.transactionHash\n                };\n            }\n            const txHash = transactionStatus[0].transactionHash;\n            console.log(\"Transaction hash:\", txHash);\n            // Get the link ID from transaction receipt\n            const receipt = await this.proxyApi.getTransactionReceipt(txHash);\n            console.log(\"Full transaction receipt:\", JSON.stringify(receipt, null, 2));\n            let linkId = \"\";\n            // Check if the transaction was successful\n            if (((_receipt_result = receipt.result) === null || _receipt_result === void 0 ? void 0 : _receipt_result.status) !== \"0x1\") {\n                var _receipt_result10;\n                throw new Error(\"Transaction failed - status: \" + ((_receipt_result10 = receipt.result) === null || _receipt_result10 === void 0 ? void 0 : _receipt_result10.status));\n            }\n            // Enhanced debugging of the receipt structure\n            console.log(\"Receipt status:\", (_receipt_result1 = receipt.result) === null || _receipt_result1 === void 0 ? void 0 : _receipt_result1.status);\n            console.log(\"Receipt logs array:\", (_receipt_result2 = receipt.result) === null || _receipt_result2 === void 0 ? void 0 : _receipt_result2.logs);\n            console.log(\"Receipt logs length:\", (_receipt_result3 = receipt.result) === null || _receipt_result3 === void 0 ? void 0 : (_receipt_result_logs = _receipt_result3.logs) === null || _receipt_result_logs === void 0 ? void 0 : _receipt_result_logs.length);\n            console.log(\"Receipt logsBloom:\", (_receipt_result4 = receipt.result) === null || _receipt_result4 === void 0 ? void 0 : _receipt_result4.logsBloom);\n            console.log(\"Receipt contractAddress:\", (_receipt_result5 = receipt.result) === null || _receipt_result5 === void 0 ? void 0 : _receipt_result5.contractAddress);\n            console.log(\"Receipt gasUsed:\", (_receipt_result6 = receipt.result) === null || _receipt_result6 === void 0 ? void 0 : _receipt_result6.gasUsed);\n            console.log(\"Receipt effectiveGasPrice:\", (_receipt_result7 = receipt.result) === null || _receipt_result7 === void 0 ? void 0 : _receipt_result7.effectiveGasPrice);\n            // Check if there's a different location for logs\n            console.log(\"Raw transaction data:\", (_receipt_result8 = receipt.result) === null || _receipt_result8 === void 0 ? void 0 : _receipt_result8.neonRawTransaction);\n            // Note: getTransaction method not available on NeonProxyRpcApi\n            // Transaction details are already in the receipt\n            // Extract all neonLogs from solanaTransactions\n            const allNeonLogs = [];\n            if ((_receipt_result9 = receipt.result) === null || _receipt_result9 === void 0 ? void 0 : _receipt_result9.solanaTransactions) {\n                for (const solTx of receipt.result.solanaTransactions){\n                    if (solTx.solanaInstructions) {\n                        for (const instruction of solTx.solanaInstructions){\n                            if (instruction.neonLogs && instruction.neonLogs.length > 0) {\n                                allNeonLogs.push(...instruction.neonLogs);\n                            }\n                        }\n                    }\n                }\n            }\n            console.log(\"Found\", allNeonLogs.length, \"neonLogs to parse\");\n            // Try to parse logs for the SolanaLinkCreated event\n            if (allNeonLogs.length > 0) {\n                for (const log of allNeonLogs){\n                    try {\n                        console.log(\"Trying to parse neonLog:\", log);\n                        // Check if this log is from our contract\n                        if (log.address.toLowerCase() === CONTRACT_ADDRESS.toLowerCase()) {\n                            console.log(\"Log is from our contract, parsing...\");\n                            // Convert the log to the format expected by ethers\n                            const ethersLog = {\n                                address: log.address,\n                                data: log.data,\n                                topics: log.topics\n                            };\n                            const parsedLog = iface.parseLog(ethersLog);\n                            console.log(\"Parsed log:\", parsedLog);\n                            if ((parsedLog === null || parsedLog === void 0 ? void 0 : parsedLog.name) === \"SolanaLinkCreated\") {\n                                linkId = parsedLog.args.linkId;\n                                console.log(\"✅ Found link ID from SolanaLinkCreated event:\", linkId);\n                                break;\n                            }\n                        } else {\n                            console.log(\"Log from different contract:\", log.address);\n                        }\n                    } catch (e) {\n                        console.log(\"Failed to parse neonLog:\", e);\n                    // Skip logs that can't be parsed\n                    }\n                }\n            } else {\n                console.warn(\"No neonLogs found in transaction receipt!\");\n                console.log(\"This might indicate:\");\n                console.log(\"1. The contract call failed silently\");\n                console.log(\"2. The contract is not at the expected address\");\n                console.log(\"3. The contract function call reverted\");\n                console.log(\"4. Events are not being emitted properly\");\n                // Try calling the contract read method to see if data was actually stored\n                try {\n                    console.log(\"Attempting to read payment link using transaction hash as ID...\");\n                    const testData = await this.contract.getSolanaPaymentLink(txHash);\n                    console.log(\"Contract read result:\", testData);\n                } catch (readError) {\n                    console.log(\"Contract read failed:\", readError);\n                }\n            }\n            // If we couldn't extract from logs, investigate further\n            if (!linkId) {\n                var _receipt_result11, _receipt_result12;\n                console.error(\"Could not extract link ID from transaction events!\");\n                console.log(\"This suggests the contract call may have failed silently\");\n                // Check if the transaction actually reverted\n                console.log(\"Checking for revert data...\");\n                if ((_receipt_result11 = receipt.result) === null || _receipt_result11 === void 0 ? void 0 : _receipt_result11.neonRevertData) {\n                    console.log(\"Revert data found:\", receipt.result.neonRevertData);\n                    try {\n                        // Try to decode the revert reason\n                        const revertReason = ethers__WEBPACK_IMPORTED_MODULE_6__.toUtf8String(receipt.result.neonRevertData);\n                        console.log(\"Revert reason:\", revertReason);\n                        throw new Error(\"Contract call reverted: \".concat(revertReason));\n                    } catch (decodeError) {\n                        console.log(\"Could not decode revert reason:\", decodeError);\n                        throw new Error(\"Contract call reverted with unknown reason\");\n                    }\n                }\n                // Let's try to understand why the event wasn't emitted\n                console.log(\"Analyzing function call...\");\n                console.log(\"Contract address:\", CONTRACT_ADDRESS);\n                console.log(\"From address:\", this.solanaUser.neonWallet);\n                console.log(\"Function data in raw tx:\", (_receipt_result12 = receipt.result) === null || _receipt_result12 === void 0 ? void 0 : _receipt_result12.neonRawTransaction);\n                // Check if user is registered\n                try {\n                    const isRegistered = await this.contract.isSolanaUser(this.solanaUser.neonWallet);\n                    console.log(\"Is user registered as Solana user:\", isRegistered);\n                    if (!isRegistered) {\n                        throw new Error(\"User is not registered as a Solana user with the contract. This is required to create payment links.\");\n                    }\n                } catch (registrationError) {\n                    console.error(\"Failed to check user registration:\", registrationError);\n                    throw registrationError;\n                }\n                // If we get here, something else went wrong\n                throw new Error(\"Payment link creation failed: Contract call executed but no event was emitted. The transaction may have failed silently.\");\n            }\n            return {\n                linkId,\n                txHash\n            };\n        } catch (error) {\n            console.error(\"Error creating payment link:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Initialize read-only contract access (without wallet)\n   */ async initReadOnlyContract() {\n        if (!this.contract) {\n            // Create a simple JSON RPC provider for read operations\n            const readOnlyProvider = new ethers__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider(NEON_CORE_RPC_URL);\n            this.contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.Contract(CONTRACT_ADDRESS, SOLANA_TIPCARD_ABI, readOnlyProvider);\n        }\n    }\n    /**\n   * Get payment link details\n   */ async getPaymentLink(linkId) {\n        // Initialize contract if not already done\n        if (!this.contract) {\n            await this.initReadOnlyContract();\n        }\n        console.log(\"Getting payment link with ID:\", linkId);\n        console.log(\"Contract address:\", CONTRACT_ADDRESS);\n        try {\n            const result = await this.contract.getSolanaPaymentLink(linkId);\n            console.log(\"Raw contract result:\", result);\n            const paymentLink = {\n                evmCreator: result.evmCreator,\n                solanaCreator: result.solanaCreator,\n                amount: result.amount,\n                isFlexible: result.isFlexible,\n                isActive: result.isActive,\n                totalReceived: result.totalReceived,\n                paymentCount: Number(result.paymentCount),\n                description: result.description\n            };\n            // Check if this looks like an empty/non-existent link (transaction not processed yet)\n            if (result.evmCreator === \"0x0000000000000000000000000000000000000000\" && result.amount === BigInt(0) && !result.isActive) {\n                console.warn(\"Payment link appears to be empty/non-existent\");\n                // If this looks like a transaction hash (66 chars, starts with 0x), provide helpful info\n                if (linkId.length === 66 && linkId.startsWith(\"0x\")) {\n                    console.log(\"\\uD83D\\uDCA1 This appears to be a transaction hash - the payment link may still be processing\");\n                    console.log(\"\\uD83D\\uDCA1 Neon operators will eventually process this transaction and create the payment link\");\n                    console.log(\"\\uD83D\\uDCA1 You can bookmark this link and try again in a few minutes\");\n                    // For now, don't throw an error - let the UI handle the empty data gracefully\n                    console.log(\"Returning empty payment link data - transaction may still be processing\");\n                }\n            }\n            return paymentLink;\n        } catch (error) {\n            console.error(\"Contract call error:\", error);\n            throw new Error(\"Payment link not found or contract error\");\n        }\n    }\n    /**\n   * Get user's payment links\n   */ async getUserLinks(userEVMAddress) {\n        // Initialize contract if not already done\n        if (!this.contract) {\n            await this.initReadOnlyContract();\n        }\n        try {\n            return await this.contract.getUserSolanaLinks(userEVMAddress);\n        } catch (error) {\n            console.error(\"Error getting user links:\", error);\n            return [];\n        }\n    }\n    /**\n   * Pay a payment link using Solana Native SDK\n   */ async payLink(linkId, amountSOL) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        console.log(\"Starting payment process...\");\n        console.log(\"Link ID:\", linkId);\n        console.log(\"Amount SOL:\", amountSOL);\n        // First, get the payment link details to find the recipient\n        const linkData = await this.getPaymentLink(linkId);\n        console.log(\"Payment link data:\", linkData);\n        if (!linkData.isActive) {\n            throw new Error(\"Payment link is no longer active\");\n        }\n        // Convert SOL to lamports\n        const amountLamports = Math.floor(amountSOL * 1e9);\n        let transferSignature;\n        try {\n            var _hexString_match, _transactionStatus_, _transactionStatus_1;\n            // Step 1: Perform the actual SOL transfer first\n            console.log(\"Step 1: Performing SOL transfer...\");\n            console.log(\"From:\", this.solanaUser.publicKey.toBase58());\n            console.log(\"To recipient bytes32:\", linkData.solanaCreator);\n            console.log(\"Amount lamports:\", amountLamports);\n            // Convert recipient Solana address from bytes32 to PublicKey\n            // Remove '0x' prefix if present\n            const hexString = linkData.solanaCreator.startsWith(\"0x\") ? linkData.solanaCreator.slice(2) : linkData.solanaCreator;\n            // Convert hex string to byte array\n            const bytes = new Uint8Array(((_hexString_match = hexString.match(/.{2}/g)) === null || _hexString_match === void 0 ? void 0 : _hexString_match.map((byte)=>parseInt(byte, 16))) || []);\n            // For bytes32 from Solana addresses, we need to find the actual 32-byte public key\n            // The bytes32 should contain the 32-byte Solana public key, possibly with leading zeros\n            let recipientPubkey;\n            if (bytes.length === 32) {\n                // Direct conversion from 32 bytes\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(bytes);\n            } else if (bytes.length > 32) {\n                // Take the last 32 bytes if it's longer\n                const last32Bytes = bytes.slice(-32);\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(last32Bytes);\n            } else {\n                // Pad with leading zeros if shorter\n                const paddedBytes = new Uint8Array(32);\n                paddedBytes.set(bytes, 32 - bytes.length);\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(paddedBytes);\n            }\n            console.log(\"Recipient PublicKey:\", recipientPubkey.toBase58());\n            // Create the SOL transfer transaction\n            const { SystemProgram, Transaction } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"));\n            // Create transfer instruction\n            const transferIx = SystemProgram.transfer({\n                fromPubkey: this.solanaUser.publicKey,\n                toPubkey: recipientPubkey,\n                lamports: amountLamports\n            });\n            // Create transaction\n            const transferTx = new Transaction().add(transferIx);\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for SOL transfer...\");\n            const { blockhash, lastValidBlockHeight: transferBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh SOL transfer blockhash:\", blockhash);\n            console.log(\"Last valid block height:\", transferBlockHeight);\n            transferTx.recentBlockhash = blockhash;\n            transferTx.feePayer = this.solanaUser.publicKey;\n            // Sign and send the SOL transfer immediately\n            console.log(\"Signing and sending SOL transfer with fresh blockhash...\");\n            const signedTransferTx = await this.solanaUser.walletAdapter.signTransaction(transferTx);\n            transferSignature = await this.connection.sendRawTransaction(signedTransferTx.serialize());\n            console.log(\"SOL transfer sent:\", transferSignature);\n            // Wait for transfer confirmation using the modern API\n            await this.connection.confirmTransaction({\n                signature: transferSignature,\n                ...await this.connection.getLatestBlockhash()\n            });\n            console.log(\"SOL transfer confirmed\");\n            // Step 2: Record the payment in the contract\n            console.log(\"Step 2: Recording payment in contract...\");\n            // Convert Solana PublicKey to bytes32\n            const payerSolanaBytes32 = (0,ethers__WEBPACK_IMPORTED_MODULE_7__.zeroPadValue)((0,ethers__WEBPACK_IMPORTED_MODULE_7__.hexlify)(this.solanaUser.publicKey.toBytes()), 32);\n            // Get current nonce\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Current nonce:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"paySolanaLink\", [\n                linkId,\n                amountLamports,\n                payerSolanaBytes32\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for contract call...\");\n            const { blockhash: contractBlockhash, lastValidBlockHeight: contractBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh contract call blockhash:\", contractBlockhash);\n            console.log(\"Last valid block height:\", contractBlockHeight);\n            scheduledTransaction.recentBlockhash = contractBlockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            // Sign with wallet adapter instead of keypair (like in tests)\n            // In tests: scheduledTransaction.sign({ publicKey: solanaUser.publicKey, secretKey: solanaUser.keypair.secretKey })\n            // In frontend: use wallet adapter signing\n            console.log(\"Signing contract call with fresh blockhash...\");\n            const signedTx = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            // Send transaction immediately\n            console.log(\"Sending contract call transaction immediately...\");\n            await this.connection.sendRawTransaction(signedTx.serialize());\n            // Wait for transaction execution on Neon EVM\n            const transactionStatus = await this.proxyApi.waitTransactionTreeExecution(this.solanaUser.neonWallet, nonce, 60000);\n            if (transactionStatus.length === 0 || transactionStatus[0].status !== \"Success\") {\n                console.warn(\"Contract payment recording failed, but SOL transfer succeeded\");\n                console.log(\"Transfer signature:\", transferSignature);\n            // Don't throw error - the payment went through even if recording failed\n            }\n            console.log(\"Payment completed successfully!\");\n            console.log(\"SOL transfer:\", transferSignature);\n            console.log(\"Contract record:\", (_transactionStatus_ = transactionStatus[0]) === null || _transactionStatus_ === void 0 ? void 0 : _transactionStatus_.transactionHash);\n            return {\n                txHash: ((_transactionStatus_1 = transactionStatus[0]) === null || _transactionStatus_1 === void 0 ? void 0 : _transactionStatus_1.transactionHash) || \"contract-recording-failed\",\n                transferSignature\n            };\n        } catch (error) {\n            console.error(\"Error paying link:\", error);\n            if (transferSignature) {\n                console.log(\"Note: SOL transfer may have succeeded:\", transferSignature);\n            }\n            throw error;\n        }\n    }\n    /**\n   * Deactivate a payment link\n   */ async deactivateLink(linkId) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        try {\n            // Get current nonce\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Current nonce:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"deactivateSolanaLink\", [\n                linkId\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for deactivate transaction...\");\n            const { blockhash, lastValidBlockHeight: deactivateBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh deactivate blockhash:\", blockhash);\n            console.log(\"Last valid block height:\", deactivateBlockHeight);\n            scheduledTransaction.recentBlockhash = blockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            // Sign with wallet adapter instead of keypair (like in tests)\n            // In tests: scheduledTransaction.sign({ publicKey: solanaUser.publicKey, secretKey: solanaUser.keypair.secretKey })\n            // In frontend: use wallet adapter signing\n            console.log(\"Signing deactivate transaction with fresh blockhash...\");\n            const signedTx = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            // Send transaction immediately\n            console.log(\"Sending deactivate transaction immediately...\");\n            await this.connection.sendRawTransaction(signedTx.serialize());\n            // Wait for transaction execution\n            const transactionStatus = await this.proxyApi.waitTransactionTreeExecution(this.solanaUser.neonWallet, nonce, 60000);\n            if (transactionStatus.length === 0 || transactionStatus[0].status !== \"Success\") {\n                throw new Error(\"Deactivation transaction failed to execute on Neon EVM\");\n            }\n            return {\n                txHash: transactionStatus[0].transactionHash\n            };\n        } catch (error) {\n            throw error;\n        }\n    }\n    /**\n   * Create a shareable URL for a payment link\n   */ createPaymentURL(linkId) {\n        return \"\".concat(window.location.origin, \"?pay=\").concat(linkId);\n    }\n    /**\n   * Extract link ID from URL\n   */ static extractLinkIdFromURL(url) {\n        try {\n            const urlObj = new URL(url);\n            return urlObj.searchParams.get(\"pay\");\n        } catch (e) {\n            return null;\n        }\n    }\n    /**\n   * Get the user's EVM address derived from Solana public key\n   */ getUserEVMAddress() {\n        var _this_solanaUser;\n        return ((_this_solanaUser = this.solanaUser) === null || _this_solanaUser === void 0 ? void 0 : _this_solanaUser.neonWallet) || null;\n    }\n    constructor(){\n        this.chainId = null;\n        this.contract = null;\n        this.connection = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Connection(SOLANA_RPC_URL, \"confirmed\");\n        this.proxyApi = new _neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__.NeonProxyRpcApi(NEON_PROXY_RPC_URL);\n    }\n}\n// Export singleton instance\nconst solanaNativeContract = new SolanaNativeContract();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3NvbGFuYS1uYXRpdmUtY29udHJhY3QudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFnRTtBQUMwQztBQUNwRDtBQUNWO0FBRTVDLHVDQUF1QztBQUN2QyxNQUFNUSxxQkFBcUJELDhDQUFXQTtBQUV0QyxNQUFNRSxtQkFBbUJDLDRDQUFnRCxJQUFJO0FBQzdFLE1BQU1HLG9CQUFvQkgsNEJBQW9DLElBQUk7QUFDbEUsTUFBTUsscUJBQXFCLEdBQXFCLE9BQWxCRixtQkFBa0I7QUFDaEQsTUFBTUcsaUJBQWlCO0FBYWhCLE1BQU1DO0lBWVg7O0dBRUMsR0FDRCxNQUFjQyxhQUE4QjtRQUMxQyxJQUFJO1lBQ0YsNkNBQTZDO1lBQzdDLE1BQU1DLFdBQVcsTUFBTUMsTUFBTUwsb0JBQW9CO2dCQUMvQ00sUUFBUTtnQkFDUkMsU0FBUztvQkFBRSxnQkFBZ0I7Z0JBQW1CO2dCQUM5Q0MsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO29CQUNuQkMsSUFBSTtvQkFDSkMsU0FBUztvQkFDVE4sUUFBUTtvQkFDUk8sUUFBUSxFQUFFO2dCQUNaO1lBQ0Y7WUFDQSxNQUFNQyxTQUFTLE1BQU1WLFNBQVNXLElBQUk7WUFDbEMsT0FBT0MsU0FBU0YsT0FBT0EsTUFBTSxFQUFFLElBQUkseUJBQXlCOztRQUM5RCxFQUFFLE9BQU9HLE9BQU87WUFDZEMsUUFBUUMsSUFBSSxDQUFDLDBDQUEwQ0Y7WUFDdkQsT0FBTyxVQUFVLHNCQUFzQjs7UUFDekM7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBY0csb0JBQXdDO1FBQ3BELElBQUk7Z0JBV0VDO1lBVkpILFFBQVFJLEdBQUcsQ0FBQztZQUVaLGlFQUFpRTtZQUNqRSxNQUFNLEVBQUVDLE9BQU8sRUFBRSxHQUFHLE1BQU0sMExBQU87WUFDakMsTUFBTUMsY0FBY0QsUUFBUUUsUUFBUTtZQUVwQyxtREFBbUQ7WUFDbkQsTUFBTUosYUFBYSxNQUFNLElBQUksQ0FBQ0ssUUFBUSxDQUFD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LEdBQVcsRUFBaUI7UUFDdEQsSUFBSTtZQUNGLE1BQU1DLFNBQVMsSUFBSUMsSUFBSUY7WUFDdkIsT0FBT0MsT0FBT0UsWUFBWSxDQUFDQyxHQUFHLENBQUM7UUFDakMsRUFBRSxVQUFNO1lBQ04sT0FBTztRQUNUO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEQyxvQkFBbUM7WUFDMUI7UUFBUCxPQUFPLHlCQUFJLENBQUMvSyxVQUFVLGNBQWYsd0RBQWlCYSxVQUFVLEtBQUk7SUFDeEM7SUFoM0JBd0QsYUFBYzthQUhOMUQsVUFBeUI7YUFDekJNLFdBQW1DO1FBR3pDLElBQUksQ0FBQ2dDLFVBQVUsR0FBRyxJQUFJNUYsdURBQVVBLENBQUNnQixnQkFBZ0I7UUFDakQsSUFBSSxDQUFDeUIsUUFBUSxHQUFHLElBQUl2QyxpRUFBZUEsQ0FBQ2E7SUFDdEM7QUE4MkJGO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU00TSx1QkFBdUIsSUFBSTFNLHVCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy9zb2xhbmEtbmF0aXZlLWNvbnRyYWN0LnRzP2Q0YzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29ubmVjdGlvbiwgUHVibGljS2V5LCBLZXlwYWlyIH0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJ1xuaW1wb3J0IHsgTmVvblByb3h5UnBjQXBpLCBjcmVhdGVCYWxhbmNlQWNjb3VudEluc3RydWN0aW9uLCBTb2xhbmFOZW9uQWNjb3VudCB9IGZyb20gJ0BuZW9uZXZtL3NvbGFuYS1zaWduJ1xuaW1wb3J0IHsgZXRoZXJzLCBoZXhsaWZ5LCB6ZXJvUGFkVmFsdWUgfSBmcm9tICdldGhlcnMnXG5pbXBvcnQgQ29udHJhY3RBQkkgZnJvbSAnLi9jb250cmFjdEFCSS5qc29uJ1xuXG4vLyBVc2UgdGhlIGFjdHVhbCBkZXBsb3llZCBjb250cmFjdCBBQklcbmNvbnN0IFNPTEFOQV9USVBDQVJEX0FCSSA9IENvbnRyYWN0QUJJXG5cbmNvbnN0IENPTlRSQUNUX0FERFJFU1MgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19USVBDQVJEX0NPTlRSQUNUX0FERFJFU1MgfHwgJzB4Q0ZFMDNjN2M2NzQ1NkQwOTRDMDE2MkY5MDMwMzkzRkMyY0NjNDBDYidcbmNvbnN0IE5FT05fQ09SRV9SUENfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfTkVPTl9SUENfVVJMIHx8ICdodHRwczovL2Rldm5ldC5uZW9uZXZtLm9yZydcbmNvbnN0IE5FT05fUFJPWFlfUlBDX1VSTCA9IGAke05FT05fQ09SRV9SUENfVVJMfS9zb2xgXG5jb25zdCBTT0xBTkFfUlBDX1VSTCA9ICdodHRwczovL2FwaS5kZXZuZXQuc29sYW5hLmNvbSdcblxuZXhwb3J0IGludGVyZmFjZSBQYXltZW50TGluayB7XG4gIGV2bUNyZWF0b3I6IHN0cmluZ1xuICBzb2xhbmFDcmVhdG9yOiBzdHJpbmdcbiAgYW1vdW50OiBiaWdpbnRcbiAgaXNGbGV4aWJsZTogYm9vbGVhblxuICBpc0FjdGl2ZTogYm9vbGVhblxuICB0b3RhbFJlY2VpdmVkOiBiaWdpbnRcbiAgcGF5bWVudENvdW50OiBudW1iZXJcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xufVxuXG5leHBvcnQgY2xhc3MgU29sYW5hTmF0aXZlQ29udHJhY3Qge1xuICBwcml2YXRlIGNvbm5lY3Rpb246IENvbm5lY3Rpb25cbiAgcHJpdmF0ZSBwcm94eUFwaTogTmVvblByb3h5UnBjQXBpXG4gIHByaXZhdGUgc29sYW5hVXNlcjogYW55XG4gIHByaXZhdGUgY2hhaW5JZDogbnVtYmVyIHwgbnVsbCA9IG51bGxcbiAgcHJpdmF0ZSBjb250cmFjdDogZXRoZXJzLkNvbnRyYWN0IHwgbnVsbCA9IG51bGxcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdGlvbihTT0xBTkFfUlBDX1VSTCwgJ2NvbmZpcm1lZCcpXG4gICAgdGhpcy5wcm94eUFwaSA9IG5ldyBOZW9uUHJveHlScGNBcGkoTkVPTl9QUk9YWV9SUENfVVJMKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBOZW9uIEVWTSBjaGFpbiBJRFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZXRDaGFpbklkKCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFVzZSB0aGUgcHJveHkgQVBJIHRvIGdldCBjaGFpbiBpbmZvcm1hdGlvblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChORU9OX1BST1hZX1JQQ19VUkwsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgbWV0aG9kOiAnZXRoX2NoYWluSWQnLFxuICAgICAgICAgIHBhcmFtczogW11cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgIHJldHVybiBwYXJzZUludChyZXN1bHQucmVzdWx0LCAxNikgLy8gQ29udmVydCBoZXggdG8gZGVjaW1hbFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBnZXQgY2hhaW4gSUQsIHVzaW5nIGRlZmF1bHQ6JywgZXJyb3IpXG4gICAgICByZXR1cm4gMjQ1MDIyOTI3IC8vIE5lb24gRGV2bmV0IGRlZmF1bHRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IE5lb24gRVZNIHByb2dyYW0gYWRkcmVzcyB1c2luZyBhIHRlbXBvcmFyeSBpbml0aWFsaXphdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZXROZW9uRXZtUHJvZ3JhbSgpOiBQcm9taXNlPFB1YmxpY0tleT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnQXR0ZW1wdGluZyB0byBnZXQgTmVvbiBFVk0gcHJvZ3JhbSB2aWEgdGVtcG9yYXJ5IGtleXBhaXIgaW5pdGlhbGl6YXRpb24uLi4nKVxuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSB0ZW1wb3Jhcnkga2V5cGFpciBqdXN0IHRvIGdldCB0aGUgcHJvZ3JhbSBpbmZvcm1hdGlvblxuICAgICAgY29uc3QgeyBLZXlwYWlyIH0gPSBhd2FpdCBpbXBvcnQoJ0Bzb2xhbmEvd2ViMy5qcycpXG4gICAgICBjb25zdCB0ZW1wS2V5cGFpciA9IEtleXBhaXIuZ2VuZXJhdGUoKVxuICAgICAgXG4gICAgICAvLyBVc2UgdGhlIGV4aXN0aW5nIHByb3h5QXBpIHRvIGdldCB0aGUgaW5mb3JtYXRpb25cbiAgICAgIGNvbnN0IGluaXRSZXN1bHQgPSBhd2FpdCB0aGlzLnByb3h5QXBpLmluaXQodGVtcEtleXBhaXIpXG4gICAgICBjb25zb2xlLmxvZygnVGVtcG9yYXJ5IGluaXQgcmVzdWx0OicsIGluaXRSZXN1bHQpXG4gICAgICBcbiAgICAgIGlmIChpbml0UmVzdWx0LnNvbGFuYVVzZXI/Lm5lb25Fdm1Qcm9ncmFtKSB7XG4gICAgICAgIHJldHVybiBpbml0UmVzdWx0LnNvbGFuYVVzZXIubmVvbkV2bVByb2dyYW1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gbmVvbkV2bVByb2dyYW0gaW4gaW5pdCByZXN1bHQnKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1RlbXBvcmFyeSBpbml0IGZhaWxlZCwgdHJ5aW5nIGRpcmVjdCBBUEkgY2FsbDonLCBlcnJvcilcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gZGlyZWN0IEFQSSBjYWxsXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goTkVPTl9QUk9YWV9SUENfVVJMLCB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgIG1ldGhvZDogJ25lb25fZ2V0RXZtUGFyYW1zJyxcbiAgICAgICAgICAgIHBhcmFtczogW11cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKCdEaXJlY3QgQVBJIHJlc3BvbnNlOicsIHJlc3VsdClcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGRpZmZlcmVudCBwb3NzaWJsZSByZXNwb25zZSBzdHJ1Y3R1cmVzXG4gICAgICAgIGxldCBwcm9ncmFtQWRkcmVzc1xuICAgICAgICBpZiAocmVzdWx0LnJlc3VsdD8ubmVvbkV2bVByb2dyYW0pIHtcbiAgICAgICAgICBwcm9ncmFtQWRkcmVzcyA9IHJlc3VsdC5yZXN1bHQubmVvbkV2bVByb2dyYW1cbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQucmVzdWx0Py5wcm9ncmFtSWQpIHtcbiAgICAgICAgICBwcm9ncmFtQWRkcmVzcyA9IHJlc3VsdC5yZXN1bHQucHJvZ3JhbUlkXG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LnJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0LnJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBwcm9ncmFtQWRkcmVzcyA9IHJlc3VsdC5yZXN1bHRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgcmVzcG9uc2Ugc3RydWN0dXJlJylcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coJ0V4dHJhY3RlZCBwcm9ncmFtIGFkZHJlc3M6JywgcHJvZ3JhbUFkZHJlc3MpXG4gICAgICAgIHJldHVybiBuZXcgUHVibGljS2V5KHByb2dyYW1BZGRyZXNzKVxuICAgICAgfSBjYXRjaCAoYXBpRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdEaXJlY3QgQVBJIGNhbGwgYWxzbyBmYWlsZWQsIHVzaW5nIGRlZmF1bHQ6JywgYXBpRXJyb3IpXG4gICAgICAgIC8vIERlZmF1bHQgTmVvbiBFVk0gcHJvZ3JhbSBmb3IgZGV2bmV0XG4gICAgICAgIHJldHVybiBuZXcgUHVibGljS2V5KCdlZUxTSmdXenp4cnFLdjFVeHRSVlZIOEZYM3FDUVdVczlRdUFqSnBFVEdTbScpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgd2l0aCBTb2xhbmEgd2FsbGV0IHVzaW5nIHRoZSByZWNvbW1lbmRlZCBTb2xhbmFOZW9uQWNjb3VudCBhcHByb2FjaFxuICAgKi9cbiAgYXN5bmMgaW5pdFdpdGhTb2xhbmFXYWxsZXQod2FsbGV0QWRhcHRlcjogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF3YWxsZXRBZGFwdGVyLnB1YmxpY0tleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGNvbm5lY3RlZCcpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SnIFVzaW5nIHJlY29tbWVuZGVkIFNvbGFuYU5lb25BY2NvdW50IGFwcHJvYWNoLi4uJylcbiAgICAgIGNvbnNvbGUubG9nKCdXYWxsZXQgcHVibGljIGtleTonLCB3YWxsZXRBZGFwdGVyLnB1YmxpY0tleS50b0Jhc2U1OCgpKVxuICAgICAgXG4gICAgICAvLyBVc2UgcHJveHlBcGkuaW5pdCB3aXRoIGp1c3QgdGhlIHB1YmxpYyBrZXkgKGxpa2UgZGVtbylcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIHNvbGFuYVVzZXIsXG4gICAgICAgIHRva2VuTWludEFkZHJlc3MsXG4gICAgICAgIHByb2dyYW1BZGRyZXNzXG4gICAgICB9ID0gYXdhaXQgdGhpcy5wcm94eUFwaS5pbml0KHdhbGxldEFkYXB0ZXIucHVibGljS2V5KVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnLSBDaGFpbiBJRDonLCBjaGFpbklkKVxuICAgICAgY29uc29sZS5sb2coJy0gTmVvbiBFVk0gUHJvZ3JhbTonLCBwcm9ncmFtQWRkcmVzcy50b0Jhc2U1OCgpKVxuICAgICAgXG4gICAgICAvLyBTdG9yZSB0aGUgcmVzdWx0IHdpdGggd2FsbGV0IGFkYXB0ZXIgZm9yIHNpZ25pbmdcbiAgICAgIHRoaXMuY2hhaW5JZCA9IGNoYWluSWRcbiAgICAgIHRoaXMuc29sYW5hVXNlciA9IHtcbiAgICAgICAgLi4uc29sYW5hVXNlcixcbiAgICAgICAgd2FsbGV0QWRhcHRlcjogd2FsbGV0QWRhcHRlciAvLyBBZGQgd2FsbGV0IGFkYXB0ZXIgZm9yIHNpZ25pbmdcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ+KchSBXYWxsZXQgaW5pdGlhbGl6ZWQgdXNpbmcgdGVzdCBwYXR0ZXJuIScpXG4gICAgICBjb25zb2xlLmxvZygn8J+TjSBDb25uZWN0ZWQgd2FsbGV0IHB1YmxpYyBrZXk6Jywgd2FsbGV0QWRhcHRlci5wdWJsaWNLZXkudG9CYXNlNTgoKSlcbiAgICAgIGNvbnNvbGUubG9nKCfwn5ONIFNvbGFuYSB1c2VyIHB1YmxpYyBrZXk6JywgdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleS50b0Jhc2U1OCgpKVxuICAgICAgY29uc29sZS5sb2coJ/Cfk40gRGVyaXZlZCBFVk0gYWRkcmVzczonLCB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldClcbiAgICAgIGNvbnNvbGUubG9nKCfwn5KwIEJhbGFuY2UgYWRkcmVzczonLCB0aGlzLnNvbGFuYVVzZXIuYmFsYW5jZUFkZHJlc3MudG9CYXNlNTgoKSlcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IHRoZXkgbWF0Y2hcbiAgICAgIGlmICh3YWxsZXRBZGFwdGVyLnB1YmxpY0tleS50b0Jhc2U1OCgpID09PSB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LnRvQmFzZTU4KCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBXYWxsZXQgcHVibGljIGtleXMgbWF0Y2ggY29ycmVjdGx5IScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgTUlTTUFUQ0g6IFdhbGxldCBhZGFwdGVyIGFuZCBzb2xhbmEgdXNlciBoYXZlIGRpZmZlcmVudCBwdWJsaWMga2V5cyEnKVxuICAgICAgICBjb25zb2xlLmVycm9yKCdXYWxsZXQgYWRhcHRlcjonLCB3YWxsZXRBZGFwdGVyLnB1YmxpY0tleS50b0Jhc2U1OCgpKVxuICAgICAgICBjb25zb2xlLmVycm9yKCdTb2xhbmEgdXNlcjonLCB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LnRvQmFzZTU4KCkpXG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZygnU29sYW5hIFVzZXIgQmFsYW5jZSBBZGRyZXNzOicsIHRoaXMuc29sYW5hVXNlci5iYWxhbmNlQWRkcmVzcy50b0Jhc2U1OCgpKVxuXG4gICAgICAvLyBDcmVhdGUgY29udHJhY3QgaW5zdGFuY2VcbiAgICAgIGNvbnN0IHJlYWRPbmx5UHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihORU9OX0NPUkVfUlBDX1VSTClcbiAgICAgIHRoaXMuY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KENPTlRSQUNUX0FERFJFU1MsIFNPTEFOQV9USVBDQVJEX0FCSSwgcmVhZE9ubHlQcm92aWRlcilcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IHRoZSBkZXJpdmVkIEVWTSBhZGRyZXNzIGlzIHZhbGlkXG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBWZXJpZnlpbmcgZGVyaXZlZCBFVk0gYWRkcmVzcy4uLicpXG4gICAgICB0cnkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIEVWTSBhZGRyZXNzIGhhcyBiZWVuIHVzZWQgYmVmb3JlIChoYXMgdHJhbnNhY3Rpb24gaGlzdG9yeSlcbiAgICAgICAgY29uc3QgdHhDb3VudCA9IGF3YWl0IHJlYWRPbmx5UHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25Db3VudCh0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldClcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk4ogRVZNIGFkZHJlc3MgdHJhbnNhY3Rpb24gY291bnQ6JywgdHhDb3VudClcbiAgICAgICAgXG4gICAgICAgIGlmICh0eENvdW50ID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgVGhpcyBFVk0gYWRkcmVzcyBoYXMgdHJhbnNhY3Rpb24gaGlzdG9yeSAtIGl0IGV4aXN0cyBvbi1jaGFpbiEnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfihLnvuI8gVGhpcyBFVk0gYWRkcmVzcyBpcyBuZXcgKG5vIHRyYW5zYWN0aW9uIGhpc3RvcnkgeWV0KScpXG4gICAgICAgICAgY29uc29sZS5sb2coJ+KEue+4jyBUaGUgYWRkcmVzcyB3aWxsIGJlIHJlZ2lzdGVyZWQgb24tY2hhaW4gd2hlbiBmaXJzdCB0cmFuc2FjdGlvbiBpcyBtYWRlJylcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAodmVyaWZ5RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KaoO+4jyBDb3VsZCBub3QgdmVyaWZ5IEVWTSBhZGRyZXNzOicsIHZlcmlmeUVycm9yKVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBWZXJpZnkgY29udHJhY3QgaXMgZGVwbG95ZWQgYXQgdGhpcyBhZGRyZXNzXG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZygnVmVyaWZ5aW5nIGNvbnRyYWN0IGF0IGFkZHJlc3M6JywgQ09OVFJBQ1RfQUREUkVTUylcbiAgICAgICAgY29uc3QgY29kZSA9IGF3YWl0IHJlYWRPbmx5UHJvdmlkZXIuZ2V0Q29kZShDT05UUkFDVF9BRERSRVNTKVxuICAgICAgICBjb25zb2xlLmxvZygnQ29udHJhY3QgY29kZSBsZW5ndGg6JywgY29kZS5sZW5ndGgpXG4gICAgICAgIGlmIChjb2RlID09PSAnMHgnKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gTm8gY29udHJhY3QgY29kZSBmb3VuZCBhdCBhZGRyZXNzOicsIENPTlRSQUNUX0FERFJFU1MpXG4gICAgICAgICAgY29uc29sZS5sb2coJ1RoaXMgbWlnaHQgbWVhbiB0aGUgY29udHJhY3QgaXMgbm90IGRlcGxveWVkIG9yIGFkZHJlc3MgaXMgaW5jb3JyZWN0JylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIENvbnRyYWN0IGZvdW5kIGF0IGFkZHJlc3MnKVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgQ29udHJhY3QgZm91bmQgYW5kIHJlYWR5IGZvciB0cmFuc2FjdGlvbnMnKVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoICh2ZXJpZnlFcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byB2ZXJpZnkgY29udHJhY3Q6JywgdmVyaWZ5RXJyb3IpXG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgU29sYW5hIE5hdGl2ZSBTREs6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBwYXltZW50IGxpbmsgdXNpbmcgU29sYW5hIE5hdGl2ZSBTREtcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVBheW1lbnRMaW5rKFxuICAgIHN1Z2dlc3RlZEFtb3VudFNPTDogbnVtYmVyLFxuICAgIGlzRmxleGlibGU6IGJvb2xlYW4sXG4gICAgZGVzY3JpcHRpb246IHN0cmluZ1xuICApOiBQcm9taXNlPHsgbGlua0lkOiBzdHJpbmc7IHR4SGFzaDogc3RyaW5nIH0+IHtcbiAgICBpZiAoIXRoaXMuc29sYW5hVXNlciB8fCAhdGhpcy5jb250cmFjdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgY29ubmVjdCB3YWxsZXQgZmlyc3QnKVxuICAgIH1cblxuICAgIC8vIENvbnZlcnQgU09MIHRvIGxhbXBvcnRzICgxIFNPTCA9IDFlOSBsYW1wb3J0cylcbiAgICBjb25zdCBhbW91bnRMYW1wb3J0cyA9IE1hdGguZmxvb3Ioc3VnZ2VzdGVkQW1vdW50U09MICogMWU5KVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBjdXJyZW50IG5vbmNlIChleGFjdGx5IGxpa2Ugd29ya2luZyBleGFtcGxlcylcbiAgICAgIGNvbnN0IG5vbmNlID0gTnVtYmVyKGF3YWl0IHRoaXMucHJveHlBcGkuZ2V0VHJhbnNhY3Rpb25Db3VudCh0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCkpXG4gICAgICBjb25zb2xlLmxvZygnQ3VycmVudCBub25jZTonLCBub25jZSlcblxuICAgICAgLy8gUHJlcGFyZSBjb250cmFjdCBjYWxsIGRhdGFcbiAgICAgIGNvbnN0IGlmYWNlID0gbmV3IGV0aGVycy5JbnRlcmZhY2UoU09MQU5BX1RJUENBUkRfQUJJKVxuICAgICAgY29uc3QgZGF0YSA9IGlmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YSgnY3JlYXRlU29sYW5hUGF5bWVudExpbmsnLCBbXG4gICAgICAgIGFtb3VudExhbXBvcnRzLFxuICAgICAgICBpc0ZsZXhpYmxlLFxuICAgICAgICBkZXNjcmlwdGlvblxuICAgICAgXSlcblxuICAgICAgLy8gQ3JlYXRlIHRyYW5zYWN0aW9uIGRhdGFcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uRGF0YSA9IHtcbiAgICAgICAgZnJvbTogdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsXG4gICAgICAgIHRvOiBDT05UUkFDVF9BRERSRVNTLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9XG5cbiAgICAgIC8vIERlYnVnOiBDaGVjayB3aGF0IHNvbGFuYVBheWVyIHdlJ3JlIHVzaW5nXG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBUcmFuc2FjdGlvbiBjcmVhdGlvbiBkZWJ1ZzonKVxuICAgICAgY29uc29sZS5sb2coJy0gc29sYW5hUGF5ZXIgZm9yIGdhcyBlc3RpbWF0aW9uOicsIHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXkudG9CYXNlNTgoKSlcbiAgICAgIGNvbnNvbGUubG9nKCctIGZyb20gYWRkcmVzcyBpbiB0cmFuc2FjdGlvbkRhdGE6JywgdHJhbnNhY3Rpb25EYXRhLmZyb20pXG4gICAgICBjb25zb2xlLmxvZygnLSBub25jZTonLCBub25jZSlcblxuICAgICAgLy8gRXN0aW1hdGUgZ2FzXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkdhcyA9IGF3YWl0IHRoaXMucHJveHlBcGkuZXN0aW1hdGVTY2hlZHVsZWRUcmFuc2FjdGlvbkdhcyh7XG4gICAgICAgIHNvbGFuYVBheWVyOiB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LFxuICAgICAgICB0cmFuc2FjdGlvbnM6IFt0cmFuc2FjdGlvbkRhdGFdLFxuICAgICAgfSlcblxuICAgICAgY29uc29sZS5sb2coJ0dhcyBlc3RpbWF0aW9uIGNvbXBsZXRlZCcpXG5cbiAgICAgIC8vIENyZWF0ZSBzY2hlZHVsZWQgdHJhbnNhY3Rpb25cbiAgICAgIGxldCB7IHNjaGVkdWxlZFRyYW5zYWN0aW9uIH0gPSBhd2FpdCB0aGlzLnByb3h5QXBpLmNyZWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgdHJhbnNhY3Rpb25HYXMsXG4gICAgICAgIHRyYW5zYWN0aW9uRGF0YSxcbiAgICAgICAgbm9uY2VcbiAgICAgIH0pXG5cbiAgICAgIGNvbnNvbGUubG9nKCdTY2hlZHVsZWQgdHJhbnNhY3Rpb24gY3JlYXRlZCcpXG5cbiAgICAgIC8vIENoZWNrIGlmIGJhbGFuY2UgYWNjb3VudCBleGlzdHMsIGlmIG5vdCBjcmVhdGUgaXRcbiAgICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZ2V0QWNjb3VudEluZm8odGhpcy5zb2xhbmFVc2VyLmJhbGFuY2VBZGRyZXNzKVxuICAgICAgaWYgKGFjY291bnQgPT09IG51bGwpIHtcbiAgICAgICAgc2NoZWR1bGVkVHJhbnNhY3Rpb24uaW5zdHJ1Y3Rpb25zLnVuc2hpZnQoXG4gICAgICAgICAgY3JlYXRlQmFsYW5jZUFjY291bnRJbnN0cnVjdGlvbihcbiAgICAgICAgICAgIHRoaXMuc29sYW5hVXNlci5uZW9uRXZtUHJvZ3JhbSxcbiAgICAgICAgICAgIHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXksXG4gICAgICAgICAgICB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCxcbiAgICAgICAgICAgIHRoaXMuY2hhaW5JZCFcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gU2lnbiBhbmQgc2VuZCB0cmFuc2FjdGlvbiAoZXhhY3RseSBsaWtlIHdvcmtpbmcgZXhhbXBsZXMpXG4gICAgICBjb25zdCB7IGJsb2NraGFzaCB9ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgpXG4gICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBibG9ja2hhc2hcbiAgICAgIHNjaGVkdWxlZFRyYW5zYWN0aW9uLmZlZVBheWVyID0gdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBQcmUtc2lnbmluZyBkZWJ1ZzonKVxuICAgICAgY29uc29sZS5sb2coJy0gQ29ubmVjdGVkIHdhbGxldDonLCB0aGlzLnNvbGFuYVVzZXIud2FsbGV0QWRhcHRlci5wdWJsaWNLZXk/LnRvQmFzZTU4KCkpXG4gICAgICBjb25zb2xlLmxvZygnLSBTb2xhbmEgdXNlcjonLCB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LnRvQmFzZTU4KCkpXG4gICAgICBjb25zb2xlLmxvZygnLSBUcmFuc2FjdGlvbiBmZWVQYXllcjonLCBzY2hlZHVsZWRUcmFuc2FjdGlvbi5mZWVQYXllcj8udG9CYXNlNTgoKSlcbiAgICAgIGNvbnNvbGUubG9nKCctIEFyZSB0aGV5IHRoZSBzYW1lPycsIHRoaXMuc29sYW5hVXNlci53YWxsZXRBZGFwdGVyLnB1YmxpY0tleT8udG9CYXNlNTgoKSA9PT0gdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleS50b0Jhc2U1OCgpKVxuICAgICAgXG4gICAgICAvLyBBbmFseXplIGFsbCBzaWduZXJzIHJlcXVpcmVkIGJ5IHRoaXMgdHJhbnNhY3Rpb25cbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIFRyYW5zYWN0aW9uIHNpZ25lcnMgYW5hbHlzaXM6JylcbiAgICAgIGNvbnNvbGUubG9nKCctIE51bWJlciBvZiBpbnN0cnVjdGlvbnM6Jywgc2NoZWR1bGVkVHJhbnNhY3Rpb24uaW5zdHJ1Y3Rpb25zLmxlbmd0aClcbiAgICAgIFxuICAgICAgY29uc3QgcmVxdWlyZWRTaWduZXJzOiBzdHJpbmdbXSA9IFtdXG4gICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5pbnN0cnVjdGlvbnMuZm9yRWFjaCgoaW5zdHJ1Y3Rpb24sIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGAtIEluc3RydWN0aW9uICR7aW5kZXh9OmApXG4gICAgICAgIGNvbnNvbGUubG9nKGAgIC0gUHJvZ3JhbSBJRDogJHtpbnN0cnVjdGlvbi5wcm9ncmFtSWQudG9CYXNlNTgoKX1gKVxuICAgICAgICBjb25zb2xlLmxvZyhgICAtIEtleXM6ICR7aW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGh9YClcbiAgICAgICAgaW5zdHJ1Y3Rpb24ua2V5cy5mb3JFYWNoKChrZXksIGtleUluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYCAgICAtIEtleSAke2tleUluZGV4fTogJHtrZXkucHVia2V5LnRvQmFzZTU4KCl9IChzaWduZXI6ICR7a2V5LmlzU2lnbmVyfSwgd3JpdGFibGU6ICR7a2V5LmlzV3JpdGFibGV9KWApXG4gICAgICAgICAgaWYgKGtleS5pc1NpZ25lcikge1xuICAgICAgICAgICAgcmVxdWlyZWRTaWduZXJzLnB1c2goa2V5LnB1YmtleS50b0Jhc2U1OCgpKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIFJlcXVpcmVkIHNpZ25lcnMgc3VtbWFyeTonKVxuICAgICAgY29uc29sZS5sb2coJy0gVG90YWwgc2lnbmVycyBuZWVkZWQ6JywgcmVxdWlyZWRTaWduZXJzLmxlbmd0aClcbiAgICAgIHJlcXVpcmVkU2lnbmVycy5mb3JFYWNoKChzaWduZXIsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgIC0gU2lnbmVyICR7aW5kZXh9OiAke3NpZ25lcn1gKVxuICAgICAgICBpZiAoc2lnbmVyID09PSB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LnRvQmFzZTU4KCkpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgICAgIOKchSBUaGlzIGlzIG91ciBjb25uZWN0ZWQgd2FsbGV0YClcbiAgICAgICAgfSBlbHNlIGlmIChzaWduZXIgPT09IHRoaXMuc29sYW5hVXNlci5iYWxhbmNlQWRkcmVzcy50b0Jhc2U1OCgpKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYCAgICDwn5OKIFRoaXMgaXMgb3VyIGJhbGFuY2UgYWRkcmVzc2ApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYCAgICDinZMgVW5rbm93biBzaWduZXIgLSBuZWVkcyBpbnZlc3RpZ2F0aW9uYClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgd2hhdCB0eXBlIG9mIHRyYW5zYWN0aW9uIHdlIGhhdmUgYW5kIHRyeSB0byB1c2UgTmVvbidzIGRpcmVjdCBzZXJpYWxpemF0aW9uXG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBUcmFuc2FjdGlvbiB0eXBlIGFuYWx5c2lzOicpXG4gICAgICBjb25zb2xlLmxvZygnLSBUcmFuc2FjdGlvbiBjb25zdHJ1Y3RvcjonLCBzY2hlZHVsZWRUcmFuc2FjdGlvbi5jb25zdHJ1Y3Rvci5uYW1lKVxuICAgICAgY29uc29sZS5sb2coJy0gSGFzIHNlcmlhbGl6ZSBtZXRob2Q6JywgdHlwZW9mIHNjaGVkdWxlZFRyYW5zYWN0aW9uLnNlcmlhbGl6ZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNvbnNvbGUubG9nKCctIEhhcyBzaWduIG1ldGhvZDonLCB0eXBlb2Ygc2NoZWR1bGVkVHJhbnNhY3Rpb24uc2lnbiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNvbnNvbGUubG9nKCctIEhhcyBuZW9uU3ViVHlwZTonLCAnbmVvblN1YlR5cGUnIGluIHNjaGVkdWxlZFRyYW5zYWN0aW9uKVxuICAgICAgXG4gICAgICBsZXQgc2lnbmF0dXJlOiBzdHJpbmdcbiAgICAgIFxuICAgICAgaWYgKHR5cGVvZiBzY2hlZHVsZWRUcmFuc2FjdGlvbi5zZXJpYWxpemUgPT09ICdmdW5jdGlvbicgJiYgJ25lb25TdWJUeXBlJyBpbiBzY2hlZHVsZWRUcmFuc2FjdGlvbikge1xuICAgICAgICAvLyBUaGlzIGlzIGEgTmVvbiBTY2hlZHVsZWRUcmFuc2FjdGlvbiAtIHRyeSB0byB1c2UgaXQgZGlyZWN0bHkgbGlrZSB0aGUgdGVzdFxuICAgICAgICBjb25zb2xlLmxvZygn4pyFIERldGVjdGVkIE5lb24gU2NoZWR1bGVkVHJhbnNhY3Rpb24gLSB1c2luZyBkaXJlY3Qgc2VyaWFsaXphdGlvbicpXG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZygnU3VibWl0dGluZyB0cmFuc2FjdGlvbiB3aXRoIE5lb24gc2VyaWFsaXphdGlvbi4uLicpXG4gICAgICAgIHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24oc2NoZWR1bGVkVHJhbnNhY3Rpb24uc2VyaWFsaXplKCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGYWxsYmFjayB0byB3YWxsZXQgYWRhcHRlciBzaWduaW5nXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OdIFVzaW5nIHdhbGxldCBhZGFwdGVyIHNpZ25pbmcgZmFsbGJhY2suLi4nKVxuICAgICAgICBcbiAgICAgICAgY29uc3Qgc2lnbmVkVHggPSBhd2FpdCB0aGlzLnNvbGFuYVVzZXIud2FsbGV0QWRhcHRlci5zaWduVHJhbnNhY3Rpb24oc2NoZWR1bGVkVHJhbnNhY3Rpb24pXG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZygnU3VibWl0dGluZyB0cmFuc2FjdGlvbi4uLicpXG4gICAgICAgIHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24oc2lnbmVkVHguc2VyaWFsaXplKCkpXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgVHJhbnNhY3Rpb24gc3VibWl0dGVkIScpXG4gICAgICBjb25zb2xlLmxvZygn8J+UlyBTaWduYXR1cmU6Jywgc2lnbmF0dXJlKVxuXG4gICAgICAvLyBXYWl0IGEgYml0IGZvciBwcm9jZXNzaW5nIChsaWtlIHdvcmtpbmcgZXhhbXBsZXMpXG4gICAgICBjb25zb2xlLmxvZygnV2FpdGluZyBmb3IgY29uZmlybWF0aW9uLi4uJylcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDAwKSlcblxuICAgICAgLy8gV2FpdCBmb3IgdHJhbnNhY3Rpb24gZXhlY3V0aW9uIG9uIE5lb24gRVZNXG4gICAgICBjb25zdCB0cmFuc2FjdGlvblN0YXR1cyA9IGF3YWl0IHRoaXMucHJveHlBcGkud2FpdFRyYW5zYWN0aW9uVHJlZUV4ZWN1dGlvbihcbiAgICAgICAgdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsIFxuICAgICAgICBub25jZSwgXG4gICAgICAgIDYwMDAwIC8vIDYwIHNlY29uZCB0aW1lb3V0XG4gICAgICApXG5cbiAgICAgIGNvbnNvbGUubG9nKCdUcmFuc2FjdGlvbiBzdGF0dXM6JywgdHJhbnNhY3Rpb25TdGF0dXMpXG5cbiAgICAgIGlmICh0cmFuc2FjdGlvblN0YXR1cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB0cmFuc2FjdGlvbiBzdGF0dXMgcmV0dXJuZWQgLSB0cmFuc2FjdGlvbiBtYXkgbm90IGhhdmUgYmVlbiBwcm9jZXNzZWQnKVxuICAgICAgfVxuXG4gICAgICBjb25zdCB0eFN0YXR1cyA9IHRyYW5zYWN0aW9uU3RhdHVzWzBdXG4gICAgICBjb25zb2xlLmxvZygnVHJhbnNhY3Rpb24gZXhlY3V0aW9uIHN0YXR1czonLCB0eFN0YXR1cy5zdGF0dXMpXG4gICAgICBcbiAgICAgIGlmICh0eFN0YXR1cy5zdGF0dXMgPT09ICdOb3RTdGFydGVkJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBUcmFuc2FjdGlvbiB3YXMgc2NoZWR1bGVkIGJ1dCBub3QgeWV0IGV4ZWN1dGVkIGJ5IE5lb24gb3BlcmF0b3JzJylcbiAgICAgICAgY29uc29sZS5sb2coJ1RoaXMgaXMgZXhwZWN0ZWQgLSBOZW9uIHdpbGwgcHJvY2VzcyBpdCBldmVudHVhbGx5JylcbiAgICAgICAgY29uc29sZS5sb2coJ1RyYW5zYWN0aW9uIGhhc2g6JywgdHhTdGF0dXMudHJhbnNhY3Rpb25IYXNoKVxuICAgICAgICBcbiAgICAgICAgLy8gU2luY2Ugd2UgaGF2ZSBhIHRyYW5zYWN0aW9uIGhhc2gsIHByb2NlZWQgd2l0aCB1c2luZyBpdCBhcyB0aGUgcGF5bWVudCBsaW5rIElEXG4gICAgICAgIC8vIFRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIHByb2Nlc3NlZCBieSBOZW9uIG9wZXJhdG9ycyBldmVudHVhbGx5XG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgVXNpbmcgdHJhbnNhY3Rpb24gaGFzaCBhcyBwYXltZW50IGxpbmsgSUQgLSBOZW9uIHdpbGwgcHJvY2VzcyBpdCB3aGVuIHJlYWR5JylcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGlua0lkOiB0eFN0YXR1cy50cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgdHhIYXNoOiB0eFN0YXR1cy50cmFuc2FjdGlvbkhhc2hcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgIH0gZWxzZSBpZiAodHhTdGF0dXMuc3RhdHVzID09PSAnRmFpbGVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIGV4ZWN1dGlvbiBmYWlsZWQuIEhhc2g6ICR7dHhTdGF0dXMudHJhbnNhY3Rpb25IYXNofWApXG4gICAgICB9IGVsc2UgaWYgKHR4U3RhdHVzLnN0YXR1cyAhPT0gJ1N1Y2Nlc3MnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVHJhbnNhY3Rpb24gZmluaXNoZWQgd2l0aCB1bmV4cGVjdGVkIHN0YXR1czonLCB0eFN0YXR1cy5zdGF0dXMpXG4gICAgICAgIC8vIFN0aWxsIHRyeSB0byByZXR1cm4gdGhlIHRyYW5zYWN0aW9uIGhhc2ggaW4gY2FzZSBpdCdzIHVzYWJsZVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmtJZDogdHhTdGF0dXMudHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgIHR4SGFzaDogdHhTdGF0dXMudHJhbnNhY3Rpb25IYXNoXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdHhIYXNoID0gdHJhbnNhY3Rpb25TdGF0dXNbMF0udHJhbnNhY3Rpb25IYXNoXG4gICAgICBjb25zb2xlLmxvZygnVHJhbnNhY3Rpb24gaGFzaDonLCB0eEhhc2gpXG5cbiAgICAgIC8vIEdldCB0aGUgbGluayBJRCBmcm9tIHRyYW5zYWN0aW9uIHJlY2VpcHRcbiAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3h5QXBpLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpXG4gICAgICBjb25zb2xlLmxvZygnRnVsbCB0cmFuc2FjdGlvbiByZWNlaXB0OicsIEpTT04uc3RyaW5naWZ5KHJlY2VpcHQsIG51bGwsIDIpKVxuICAgICAgXG4gICAgICBsZXQgbGlua0lkID0gJydcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIHRyYW5zYWN0aW9uIHdhcyBzdWNjZXNzZnVsXG4gICAgICBpZiAocmVjZWlwdC5yZXN1bHQ/LnN0YXR1cyAhPT0gJzB4MScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBmYWlsZWQgLSBzdGF0dXM6ICcgKyByZWNlaXB0LnJlc3VsdD8uc3RhdHVzKVxuICAgICAgfVxuXG4gICAgICAvLyBFbmhhbmNlZCBkZWJ1Z2dpbmcgb2YgdGhlIHJlY2VpcHQgc3RydWN0dXJlXG4gICAgICBjb25zb2xlLmxvZygnUmVjZWlwdCBzdGF0dXM6JywgcmVjZWlwdC5yZXN1bHQ/LnN0YXR1cylcbiAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXB0IGxvZ3MgYXJyYXk6JywgcmVjZWlwdC5yZXN1bHQ/LmxvZ3MpXG4gICAgICBjb25zb2xlLmxvZygnUmVjZWlwdCBsb2dzIGxlbmd0aDonLCByZWNlaXB0LnJlc3VsdD8ubG9ncz8ubGVuZ3RoKVxuICAgICAgY29uc29sZS5sb2coJ1JlY2VpcHQgbG9nc0Jsb29tOicsIHJlY2VpcHQucmVzdWx0Py5sb2dzQmxvb20pXG4gICAgICBjb25zb2xlLmxvZygnUmVjZWlwdCBjb250cmFjdEFkZHJlc3M6JywgcmVjZWlwdC5yZXN1bHQ/LmNvbnRyYWN0QWRkcmVzcylcbiAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXB0IGdhc1VzZWQ6JywgcmVjZWlwdC5yZXN1bHQ/Lmdhc1VzZWQpXG4gICAgICBjb25zb2xlLmxvZygnUmVjZWlwdCBlZmZlY3RpdmVHYXNQcmljZTonLCByZWNlaXB0LnJlc3VsdD8uZWZmZWN0aXZlR2FzUHJpY2UpXG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZXJlJ3MgYSBkaWZmZXJlbnQgbG9jYXRpb24gZm9yIGxvZ3NcbiAgICAgIGNvbnNvbGUubG9nKCdSYXcgdHJhbnNhY3Rpb24gZGF0YTonLCByZWNlaXB0LnJlc3VsdD8ubmVvblJhd1RyYW5zYWN0aW9uKVxuICAgICAgXG4gICAgICAvLyBOb3RlOiBnZXRUcmFuc2FjdGlvbiBtZXRob2Qgbm90IGF2YWlsYWJsZSBvbiBOZW9uUHJveHlScGNBcGlcbiAgICAgIC8vIFRyYW5zYWN0aW9uIGRldGFpbHMgYXJlIGFscmVhZHkgaW4gdGhlIHJlY2VpcHRcblxuICAgICAgLy8gRXh0cmFjdCBhbGwgbmVvbkxvZ3MgZnJvbSBzb2xhbmFUcmFuc2FjdGlvbnNcbiAgICAgIGNvbnN0IGFsbE5lb25Mb2dzOiBhbnlbXSA9IFtdXG4gICAgICBpZiAocmVjZWlwdC5yZXN1bHQ/LnNvbGFuYVRyYW5zYWN0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IHNvbFR4IG9mIHJlY2VpcHQucmVzdWx0LnNvbGFuYVRyYW5zYWN0aW9ucykge1xuICAgICAgICAgIGlmIChzb2xUeC5zb2xhbmFJbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5zdHJ1Y3Rpb24gb2Ygc29sVHguc29sYW5hSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5uZW9uTG9ncyAmJiBpbnN0cnVjdGlvbi5uZW9uTG9ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgYWxsTmVvbkxvZ3MucHVzaCguLi5pbnN0cnVjdGlvbi5uZW9uTG9ncylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnRm91bmQnLCBhbGxOZW9uTG9ncy5sZW5ndGgsICduZW9uTG9ncyB0byBwYXJzZScpXG5cbiAgICAgIC8vIFRyeSB0byBwYXJzZSBsb2dzIGZvciB0aGUgU29sYW5hTGlua0NyZWF0ZWQgZXZlbnRcbiAgICAgIGlmIChhbGxOZW9uTG9ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAoY29uc3QgbG9nIG9mIGFsbE5lb25Mb2dzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUcnlpbmcgdG8gcGFyc2UgbmVvbkxvZzonLCBsb2cpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgbG9nIGlzIGZyb20gb3VyIGNvbnRyYWN0XG4gICAgICAgICAgICBpZiAobG9nLmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gQ09OVFJBQ1RfQUREUkVTUy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdMb2cgaXMgZnJvbSBvdXIgY29udHJhY3QsIHBhcnNpbmcuLi4nKVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgbG9nIHRvIHRoZSBmb3JtYXQgZXhwZWN0ZWQgYnkgZXRoZXJzXG4gICAgICAgICAgICAgIGNvbnN0IGV0aGVyc0xvZyA9IHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBsb2cuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBkYXRhOiBsb2cuZGF0YSxcbiAgICAgICAgICAgICAgICB0b3BpY3M6IGxvZy50b3BpY3NcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgY29uc3QgcGFyc2VkTG9nID0gaWZhY2UucGFyc2VMb2coZXRoZXJzTG9nKVxuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUGFyc2VkIGxvZzonLCBwYXJzZWRMb2cpXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAocGFyc2VkTG9nPy5uYW1lID09PSAnU29sYW5hTGlua0NyZWF0ZWQnKSB7XG4gICAgICAgICAgICAgICAgbGlua0lkID0gcGFyc2VkTG9nLmFyZ3MubGlua0lkXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ+KchSBGb3VuZCBsaW5rIElEIGZyb20gU29sYW5hTGlua0NyZWF0ZWQgZXZlbnQ6JywgbGlua0lkKVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdMb2cgZnJvbSBkaWZmZXJlbnQgY29udHJhY3Q6JywgbG9nLmFkZHJlc3MpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCB0byBwYXJzZSBuZW9uTG9nOicsIGUpXG4gICAgICAgICAgICAvLyBTa2lwIGxvZ3MgdGhhdCBjYW4ndCBiZSBwYXJzZWRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybignTm8gbmVvbkxvZ3MgZm91bmQgaW4gdHJhbnNhY3Rpb24gcmVjZWlwdCEnKVxuICAgICAgICBjb25zb2xlLmxvZygnVGhpcyBtaWdodCBpbmRpY2F0ZTonKVxuICAgICAgICBjb25zb2xlLmxvZygnMS4gVGhlIGNvbnRyYWN0IGNhbGwgZmFpbGVkIHNpbGVudGx5JylcbiAgICAgICAgY29uc29sZS5sb2coJzIuIFRoZSBjb250cmFjdCBpcyBub3QgYXQgdGhlIGV4cGVjdGVkIGFkZHJlc3MnKVxuICAgICAgICBjb25zb2xlLmxvZygnMy4gVGhlIGNvbnRyYWN0IGZ1bmN0aW9uIGNhbGwgcmV2ZXJ0ZWQnKVxuICAgICAgICBjb25zb2xlLmxvZygnNC4gRXZlbnRzIGFyZSBub3QgYmVpbmcgZW1pdHRlZCBwcm9wZXJseScpXG4gICAgICAgIFxuICAgICAgICAvLyBUcnkgY2FsbGluZyB0aGUgY29udHJhY3QgcmVhZCBtZXRob2QgdG8gc2VlIGlmIGRhdGEgd2FzIGFjdHVhbGx5IHN0b3JlZFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIHRvIHJlYWQgcGF5bWVudCBsaW5rIHVzaW5nIHRyYW5zYWN0aW9uIGhhc2ggYXMgSUQuLi4nKVxuICAgICAgICAgIGNvbnN0IHRlc3REYXRhID0gYXdhaXQgdGhpcy5jb250cmFjdCEuZ2V0U29sYW5hUGF5bWVudExpbmsodHhIYXNoKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCdDb250cmFjdCByZWFkIHJlc3VsdDonLCB0ZXN0RGF0YSlcbiAgICAgICAgfSBjYXRjaCAocmVhZEVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0NvbnRyYWN0IHJlYWQgZmFpbGVkOicsIHJlYWRFcnJvcilcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSBjb3VsZG4ndCBleHRyYWN0IGZyb20gbG9ncywgaW52ZXN0aWdhdGUgZnVydGhlclxuICAgICAgaWYgKCFsaW5rSWQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQ291bGQgbm90IGV4dHJhY3QgbGluayBJRCBmcm9tIHRyYW5zYWN0aW9uIGV2ZW50cyEnKVxuICAgICAgICBjb25zb2xlLmxvZygnVGhpcyBzdWdnZXN0cyB0aGUgY29udHJhY3QgY2FsbCBtYXkgaGF2ZSBmYWlsZWQgc2lsZW50bHknKVxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHRyYW5zYWN0aW9uIGFjdHVhbGx5IHJldmVydGVkXG4gICAgICAgIGNvbnNvbGUubG9nKCdDaGVja2luZyBmb3IgcmV2ZXJ0IGRhdGEuLi4nKVxuICAgICAgICBpZiAocmVjZWlwdC5yZXN1bHQ/Lm5lb25SZXZlcnREYXRhKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1JldmVydCBkYXRhIGZvdW5kOicsIHJlY2VpcHQucmVzdWx0Lm5lb25SZXZlcnREYXRhKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gZGVjb2RlIHRoZSByZXZlcnQgcmVhc29uXG4gICAgICAgICAgICBjb25zdCByZXZlcnRSZWFzb24gPSBldGhlcnMudG9VdGY4U3RyaW5nKHJlY2VpcHQucmVzdWx0Lm5lb25SZXZlcnREYXRhKVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1JldmVydCByZWFzb246JywgcmV2ZXJ0UmVhc29uKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb250cmFjdCBjYWxsIHJldmVydGVkOiAke3JldmVydFJlYXNvbn1gKVxuICAgICAgICAgIH0gY2F0Y2ggKGRlY29kZUVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQ291bGQgbm90IGRlY29kZSByZXZlcnQgcmVhc29uOicsIGRlY29kZUVycm9yKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250cmFjdCBjYWxsIHJldmVydGVkIHdpdGggdW5rbm93biByZWFzb24nKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gTGV0J3MgdHJ5IHRvIHVuZGVyc3RhbmQgd2h5IHRoZSBldmVudCB3YXNuJ3QgZW1pdHRlZFxuICAgICAgICBjb25zb2xlLmxvZygnQW5hbHl6aW5nIGZ1bmN0aW9uIGNhbGwuLi4nKVxuICAgICAgICBjb25zb2xlLmxvZygnQ29udHJhY3QgYWRkcmVzczonLCBDT05UUkFDVF9BRERSRVNTKVxuICAgICAgICBjb25zb2xlLmxvZygnRnJvbSBhZGRyZXNzOicsIHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0KVxuICAgICAgICBjb25zb2xlLmxvZygnRnVuY3Rpb24gZGF0YSBpbiByYXcgdHg6JywgcmVjZWlwdC5yZXN1bHQ/Lm5lb25SYXdUcmFuc2FjdGlvbilcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHVzZXIgaXMgcmVnaXN0ZXJlZFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGlzUmVnaXN0ZXJlZCA9IGF3YWl0IHRoaXMuY29udHJhY3QhLmlzU29sYW5hVXNlcih0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldClcbiAgICAgICAgICBjb25zb2xlLmxvZygnSXMgdXNlciByZWdpc3RlcmVkIGFzIFNvbGFuYSB1c2VyOicsIGlzUmVnaXN0ZXJlZClcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIWlzUmVnaXN0ZXJlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVc2VyIGlzIG5vdCByZWdpc3RlcmVkIGFzIGEgU29sYW5hIHVzZXIgd2l0aCB0aGUgY29udHJhY3QuIFRoaXMgaXMgcmVxdWlyZWQgdG8gY3JlYXRlIHBheW1lbnQgbGlua3MuJylcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKHJlZ2lzdHJhdGlvbkVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNoZWNrIHVzZXIgcmVnaXN0cmF0aW9uOicsIHJlZ2lzdHJhdGlvbkVycm9yKVxuICAgICAgICAgIHRocm93IHJlZ2lzdHJhdGlvbkVycm9yXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIElmIHdlIGdldCBoZXJlLCBzb21ldGhpbmcgZWxzZSB3ZW50IHdyb25nXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGF5bWVudCBsaW5rIGNyZWF0aW9uIGZhaWxlZDogQ29udHJhY3QgY2FsbCBleGVjdXRlZCBidXQgbm8gZXZlbnQgd2FzIGVtaXR0ZWQuIFRoZSB0cmFuc2FjdGlvbiBtYXkgaGF2ZSBmYWlsZWQgc2lsZW50bHkuJylcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGlua0lkLFxuICAgICAgICB0eEhhc2hcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBwYXltZW50IGxpbms6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHJlYWQtb25seSBjb250cmFjdCBhY2Nlc3MgKHdpdGhvdXQgd2FsbGV0KVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBpbml0UmVhZE9ubHlDb250cmFjdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuY29udHJhY3QpIHtcbiAgICAgIC8vIENyZWF0ZSBhIHNpbXBsZSBKU09OIFJQQyBwcm92aWRlciBmb3IgcmVhZCBvcGVyYXRpb25zXG4gICAgICBjb25zdCByZWFkT25seVByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoTkVPTl9DT1JFX1JQQ19VUkwpXG4gICAgICB0aGlzLmNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChDT05UUkFDVF9BRERSRVNTLCBTT0xBTkFfVElQQ0FSRF9BQkksIHJlYWRPbmx5UHJvdmlkZXIpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBwYXltZW50IGxpbmsgZGV0YWlsc1xuICAgKi9cbiAgYXN5bmMgZ2V0UGF5bWVudExpbmsobGlua0lkOiBzdHJpbmcpOiBQcm9taXNlPFBheW1lbnRMaW5rPiB7XG4gICAgLy8gSW5pdGlhbGl6ZSBjb250cmFjdCBpZiBub3QgYWxyZWFkeSBkb25lXG4gICAgaWYgKCF0aGlzLmNvbnRyYWN0KSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRSZWFkT25seUNvbnRyYWN0KClcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnR2V0dGluZyBwYXltZW50IGxpbmsgd2l0aCBJRDonLCBsaW5rSWQpXG4gICAgY29uc29sZS5sb2coJ0NvbnRyYWN0IGFkZHJlc3M6JywgQ09OVFJBQ1RfQUREUkVTUylcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNvbnRyYWN0IS5nZXRTb2xhbmFQYXltZW50TGluayhsaW5rSWQpXG4gICAgICBjb25zb2xlLmxvZygnUmF3IGNvbnRyYWN0IHJlc3VsdDonLCByZXN1bHQpXG4gICAgICBcbiAgICAgIGNvbnN0IHBheW1lbnRMaW5rID0ge1xuICAgICAgICBldm1DcmVhdG9yOiByZXN1bHQuZXZtQ3JlYXRvcixcbiAgICAgICAgc29sYW5hQ3JlYXRvcjogcmVzdWx0LnNvbGFuYUNyZWF0b3IsXG4gICAgICAgIGFtb3VudDogcmVzdWx0LmFtb3VudCxcbiAgICAgICAgaXNGbGV4aWJsZTogcmVzdWx0LmlzRmxleGlibGUsXG4gICAgICAgIGlzQWN0aXZlOiByZXN1bHQuaXNBY3RpdmUsXG4gICAgICAgIHRvdGFsUmVjZWl2ZWQ6IHJlc3VsdC50b3RhbFJlY2VpdmVkLFxuICAgICAgICBwYXltZW50Q291bnQ6IE51bWJlcihyZXN1bHQucGF5bWVudENvdW50KSxcbiAgICAgICAgZGVzY3JpcHRpb246IHJlc3VsdC5kZXNjcmlwdGlvblxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGxvb2tzIGxpa2UgYW4gZW1wdHkvbm9uLWV4aXN0ZW50IGxpbmsgKHRyYW5zYWN0aW9uIG5vdCBwcm9jZXNzZWQgeWV0KVxuICAgICAgaWYgKHJlc3VsdC5ldm1DcmVhdG9yID09PSAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyAmJiBcbiAgICAgICAgICByZXN1bHQuYW1vdW50ID09PSBCaWdJbnQoMCkgJiYgXG4gICAgICAgICAgIXJlc3VsdC5pc0FjdGl2ZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1BheW1lbnQgbGluayBhcHBlYXJzIHRvIGJlIGVtcHR5L25vbi1leGlzdGVudCcpXG4gICAgICAgIFxuICAgICAgICAvLyBJZiB0aGlzIGxvb2tzIGxpa2UgYSB0cmFuc2FjdGlvbiBoYXNoICg2NiBjaGFycywgc3RhcnRzIHdpdGggMHgpLCBwcm92aWRlIGhlbHBmdWwgaW5mb1xuICAgICAgICBpZiAobGlua0lkLmxlbmd0aCA9PT0gNjYgJiYgbGlua0lkLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+SoSBUaGlzIGFwcGVhcnMgdG8gYmUgYSB0cmFuc2FjdGlvbiBoYXNoIC0gdGhlIHBheW1lbnQgbGluayBtYXkgc3RpbGwgYmUgcHJvY2Vzc2luZycpXG4gICAgICAgICAgY29uc29sZS5sb2coJ/CfkqEgTmVvbiBvcGVyYXRvcnMgd2lsbCBldmVudHVhbGx5IHByb2Nlc3MgdGhpcyB0cmFuc2FjdGlvbiBhbmQgY3JlYXRlIHRoZSBwYXltZW50IGxpbmsnKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5KhIFlvdSBjYW4gYm9va21hcmsgdGhpcyBsaW5rIGFuZCB0cnkgYWdhaW4gaW4gYSBmZXcgbWludXRlcycpXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRm9yIG5vdywgZG9uJ3QgdGhyb3cgYW4gZXJyb3IgLSBsZXQgdGhlIFVJIGhhbmRsZSB0aGUgZW1wdHkgZGF0YSBncmFjZWZ1bGx5XG4gICAgICAgICAgY29uc29sZS5sb2coJ1JldHVybmluZyBlbXB0eSBwYXltZW50IGxpbmsgZGF0YSAtIHRyYW5zYWN0aW9uIG1heSBzdGlsbCBiZSBwcm9jZXNzaW5nJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gcGF5bWVudExpbmtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQ29udHJhY3QgY2FsbCBlcnJvcjonLCBlcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGF5bWVudCBsaW5rIG5vdCBmb3VuZCBvciBjb250cmFjdCBlcnJvcicpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB1c2VyJ3MgcGF5bWVudCBsaW5rc1xuICAgKi9cbiAgYXN5bmMgZ2V0VXNlckxpbmtzKHVzZXJFVk1BZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgLy8gSW5pdGlhbGl6ZSBjb250cmFjdCBpZiBub3QgYWxyZWFkeSBkb25lXG4gICAgaWYgKCF0aGlzLmNvbnRyYWN0KSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRSZWFkT25seUNvbnRyYWN0KClcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29udHJhY3QhLmdldFVzZXJTb2xhbmFMaW5rcyh1c2VyRVZNQWRkcmVzcylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB1c2VyIGxpbmtzOicsIGVycm9yKVxuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBheSBhIHBheW1lbnQgbGluayB1c2luZyBTb2xhbmEgTmF0aXZlIFNES1xuICAgKi9cbiAgYXN5bmMgcGF5TGluayhcbiAgICBsaW5rSWQ6IHN0cmluZyxcbiAgICBhbW91bnRTT0w6IG51bWJlclxuICApOiBQcm9taXNlPHsgdHhIYXNoOiBzdHJpbmc7IHRyYW5zZmVyU2lnbmF0dXJlPzogc3RyaW5nIH0+IHtcbiAgICBpZiAoIXRoaXMuc29sYW5hVXNlciB8fCAhdGhpcy5jb250cmFjdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgY29ubmVjdCB3YWxsZXQgZmlyc3QnKVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdTdGFydGluZyBwYXltZW50IHByb2Nlc3MuLi4nKVxuICAgIGNvbnNvbGUubG9nKCdMaW5rIElEOicsIGxpbmtJZClcbiAgICBjb25zb2xlLmxvZygnQW1vdW50IFNPTDonLCBhbW91bnRTT0wpXG5cbiAgICAvLyBGaXJzdCwgZ2V0IHRoZSBwYXltZW50IGxpbmsgZGV0YWlscyB0byBmaW5kIHRoZSByZWNpcGllbnRcbiAgICBjb25zdCBsaW5rRGF0YSA9IGF3YWl0IHRoaXMuZ2V0UGF5bWVudExpbmsobGlua0lkKVxuICAgIGNvbnNvbGUubG9nKCdQYXltZW50IGxpbmsgZGF0YTonLCBsaW5rRGF0YSlcblxuICAgIGlmICghbGlua0RhdGEuaXNBY3RpdmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGF5bWVudCBsaW5rIGlzIG5vIGxvbmdlciBhY3RpdmUnKVxuICAgIH1cblxuICAgIC8vIENvbnZlcnQgU09MIHRvIGxhbXBvcnRzXG4gICAgY29uc3QgYW1vdW50TGFtcG9ydHMgPSBNYXRoLmZsb29yKGFtb3VudFNPTCAqIDFlOSlcbiAgICBcbiAgICBsZXQgdHJhbnNmZXJTaWduYXR1cmU6IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFN0ZXAgMTogUGVyZm9ybSB0aGUgYWN0dWFsIFNPTCB0cmFuc2ZlciBmaXJzdFxuICAgICAgY29uc29sZS5sb2coJ1N0ZXAgMTogUGVyZm9ybWluZyBTT0wgdHJhbnNmZXIuLi4nKVxuICAgICAgY29uc29sZS5sb2coJ0Zyb206JywgdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleS50b0Jhc2U1OCgpKVxuICAgICAgY29uc29sZS5sb2coJ1RvIHJlY2lwaWVudCBieXRlczMyOicsIGxpbmtEYXRhLnNvbGFuYUNyZWF0b3IpXG4gICAgICBjb25zb2xlLmxvZygnQW1vdW50IGxhbXBvcnRzOicsIGFtb3VudExhbXBvcnRzKVxuXG4gICAgICAvLyBDb252ZXJ0IHJlY2lwaWVudCBTb2xhbmEgYWRkcmVzcyBmcm9tIGJ5dGVzMzIgdG8gUHVibGljS2V5XG4gICAgICAvLyBSZW1vdmUgJzB4JyBwcmVmaXggaWYgcHJlc2VudFxuICAgICAgY29uc3QgaGV4U3RyaW5nID0gbGlua0RhdGEuc29sYW5hQ3JlYXRvci5zdGFydHNXaXRoKCcweCcpIFxuICAgICAgICA/IGxpbmtEYXRhLnNvbGFuYUNyZWF0b3Iuc2xpY2UoMikgXG4gICAgICAgIDogbGlua0RhdGEuc29sYW5hQ3JlYXRvclxuICAgICAgXG4gICAgICAvLyBDb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheVxuICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShoZXhTdHJpbmcubWF0Y2goLy57Mn0vZyk/Lm1hcChieXRlID0+IHBhcnNlSW50KGJ5dGUsIDE2KSkgfHwgW10pXG4gICAgICBcbiAgICAgIC8vIEZvciBieXRlczMyIGZyb20gU29sYW5hIGFkZHJlc3Nlcywgd2UgbmVlZCB0byBmaW5kIHRoZSBhY3R1YWwgMzItYnl0ZSBwdWJsaWMga2V5XG4gICAgICAvLyBUaGUgYnl0ZXMzMiBzaG91bGQgY29udGFpbiB0aGUgMzItYnl0ZSBTb2xhbmEgcHVibGljIGtleSwgcG9zc2libHkgd2l0aCBsZWFkaW5nIHplcm9zXG4gICAgICBsZXQgcmVjaXBpZW50UHVia2V5XG4gICAgICBcbiAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDMyKSB7XG4gICAgICAgIC8vIERpcmVjdCBjb252ZXJzaW9uIGZyb20gMzIgYnl0ZXNcbiAgICAgICAgcmVjaXBpZW50UHVia2V5ID0gbmV3IChhd2FpdCBpbXBvcnQoJ0Bzb2xhbmEvd2ViMy5qcycpKS5QdWJsaWNLZXkoYnl0ZXMpXG4gICAgICB9IGVsc2UgaWYgKGJ5dGVzLmxlbmd0aCA+IDMyKSB7XG4gICAgICAgIC8vIFRha2UgdGhlIGxhc3QgMzIgYnl0ZXMgaWYgaXQncyBsb25nZXJcbiAgICAgICAgY29uc3QgbGFzdDMyQnl0ZXMgPSBieXRlcy5zbGljZSgtMzIpXG4gICAgICAgIHJlY2lwaWVudFB1YmtleSA9IG5ldyAoYXdhaXQgaW1wb3J0KCdAc29sYW5hL3dlYjMuanMnKSkuUHVibGljS2V5KGxhc3QzMkJ5dGVzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUGFkIHdpdGggbGVhZGluZyB6ZXJvcyBpZiBzaG9ydGVyXG4gICAgICAgIGNvbnN0IHBhZGRlZEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMzIpXG4gICAgICAgIHBhZGRlZEJ5dGVzLnNldChieXRlcywgMzIgLSBieXRlcy5sZW5ndGgpXG4gICAgICAgIHJlY2lwaWVudFB1YmtleSA9IG5ldyAoYXdhaXQgaW1wb3J0KCdAc29sYW5hL3dlYjMuanMnKSkuUHVibGljS2V5KHBhZGRlZEJ5dGVzKVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnUmVjaXBpZW50IFB1YmxpY0tleTonLCByZWNpcGllbnRQdWJrZXkudG9CYXNlNTgoKSlcblxuICAgICAgLy8gQ3JlYXRlIHRoZSBTT0wgdHJhbnNmZXIgdHJhbnNhY3Rpb25cbiAgICAgIGNvbnN0IHsgU3lzdGVtUHJvZ3JhbSwgVHJhbnNhY3Rpb24gfSA9IGF3YWl0IGltcG9ydCgnQHNvbGFuYS93ZWIzLmpzJylcblxuICAgICAgLy8gQ3JlYXRlIHRyYW5zZmVyIGluc3RydWN0aW9uXG4gICAgICBjb25zdCB0cmFuc2Zlckl4ID0gU3lzdGVtUHJvZ3JhbS50cmFuc2Zlcih7XG4gICAgICAgIGZyb21QdWJrZXk6IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXksXG4gICAgICAgIHRvUHVia2V5OiByZWNpcGllbnRQdWJrZXksXG4gICAgICAgIGxhbXBvcnRzOiBhbW91bnRMYW1wb3J0c1xuICAgICAgfSlcblxuICAgICAgLy8gQ3JlYXRlIHRyYW5zYWN0aW9uXG4gICAgICBjb25zdCB0cmFuc2ZlclR4ID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHRyYW5zZmVySXgpXG4gICAgICBcbiAgICAgIC8vIEdldCBmcmVzaCByZWNlbnQgYmxvY2toYXNoIHJpZ2h0IGJlZm9yZSBzaWduaW5nXG4gICAgICBjb25zb2xlLmxvZygnR2V0dGluZyBmcmVzaCBibG9ja2hhc2ggZm9yIFNPTCB0cmFuc2Zlci4uLicpXG4gICAgICBjb25zdCB7IGJsb2NraGFzaCwgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IHRyYW5zZmVyQmxvY2tIZWlnaHQgfSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goJ2NvbmZpcm1lZCcpXG4gICAgICBjb25zb2xlLmxvZygnRnJlc2ggU09MIHRyYW5zZmVyIGJsb2NraGFzaDonLCBibG9ja2hhc2gpXG4gICAgICBjb25zb2xlLmxvZygnTGFzdCB2YWxpZCBibG9jayBoZWlnaHQ6JywgdHJhbnNmZXJCbG9ja0hlaWdodClcbiAgICAgIFxuICAgICAgdHJhbnNmZXJUeC5yZWNlbnRCbG9ja2hhc2ggPSBibG9ja2hhc2hcbiAgICAgIHRyYW5zZmVyVHguZmVlUGF5ZXIgPSB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5XG5cbiAgICAgIC8vIFNpZ24gYW5kIHNlbmQgdGhlIFNPTCB0cmFuc2ZlciBpbW1lZGlhdGVseVxuICAgICAgY29uc29sZS5sb2coJ1NpZ25pbmcgYW5kIHNlbmRpbmcgU09MIHRyYW5zZmVyIHdpdGggZnJlc2ggYmxvY2toYXNoLi4uJylcbiAgICAgIGNvbnN0IHNpZ25lZFRyYW5zZmVyVHggPSBhd2FpdCB0aGlzLnNvbGFuYVVzZXIud2FsbGV0QWRhcHRlci5zaWduVHJhbnNhY3Rpb24odHJhbnNmZXJUeClcbiAgICAgIHRyYW5zZmVyU2lnbmF0dXJlID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihzaWduZWRUcmFuc2ZlclR4LnNlcmlhbGl6ZSgpKVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnU09MIHRyYW5zZmVyIHNlbnQ6JywgdHJhbnNmZXJTaWduYXR1cmUpXG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIHRyYW5zZmVyIGNvbmZpcm1hdGlvbiB1c2luZyB0aGUgbW9kZXJuIEFQSVxuICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XG4gICAgICAgIHNpZ25hdHVyZTogdHJhbnNmZXJTaWduYXR1cmUsXG4gICAgICAgIC4uLihhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCkpXG4gICAgICB9KVxuICAgICAgY29uc29sZS5sb2coJ1NPTCB0cmFuc2ZlciBjb25maXJtZWQnKVxuXG4gICAgICAvLyBTdGVwIDI6IFJlY29yZCB0aGUgcGF5bWVudCBpbiB0aGUgY29udHJhY3RcbiAgICAgIGNvbnNvbGUubG9nKCdTdGVwIDI6IFJlY29yZGluZyBwYXltZW50IGluIGNvbnRyYWN0Li4uJylcbiAgICAgIFxuICAgICAgLy8gQ29udmVydCBTb2xhbmEgUHVibGljS2V5IHRvIGJ5dGVzMzJcbiAgICAgIGNvbnN0IHBheWVyU29sYW5hQnl0ZXMzMiA9IHplcm9QYWRWYWx1ZShoZXhsaWZ5KHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXkudG9CeXRlcygpKSwgMzIpXG5cbiAgICAgIC8vIEdldCBjdXJyZW50IG5vbmNlXG4gICAgICBjb25zdCBub25jZSA9IE51bWJlcihhd2FpdCB0aGlzLnByb3h5QXBpLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQpKVxuICAgICAgY29uc29sZS5sb2coJ0N1cnJlbnQgbm9uY2U6Jywgbm9uY2UpXG5cbiAgICAgIC8vIFByZXBhcmUgY29udHJhY3QgY2FsbCBkYXRhXG4gICAgICBjb25zdCBpZmFjZSA9IG5ldyBldGhlcnMuSW50ZXJmYWNlKFNPTEFOQV9USVBDQVJEX0FCSSlcbiAgICAgIGNvbnN0IGRhdGEgPSBpZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoJ3BheVNvbGFuYUxpbmsnLCBbXG4gICAgICAgIGxpbmtJZCxcbiAgICAgICAgYW1vdW50TGFtcG9ydHMsXG4gICAgICAgIHBheWVyU29sYW5hQnl0ZXMzMlxuICAgICAgXSlcblxuICAgICAgLy8gQ3JlYXRlIHRyYW5zYWN0aW9uIGRhdGFcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uRGF0YSA9IHtcbiAgICAgICAgZnJvbTogdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsXG4gICAgICAgIHRvOiBDT05UUkFDVF9BRERSRVNTLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9XG5cbiAgICAgIC8vIEVzdGltYXRlIGdhc1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25HYXMgPSBhd2FpdCB0aGlzLnByb3h5QXBpLmVzdGltYXRlU2NoZWR1bGVkVHJhbnNhY3Rpb25HYXMoe1xuICAgICAgICBzb2xhbmFQYXllcjogdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleSxcbiAgICAgICAgdHJhbnNhY3Rpb25zOiBbdHJhbnNhY3Rpb25EYXRhXSxcbiAgICAgIH0pXG5cbiAgICAgIC8vIENyZWF0ZSBzY2hlZHVsZWQgdHJhbnNhY3Rpb25cbiAgICAgIGxldCB7IHNjaGVkdWxlZFRyYW5zYWN0aW9uIH0gPSBhd2FpdCB0aGlzLnByb3h5QXBpLmNyZWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgdHJhbnNhY3Rpb25HYXMsXG4gICAgICAgIHRyYW5zYWN0aW9uRGF0YSxcbiAgICAgICAgbm9uY2VcbiAgICAgIH0pXG5cbiAgICAgIC8vIEdldCBmcmVzaCByZWNlbnQgYmxvY2toYXNoIHJpZ2h0IGJlZm9yZSBzaWduaW5nXG4gICAgICBjb25zb2xlLmxvZygnR2V0dGluZyBmcmVzaCBibG9ja2hhc2ggZm9yIGNvbnRyYWN0IGNhbGwuLi4nKVxuICAgICAgY29uc3QgeyBibG9ja2hhc2g6IGNvbnRyYWN0QmxvY2toYXNoLCBsYXN0VmFsaWRCbG9ja0hlaWdodDogY29udHJhY3RCbG9ja0hlaWdodCB9ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgnY29uZmlybWVkJylcbiAgICAgIGNvbnNvbGUubG9nKCdGcmVzaCBjb250cmFjdCBjYWxsIGJsb2NraGFzaDonLCBjb250cmFjdEJsb2NraGFzaClcbiAgICAgIGNvbnNvbGUubG9nKCdMYXN0IHZhbGlkIGJsb2NrIGhlaWdodDonLCBjb250cmFjdEJsb2NrSGVpZ2h0KVxuICAgICAgXG4gICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBjb250cmFjdEJsb2NraGFzaFxuICAgICAgc2NoZWR1bGVkVHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5XG5cbiAgICAgIC8vIFNpZ24gd2l0aCB3YWxsZXQgYWRhcHRlciBpbnN0ZWFkIG9mIGtleXBhaXIgKGxpa2UgaW4gdGVzdHMpXG4gICAgICAvLyBJbiB0ZXN0czogc2NoZWR1bGVkVHJhbnNhY3Rpb24uc2lnbih7IHB1YmxpY0tleTogc29sYW5hVXNlci5wdWJsaWNLZXksIHNlY3JldEtleTogc29sYW5hVXNlci5rZXlwYWlyLnNlY3JldEtleSB9KVxuICAgICAgLy8gSW4gZnJvbnRlbmQ6IHVzZSB3YWxsZXQgYWRhcHRlciBzaWduaW5nXG4gICAgICBjb25zb2xlLmxvZygnU2lnbmluZyBjb250cmFjdCBjYWxsIHdpdGggZnJlc2ggYmxvY2toYXNoLi4uJylcbiAgICAgIGNvbnN0IHNpZ25lZFR4ID0gYXdhaXQgdGhpcy5zb2xhbmFVc2VyLndhbGxldEFkYXB0ZXIuc2lnblRyYW5zYWN0aW9uKHNjaGVkdWxlZFRyYW5zYWN0aW9uKVxuICAgICAgXG4gICAgICAvLyBTZW5kIHRyYW5zYWN0aW9uIGltbWVkaWF0ZWx5XG4gICAgICBjb25zb2xlLmxvZygnU2VuZGluZyBjb250cmFjdCBjYWxsIHRyYW5zYWN0aW9uIGltbWVkaWF0ZWx5Li4uJylcbiAgICAgIGF3YWl0IHRoaXMuY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24oc2lnbmVkVHguc2VyaWFsaXplKCkpXG5cbiAgICAgIC8vIFdhaXQgZm9yIHRyYW5zYWN0aW9uIGV4ZWN1dGlvbiBvbiBOZW9uIEVWTVxuICAgICAgY29uc3QgdHJhbnNhY3Rpb25TdGF0dXMgPSBhd2FpdCB0aGlzLnByb3h5QXBpLndhaXRUcmFuc2FjdGlvblRyZWVFeGVjdXRpb24oXG4gICAgICAgIHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0LCBcbiAgICAgICAgbm9uY2UsIFxuICAgICAgICA2MDAwMFxuICAgICAgKVxuXG4gICAgICBpZiAodHJhbnNhY3Rpb25TdGF0dXMubGVuZ3RoID09PSAwIHx8IHRyYW5zYWN0aW9uU3RhdHVzWzBdLnN0YXR1cyAhPT0gJ1N1Y2Nlc3MnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ29udHJhY3QgcGF5bWVudCByZWNvcmRpbmcgZmFpbGVkLCBidXQgU09MIHRyYW5zZmVyIHN1Y2NlZWRlZCcpXG4gICAgICAgIGNvbnNvbGUubG9nKCdUcmFuc2ZlciBzaWduYXR1cmU6JywgdHJhbnNmZXJTaWduYXR1cmUpXG4gICAgICAgIC8vIERvbid0IHRocm93IGVycm9yIC0gdGhlIHBheW1lbnQgd2VudCB0aHJvdWdoIGV2ZW4gaWYgcmVjb3JkaW5nIGZhaWxlZFxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnUGF5bWVudCBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5IScpXG4gICAgICBjb25zb2xlLmxvZygnU09MIHRyYW5zZmVyOicsIHRyYW5zZmVyU2lnbmF0dXJlKVxuICAgICAgY29uc29sZS5sb2coJ0NvbnRyYWN0IHJlY29yZDonLCB0cmFuc2FjdGlvblN0YXR1c1swXT8udHJhbnNhY3Rpb25IYXNoKVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eEhhc2g6IHRyYW5zYWN0aW9uU3RhdHVzWzBdPy50cmFuc2FjdGlvbkhhc2ggfHwgJ2NvbnRyYWN0LXJlY29yZGluZy1mYWlsZWQnLFxuICAgICAgICB0cmFuc2ZlclNpZ25hdHVyZVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBheWluZyBsaW5rOicsIGVycm9yKVxuICAgICAgaWYgKHRyYW5zZmVyU2lnbmF0dXJlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdOb3RlOiBTT0wgdHJhbnNmZXIgbWF5IGhhdmUgc3VjY2VlZGVkOicsIHRyYW5zZmVyU2lnbmF0dXJlKVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVhY3RpdmF0ZSBhIHBheW1lbnQgbGlua1xuICAgKi9cbiAgYXN5bmMgZGVhY3RpdmF0ZUxpbmsobGlua0lkOiBzdHJpbmcpOiBQcm9taXNlPHsgdHhIYXNoOiBzdHJpbmcgfT4ge1xuICAgIGlmICghdGhpcy5zb2xhbmFVc2VyIHx8ICF0aGlzLmNvbnRyYWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBjb25uZWN0IHdhbGxldCBmaXJzdCcpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBjdXJyZW50IG5vbmNlXG4gICAgICBjb25zdCBub25jZSA9IE51bWJlcihhd2FpdCB0aGlzLnByb3h5QXBpLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQpKVxuICAgICAgY29uc29sZS5sb2coJ0N1cnJlbnQgbm9uY2U6Jywgbm9uY2UpXG5cbiAgICAgIC8vIFByZXBhcmUgY29udHJhY3QgY2FsbCBkYXRhXG4gICAgICBjb25zdCBpZmFjZSA9IG5ldyBldGhlcnMuSW50ZXJmYWNlKFNPTEFOQV9USVBDQVJEX0FCSSlcbiAgICAgIGNvbnN0IGRhdGEgPSBpZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoJ2RlYWN0aXZhdGVTb2xhbmFMaW5rJywgW2xpbmtJZF0pXG5cbiAgICAgIC8vIENyZWF0ZSB0cmFuc2FjdGlvbiBkYXRhXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkRhdGEgPSB7XG4gICAgICAgIGZyb206IHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0LFxuICAgICAgICB0bzogQ09OVFJBQ1RfQUREUkVTUyxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfVxuXG4gICAgICAvLyBFc3RpbWF0ZSBnYXNcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uR2FzID0gYXdhaXQgdGhpcy5wcm94eUFwaS5lc3RpbWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uR2FzKHtcbiAgICAgICAgc29sYW5hUGF5ZXI6IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXksXG4gICAgICAgIHRyYW5zYWN0aW9uczogW3RyYW5zYWN0aW9uRGF0YV0sXG4gICAgICB9KVxuXG4gICAgICAvLyBDcmVhdGUgc2NoZWR1bGVkIHRyYW5zYWN0aW9uXG4gICAgICBsZXQgeyBzY2hlZHVsZWRUcmFuc2FjdGlvbiB9ID0gYXdhaXQgdGhpcy5wcm94eUFwaS5jcmVhdGVTY2hlZHVsZWRUcmFuc2FjdGlvbih7XG4gICAgICAgIHRyYW5zYWN0aW9uR2FzLFxuICAgICAgICB0cmFuc2FjdGlvbkRhdGEsXG4gICAgICAgIG5vbmNlXG4gICAgICB9KVxuXG4gICAgICAvLyBHZXQgZnJlc2ggcmVjZW50IGJsb2NraGFzaCByaWdodCBiZWZvcmUgc2lnbmluZ1xuICAgICAgY29uc29sZS5sb2coJ0dldHRpbmcgZnJlc2ggYmxvY2toYXNoIGZvciBkZWFjdGl2YXRlIHRyYW5zYWN0aW9uLi4uJylcbiAgICAgIGNvbnN0IHsgYmxvY2toYXNoLCBsYXN0VmFsaWRCbG9ja0hlaWdodDogZGVhY3RpdmF0ZUJsb2NrSGVpZ2h0IH0gPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCdjb25maXJtZWQnKVxuICAgICAgY29uc29sZS5sb2coJ0ZyZXNoIGRlYWN0aXZhdGUgYmxvY2toYXNoOicsIGJsb2NraGFzaClcbiAgICAgIGNvbnNvbGUubG9nKCdMYXN0IHZhbGlkIGJsb2NrIGhlaWdodDonLCBkZWFjdGl2YXRlQmxvY2tIZWlnaHQpXG4gICAgICBcbiAgICAgIHNjaGVkdWxlZFRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGJsb2NraGFzaFxuICAgICAgc2NoZWR1bGVkVHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5XG5cbiAgICAgIC8vIFNpZ24gd2l0aCB3YWxsZXQgYWRhcHRlciBpbnN0ZWFkIG9mIGtleXBhaXIgKGxpa2UgaW4gdGVzdHMpXG4gICAgICAvLyBJbiB0ZXN0czogc2NoZWR1bGVkVHJhbnNhY3Rpb24uc2lnbih7IHB1YmxpY0tleTogc29sYW5hVXNlci5wdWJsaWNLZXksIHNlY3JldEtleTogc29sYW5hVXNlci5rZXlwYWlyLnNlY3JldEtleSB9KVxuICAgICAgLy8gSW4gZnJvbnRlbmQ6IHVzZSB3YWxsZXQgYWRhcHRlciBzaWduaW5nXG4gICAgICBjb25zb2xlLmxvZygnU2lnbmluZyBkZWFjdGl2YXRlIHRyYW5zYWN0aW9uIHdpdGggZnJlc2ggYmxvY2toYXNoLi4uJylcbiAgICAgIGNvbnN0IHNpZ25lZFR4ID0gYXdhaXQgdGhpcy5zb2xhbmFVc2VyLndhbGxldEFkYXB0ZXIuc2lnblRyYW5zYWN0aW9uKHNjaGVkdWxlZFRyYW5zYWN0aW9uKVxuICAgICAgXG4gICAgICAvLyBTZW5kIHRyYW5zYWN0aW9uIGltbWVkaWF0ZWx5XG4gICAgICBjb25zb2xlLmxvZygnU2VuZGluZyBkZWFjdGl2YXRlIHRyYW5zYWN0aW9uIGltbWVkaWF0ZWx5Li4uJylcbiAgICAgIGF3YWl0IHRoaXMuY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24oc2lnbmVkVHguc2VyaWFsaXplKCkpXG5cbiAgICAgIC8vIFdhaXQgZm9yIHRyYW5zYWN0aW9uIGV4ZWN1dGlvblxuICAgICAgY29uc3QgdHJhbnNhY3Rpb25TdGF0dXMgPSBhd2FpdCB0aGlzLnByb3h5QXBpLndhaXRUcmFuc2FjdGlvblRyZWVFeGVjdXRpb24oXG4gICAgICAgIHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0LCBcbiAgICAgICAgbm9uY2UsIFxuICAgICAgICA2MDAwMFxuICAgICAgKVxuXG4gICAgICBpZiAodHJhbnNhY3Rpb25TdGF0dXMubGVuZ3RoID09PSAwIHx8IHRyYW5zYWN0aW9uU3RhdHVzWzBdLnN0YXR1cyAhPT0gJ1N1Y2Nlc3MnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVhY3RpdmF0aW9uIHRyYW5zYWN0aW9uIGZhaWxlZCB0byBleGVjdXRlIG9uIE5lb24gRVZNJylcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHhIYXNoOiB0cmFuc2FjdGlvblN0YXR1c1swXS50cmFuc2FjdGlvbkhhc2hcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzaGFyZWFibGUgVVJMIGZvciBhIHBheW1lbnQgbGlua1xuICAgKi9cbiAgY3JlYXRlUGF5bWVudFVSTChsaW5rSWQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke3dpbmRvdy5sb2NhdGlvbi5vcmlnaW59P3BheT0ke2xpbmtJZH1gXG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdCBsaW5rIElEIGZyb20gVVJMXG4gICAqL1xuICBzdGF0aWMgZXh0cmFjdExpbmtJZEZyb21VUkwodXJsOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXJsT2JqID0gbmV3IFVSTCh1cmwpXG4gICAgICByZXR1cm4gdXJsT2JqLnNlYXJjaFBhcmFtcy5nZXQoJ3BheScpXG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzZXIncyBFVk0gYWRkcmVzcyBkZXJpdmVkIGZyb20gU29sYW5hIHB1YmxpYyBrZXlcbiAgICovXG4gIGdldFVzZXJFVk1BZGRyZXNzKCk6IHN0cmluZyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLnNvbGFuYVVzZXI/Lm5lb25XYWxsZXQgfHwgbnVsbFxuICB9XG59XG5cbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBzb2xhbmFOYXRpdmVDb250cmFjdCA9IG5ldyBTb2xhbmFOYXRpdmVDb250cmFjdCgpIl0sIm5hbWVzIjpbIkNvbm5lY3Rpb24iLCJQdWJsaWNLZXkiLCJOZW9uUHJveHlScGNBcGkiLCJjcmVhdGVCYWxhbmNlQWNjb3VudEluc3RydWN0aW9uIiwiZXRoZXJzIiwiaGV4bGlmeSIsInplcm9QYWRWYWx1ZSIsIkNvbnRyYWN0QUJJIiwiU09MQU5BX1RJUENBUkRfQUJJIiwiQ09OVFJBQ1RfQUREUkVTUyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19USVBDQVJEX0NPTlRSQUNUX0FERFJFU1MiLCJORU9OX0NPUkVfUlBDX1VSTCIsIk5FWFRfUFVCTElDX05FT05fUlBDX1VSTCIsIk5FT05fUFJPWFlfUlBDX1VSTCIsIlNPTEFOQV9SUENfVVJMIiwiU29sYW5hTmF0aXZlQ29udHJhY3QiLCJnZXRDaGFpbklkIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImlkIiwianNvbnJwYyIsInBhcmFtcyIsInJlc3VsdCIsImpzb24iLCJwYXJzZUludCIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJnZXROZW9uRXZtUHJvZ3JhbSIsImluaXRSZXN1bHQiLCJsb2ciLCJLZXlwYWlyIiwidGVtcEtleXBhaXIiLCJnZW5lcmF0ZSIsInByb3h5QXBpIiwiaW5pdCIsInNvbGFuYVVzZXIiLCJuZW9uRXZtUHJvZ3JhbSIsIkVycm9yIiwicHJvZ3JhbUFkZHJlc3MiLCJwcm9ncmFtSWQiLCJhcGlFcnJvciIsImluaXRXaXRoU29sYW5hV2FsbGV0Iiwid2FsbGV0QWRhcHRlciIsInB1YmxpY0tleSIsInRvQmFzZTU4IiwicHJvdmlkZXIiLCJjaGFpbklkIiwidG9rZW5NaW50QWRkcmVzcyIsIm5lb25XYWxsZXQiLCJiYWxhbmNlQWRkcmVzcyIsInJlYWRPbmx5UHJvdmlkZXIiLCJKc29uUnBjUHJvdmlkZXIiLCJjb250cmFjdCIsIkNvbnRyYWN0IiwidHhDb3VudCIsImdldFRyYW5zYWN0aW9uQ291bnQiLCJ2ZXJpZnlFcnJvciIsImNvZGUiLCJnZXRDb2RlIiwibGVuZ3RoIiwiY3JlYXRlUGF5bWVudExpbmsiLCJzdWdnZXN0ZWRBbW91bnRTT0wiLCJpc0ZsZXhpYmxlIiwiZGVzY3JpcHRpb24iLCJhbW91bnRMYW1wb3J0cyIsIk1hdGgiLCJmbG9vciIsInNjaGVkdWxlZFRyYW5zYWN0aW9uIiwicmVjZWlwdCIsIm5vbmNlIiwiTnVtYmVyIiwiaWZhY2UiLCJJbnRlcmZhY2UiLCJkYXRhIiwiZW5jb2RlRnVuY3Rpb25EYXRhIiwidHJhbnNhY3Rpb25EYXRhIiwiZnJvbSIsInRvIiwidHJhbnNhY3Rpb25HYXMiLCJlc3RpbWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uR2FzIiwic29sYW5hUGF5ZXIiLCJ0cmFuc2FjdGlvbnMiLCJjcmVhdGVTY2hlZHVsZWRUcmFuc2FjdGlvbiIsImFjY291bnQiLCJjb25uZWN0aW9uIiwiZ2V0QWNjb3VudEluZm8iLCJpbnN0cnVjdGlvbnMiLCJ1bnNoaWZ0IiwiYmxvY2toYXNoIiwiZ2V0TGF0ZXN0QmxvY2toYXNoIiwicmVjZW50QmxvY2toYXNoIiwiZmVlUGF5ZXIiLCJyZXF1aXJlZFNpZ25lcnMiLCJmb3JFYWNoIiwiaW5zdHJ1Y3Rpb24iLCJpbmRleCIsImtleXMiLCJrZXkiLCJrZXlJbmRleCIsInB1YmtleSIsImlzU2lnbmVyIiwiaXNXcml0YWJsZSIsInB1c2giLCJzaWduZXIiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJzZXJpYWxpemUiLCJzaWduIiwic2lnbmF0dXJlIiwic2VuZFJhd1RyYW5zYWN0aW9uIiwic2lnbmVkVHgiLCJzaWduVHJhbnNhY3Rpb24iLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJ0cmFuc2FjdGlvblN0YXR1cyIsIndhaXRUcmFuc2FjdGlvblRyZWVFeGVjdXRpb24iLCJ0eFN0YXR1cyIsInN0YXR1cyIsInRyYW5zYWN0aW9uSGFzaCIsImxpbmtJZCIsInR4SGFzaCIsImdldFRyYW5zYWN0aW9uUmVjZWlwdCIsImxvZ3MiLCJsb2dzQmxvb20iLCJjb250cmFjdEFkZHJlc3MiLCJnYXNVc2VkIiwiZWZmZWN0aXZlR2FzUHJpY2UiLCJuZW9uUmF3VHJhbnNhY3Rpb24iLCJhbGxOZW9uTG9ncyIsInNvbGFuYVRyYW5zYWN0aW9ucyIsInNvbFR4Iiwic29sYW5hSW5zdHJ1Y3Rpb25zIiwibmVvbkxvZ3MiLCJhZGRyZXNzIiwidG9Mb3dlckNhc2UiLCJldGhlcnNMb2ciLCJ0b3BpY3MiLCJwYXJzZWRMb2ciLCJwYXJzZUxvZyIsImFyZ3MiLCJlIiwidGVzdERhdGEiLCJnZXRTb2xhbmFQYXltZW50TGluayIsInJlYWRFcnJvciIsIm5lb25SZXZlcnREYXRhIiwicmV2ZXJ0UmVhc29uIiwidG9VdGY4U3RyaW5nIiwiZGVjb2RlRXJyb3IiLCJpc1JlZ2lzdGVyZWQiLCJpc1NvbGFuYVVzZXIiLCJyZWdpc3RyYXRpb25FcnJvciIsImluaXRSZWFkT25seUNvbnRyYWN0IiwiZ2V0UGF5bWVudExpbmsiLCJwYXltZW50TGluayIsImV2bUNyZWF0b3IiLCJzb2xhbmFDcmVhdG9yIiwiYW1vdW50IiwiaXNBY3RpdmUiLCJ0b3RhbFJlY2VpdmVkIiwicGF5bWVudENvdW50IiwiQmlnSW50Iiwic3RhcnRzV2l0aCIsImdldFVzZXJMaW5rcyIsInVzZXJFVk1BZGRyZXNzIiwiZ2V0VXNlclNvbGFuYUxpbmtzIiwicGF5TGluayIsImFtb3VudFNPTCIsImxpbmtEYXRhIiwidHJhbnNmZXJTaWduYXR1cmUiLCJoZXhTdHJpbmciLCJzbGljZSIsImJ5dGVzIiwiVWludDhBcnJheSIsIm1hdGNoIiwibWFwIiwiYnl0ZSIsInJlY2lwaWVudFB1YmtleSIsImxhc3QzMkJ5dGVzIiwicGFkZGVkQnl0ZXMiLCJzZXQiLCJTeXN0ZW1Qcm9ncmFtIiwiVHJhbnNhY3Rpb24iLCJ0cmFuc2Zlckl4IiwidHJhbnNmZXIiLCJmcm9tUHVia2V5IiwidG9QdWJrZXkiLCJsYW1wb3J0cyIsInRyYW5zZmVyVHgiLCJhZGQiLCJsYXN0VmFsaWRCbG9ja0hlaWdodCIsInRyYW5zZmVyQmxvY2tIZWlnaHQiLCJzaWduZWRUcmFuc2ZlclR4IiwiY29uZmlybVRyYW5zYWN0aW9uIiwicGF5ZXJTb2xhbmFCeXRlczMyIiwidG9CeXRlcyIsImNvbnRyYWN0QmxvY2toYXNoIiwiY29udHJhY3RCbG9ja0hlaWdodCIsImRlYWN0aXZhdGVMaW5rIiwiZGVhY3RpdmF0ZUJsb2NrSGVpZ2h0IiwiY3JlYXRlUGF5bWVudFVSTCIsIndpbmRvdyIsImxvY2F0aW9uIiwib3JpZ2luIiwiZXh0cmFjdExpbmtJZEZyb21VUkwiLCJ1cmwiLCJ1cmxPYmoiLCJVUkwiLCJzZWFyY2hQYXJhbXMiLCJnZXQiLCJnZXRVc2VyRVZNQWRkcmVzcyIsInNvbGFuYU5hdGl2ZUNvbnRyYWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/solana-native-contract.ts\n"));

/***/ })

});