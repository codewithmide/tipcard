"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/solana-native-contract.ts":
/*!*****************************************!*\
  !*** ./utils/solana-native-contract.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaNativeContract: function() { return /* binding */ SolanaNativeContract; },\n/* harmony export */   solanaNativeContract: function() { return /* binding */ solanaNativeContract; }\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var _neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @neonevm/solana-sign */ \"(app-pages-browser)/./node_modules/@neonevm/solana-sign/dist/esm/index.mjs\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/units.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _contractABI_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contractABI.json */ \"(app-pages-browser)/./utils/contractABI.json\");\n\n\n\n\n// Use the actual deployed contract ABI\nconst SOLANA_TIPCARD_ABI = _contractABI_json__WEBPACK_IMPORTED_MODULE_2__;\nconst CONTRACT_ADDRESS = \"0xCFE03c7c67456D094C0162F9030393FC2cCc40Cb\" || 0;\nconst NEON_CORE_RPC_URL = \"https://devnet.neonevm.org\" || 0;\nconst NEON_PROXY_RPC_URL = \"\".concat(NEON_CORE_RPC_URL, \"/sol\");\nconst SOLANA_RPC_URL = \"https://api.devnet.solana.com\";\nclass SolanaNativeContract {\n    /**\n   * Initialize with Solana wallet using the recommended SolanaNeonAccount approach\n   */ async initWithSolanaWallet(walletAdapter) {\n        if (!walletAdapter.publicKey) {\n            throw new Error(\"Wallet not connected\");\n        }\n        try {\n            var _this_solanaUser_balanceAddress, _this_solanaUser_balanceAddress1;\n            console.log(\"\\uD83D\\uDD27 Using recommended SolanaNeonAccount approach...\");\n            console.log(\"Wallet public key:\", walletAdapter.publicKey.toBase58());\n            // Use proxyApi.init with just the public key (like demo)\n            const { provider, chainId, solanaUser, tokenMintAddress, programAddress } = await this.proxyApi.init(walletAdapter.publicKey);\n            console.log(\"- Chain ID:\", chainId);\n            console.log(\"- Neon EVM Program:\", programAddress.toBase58());\n            // Store the result with wallet adapter for signing\n            this.chainId = chainId;\n            this.solanaUser = {\n                ...solanaUser,\n                walletAdapter: walletAdapter // Add wallet adapter for signing\n            };\n            // Create balance address if it doesn't exist (using SolanaNeonAccount approach)\n            if (!this.solanaUser.balanceAddress) {\n                const { SolanaNeonAccount } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @neonevm/solana-sign */ \"(app-pages-browser)/./node_modules/@neonevm/solana-sign/dist/esm/index.mjs\"));\n                const account = new SolanaNeonAccount(this.solanaUser.publicKey, this.solanaUser.neonEvmProgram, this.solanaUser.tokenMint, this.solanaUser.chainId);\n                this.solanaUser.balanceAddress = account.balanceAddress;\n            }\n            console.log(\"✅ Wallet initialized using SolanaNeonAccount approach!\");\n            console.log(\"\\uD83D\\uDCCD Connected wallet public key:\", walletAdapter.publicKey.toBase58());\n            console.log(\"\\uD83D\\uDCCD Solana user public key:\", this.solanaUser.publicKey.toBase58());\n            console.log(\"\\uD83D\\uDCCD Derived EVM address:\", this.solanaUser.neonWallet);\n            console.log(\"\\uD83D\\uDCB0 Balance address:\", ((_this_solanaUser_balanceAddress = this.solanaUser.balanceAddress) === null || _this_solanaUser_balanceAddress === void 0 ? void 0 : _this_solanaUser_balanceAddress.toBase58()) || \"Not available\");\n            console.log(\"\\uD83D\\uDD0D Full solanaUser object:\", this.solanaUser);\n            // Verify they match\n            if (walletAdapter.publicKey.toBase58() === this.solanaUser.publicKey.toBase58()) {\n                console.log(\"✅ Wallet public keys match correctly!\");\n            } else {\n                console.error(\"❌ MISMATCH: Wallet adapter and solana user have different public keys!\");\n                console.error(\"Wallet adapter:\", walletAdapter.publicKey.toBase58());\n                console.error(\"Solana user:\", this.solanaUser.publicKey.toBase58());\n            }\n            console.log(\"\\uD83D\\uDCB0 Final balance address:\", ((_this_solanaUser_balanceAddress1 = this.solanaUser.balanceAddress) === null || _this_solanaUser_balanceAddress1 === void 0 ? void 0 : _this_solanaUser_balanceAddress1.toBase58()) || \"Still not available\");\n            // Create contract instance\n            const readOnlyProvider = new ethers__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider(NEON_CORE_RPC_URL);\n            this.contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.Contract(CONTRACT_ADDRESS, SOLANA_TIPCARD_ABI, readOnlyProvider);\n            // Verify the derived EVM address is valid\n            console.log(\"\\uD83D\\uDD0D Verifying derived EVM address...\");\n            try {\n                // Check if this EVM address has been used before (has transaction history)\n                const txCount = await readOnlyProvider.getTransactionCount(this.solanaUser.neonWallet);\n                console.log(\"\\uD83D\\uDCCA EVM address transaction count:\", txCount);\n                if (txCount > 0) {\n                    console.log(\"✅ This EVM address has transaction history - it exists on-chain!\");\n                } else {\n                    console.log(\"ℹ️ This EVM address is new (no transaction history yet)\");\n                    console.log(\"ℹ️ The address will be registered on-chain when first transaction is made\");\n                }\n            } catch (verifyError) {\n                console.log(\"⚠️ Could not verify EVM address:\", verifyError);\n            }\n            // Verify contract is deployed at this address\n            try {\n                console.log(\"Verifying contract at address:\", CONTRACT_ADDRESS);\n                const code = await readOnlyProvider.getCode(CONTRACT_ADDRESS);\n                console.log(\"Contract code length:\", code.length);\n                if (code === \"0x\") {\n                    console.warn(\"⚠️ No contract code found at address:\", CONTRACT_ADDRESS);\n                    console.log(\"This might mean the contract is not deployed or address is incorrect\");\n                } else {\n                    console.log(\"✅ Contract found at address\");\n                    console.log(\"✅ Contract found and ready for transactions\");\n                }\n            } catch (verifyError) {\n                console.warn(\"Failed to verify contract:\", verifyError);\n            }\n        } catch (error) {\n            console.error(\"Failed to initialize Solana Native SDK:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Create a payment link using Solana Native SDK\n   */ async createPaymentLink(suggestedAmountSOL, isFlexible, description) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        // Convert SOL to lamports (1 SOL = 1e9 lamports)\n        const amountLamports = Math.floor(suggestedAmountSOL * 1e9);\n        try {\n            var _this_solanaUser_walletAdapter_publicKey, _scheduledTransaction_feePayer, _this_solanaUser_walletAdapter_publicKey1, _receipt_result;\n            // Get current nonce (exactly like working examples)\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Current nonce:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"createSolanaPaymentLink\", [\n                amountLamports,\n                isFlexible,\n                description\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Debug: Check what solanaPayer we're using\n            console.log(\"\\uD83D\\uDD0D Transaction creation debug:\");\n            console.log(\"- solanaPayer for gas estimation:\", this.solanaUser.publicKey.toBase58());\n            console.log(\"- from address in transactionData:\", transactionData.from);\n            console.log(\"- nonce:\", nonce);\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            console.log(\"Gas estimation completed\");\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            console.log(\"Scheduled transaction created\");\n            // Check if balance account exists, if not create it\n            const account = await this.connection.getAccountInfo(this.solanaUser.balanceAddress);\n            if (account === null) {\n                scheduledTransaction.instructions.unshift((0,_neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__.createBalanceAccountInstruction)(this.solanaUser.neonEvmProgram, this.solanaUser.publicKey, this.solanaUser.neonWallet, this.chainId));\n            }\n            // Sign and send transaction using exact test pattern\n            const { blockhash } = await this.connection.getLatestBlockhash();\n            scheduledTransaction.recentBlockhash = blockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            console.log(\"\\uD83D\\uDD0D Pre-signing debug:\");\n            console.log(\"- Connected wallet:\", (_this_solanaUser_walletAdapter_publicKey = this.solanaUser.walletAdapter.publicKey) === null || _this_solanaUser_walletAdapter_publicKey === void 0 ? void 0 : _this_solanaUser_walletAdapter_publicKey.toBase58());\n            console.log(\"- Solana user:\", this.solanaUser.publicKey.toBase58());\n            console.log(\"- Transaction feePayer:\", (_scheduledTransaction_feePayer = scheduledTransaction.feePayer) === null || _scheduledTransaction_feePayer === void 0 ? void 0 : _scheduledTransaction_feePayer.toBase58());\n            console.log(\"- Are they the same?\", ((_this_solanaUser_walletAdapter_publicKey1 = this.solanaUser.walletAdapter.publicKey) === null || _this_solanaUser_walletAdapter_publicKey1 === void 0 ? void 0 : _this_solanaUser_walletAdapter_publicKey1.toBase58()) === this.solanaUser.publicKey.toBase58());\n            // Sign the transaction using wallet adapter (frontend approach)\n            console.log(\"\\uD83D\\uDCDD Signing transaction with wallet adapter...\");\n            const signedTransaction = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            console.log(\"Submitting transaction...\");\n            const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n            console.log(\"✅ Transaction submitted!\");\n            console.log(\"\\uD83D\\uDD17 Signature:\", signature);\n            // Wait for confirmation\n            console.log(\"Waiting for payment confirmation...\");\n            await new Promise((resolve)=>setTimeout(resolve, 5000));\n            // Check transaction status\n            try {\n                var _confirmation_value;\n                const confirmation = await this.connection.getSignatureStatus(signature);\n                if ((_confirmation_value = confirmation.value) === null || _confirmation_value === void 0 ? void 0 : _confirmation_value.confirmationStatus) {\n                    console.log(\"✅ Payment status: \".concat(confirmation.value.confirmationStatus));\n                }\n                // Try to get payment details\n                try {\n                    console.log(\"   Getting payment transaction details...\");\n                    const neonTxResponse = await fetch(\"https://devnet.neonevm.org/sol\", {\n                        method: \"POST\",\n                        headers: {\n                            \"Content-Type\": \"application/json\"\n                        },\n                        body: JSON.stringify({\n                            method: \"neon_getTransactionBySenderNonce\",\n                            params: [\n                                this.solanaUser.publicKey.toBase58(),\n                                nonce\n                            ],\n                            id: 1,\n                            jsonrpc: \"2.0\"\n                        })\n                    });\n                    const neonTxResult = await neonTxResponse.json();\n                    if (neonTxResult.result && neonTxResult.result.hash) {\n                        console.log(\"✅ Neon EVM payment hash: \".concat(neonTxResult.result.hash));\n                        // Check updated link details\n                        try {\n                            const linkDetails = await solanaTipCard.getSolanaPaymentLink(createdLinkId);\n                            console.log(\"\\uD83C\\uDF89 Updated Payment Link Details:\");\n                            console.log(\"   Total Received: \".concat(ethers__WEBPACK_IMPORTED_MODULE_6__.formatUnits(linkDetails.totalReceived, 9), \" SOL\"));\n                            console.log(\"   Payment Count: \".concat(linkDetails.paymentCount));\n                            console.log(\"   Active: \".concat(linkDetails.isActive));\n                        } catch (linkError) {\n                            console.log(\"ℹ️ Could not get updated link details: \".concat(linkError.message));\n                        }\n                    } else {\n                        console.log(\"ℹ️ Neon EVM payment transaction not found yet (may still be processing)\");\n                    }\n                } catch (neonError) {\n                    console.log(\"ℹ️ Could not get Neon payment details: \".concat(neonError.message));\n                }\n            } catch (confirmError) {\n                console.log(\"ℹ️ Payment confirmation check: \".concat(confirmError.message));\n            }\n            console.log(\"\\uD83C\\uDF89 Payment transaction completed!\");\n            // Get the link ID from transaction receipt\n            const receipt = await this.proxyApi.getTransactionReceipt(txHash);\n            console.log(\"Full transaction receipt:\", JSON.stringify(receipt, null, 2));\n            // Extract all neonLogs from solanaTransactions\n            const allNeonLogs = [];\n            if ((_receipt_result = receipt.result) === null || _receipt_result === void 0 ? void 0 : _receipt_result.solanaTransactions) {\n                for (const solTx of receipt.result.solanaTransactions){\n                    if (solTx.solanaInstructions) {\n                        for (const instruction of solTx.solanaInstructions){\n                            if (instruction.neonLogs && instruction.neonLogs.length > 0) {\n                                allNeonLogs.push(...instruction.neonLogs);\n                            }\n                        }\n                    }\n                }\n            }\n            console.log(\"Found\", allNeonLogs.length, \"neonLogs to parse\");\n            // If we couldn't extract from logs, investigate further\n            if (!linkId) {\n                var _receipt_result1, _receipt_result2;\n                console.error(\"Could not extract link ID from transaction events!\");\n                console.log(\"This suggests the contract call may have failed silently\");\n                // Check if the transaction actually reverted\n                console.log(\"Checking for revert data...\");\n                if ((_receipt_result1 = receipt.result) === null || _receipt_result1 === void 0 ? void 0 : _receipt_result1.neonRevertData) {\n                    console.log(\"Revert data found:\", receipt.result.neonRevertData);\n                    try {\n                        // Try to decode the revert reason\n                        const revertReason = ethers__WEBPACK_IMPORTED_MODULE_7__.toUtf8String(receipt.result.neonRevertData);\n                        console.log(\"Revert reason:\", revertReason);\n                        throw new Error(\"Contract call reverted: \".concat(revertReason));\n                    } catch (decodeError) {\n                        console.log(\"Could not decode revert reason:\", decodeError);\n                        throw new Error(\"Contract call reverted with unknown reason\");\n                    }\n                }\n                // Let's try to understand why the event wasn't emitted\n                console.log(\"Analyzing function call...\");\n                console.log(\"Contract address:\", CONTRACT_ADDRESS);\n                console.log(\"From address:\", this.solanaUser.neonWallet);\n                console.log(\"Function data in raw tx:\", (_receipt_result2 = receipt.result) === null || _receipt_result2 === void 0 ? void 0 : _receipt_result2.neonRawTransaction);\n                // Check if user is registered\n                try {\n                    const isRegistered = await this.contract.isSolanaUser(this.solanaUser.neonWallet);\n                    console.log(\"Is user registered as Solana user:\", isRegistered);\n                    if (!isRegistered) {\n                        throw new Error(\"User is not registered as a Solana user with the contract. This is required to create payment links.\");\n                    }\n                } catch (registrationError) {\n                    console.error(\"Failed to check user registration:\", registrationError);\n                    throw registrationError;\n                }\n                // If we get here, something else went wrong\n                throw new Error(\"Payment link creation failed: Contract call executed but no event was emitted. The transaction may have failed silently.\");\n            }\n            return {\n                linkId,\n                txHash\n            };\n        } catch (error) {\n            console.error(\"Error creating payment link:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Initialize read-only contract access (without wallet)\n   */ async initReadOnlyContract() {\n        if (!this.contract) {\n            // Create a simple JSON RPC provider for read operations\n            const readOnlyProvider = new ethers__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider(NEON_CORE_RPC_URL);\n            this.contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.Contract(CONTRACT_ADDRESS, SOLANA_TIPCARD_ABI, readOnlyProvider);\n        }\n    }\n    /**\n   * Get payment link details\n   */ async getPaymentLink(linkId1) {\n        // Initialize contract if not already done\n        if (!this.contract) {\n            await this.initReadOnlyContract();\n        }\n        console.log(\"Getting payment link with ID:\", linkId1);\n        console.log(\"Contract address:\", CONTRACT_ADDRESS);\n        try {\n            const result = await this.contract.getSolanaPaymentLink(linkId1);\n            console.log(\"Raw contract result:\", result);\n            const paymentLink = {\n                evmCreator: result.evmCreator,\n                solanaCreator: result.solanaCreator,\n                amount: result.amount,\n                isFlexible: result.isFlexible,\n                isActive: result.isActive,\n                totalReceived: result.totalReceived,\n                paymentCount: Number(result.paymentCount),\n                description: result.description\n            };\n            // Check if this looks like an empty/non-existent link (transaction not processed yet)\n            if (result.evmCreator === \"0x0000000000000000000000000000000000000000\" && result.amount === BigInt(0) && !result.isActive) {\n                console.warn(\"Payment link appears to be empty/non-existent\");\n                // If this looks like a transaction hash (66 chars, starts with 0x), provide helpful info\n                if (linkId1.length === 66 && linkId1.startsWith(\"0x\")) {\n                    console.log(\"\\uD83D\\uDCA1 This appears to be a transaction hash - the payment link may still be processing\");\n                    console.log(\"\\uD83D\\uDCA1 Neon operators will eventually process this transaction and create the payment link\");\n                    console.log(\"\\uD83D\\uDCA1 You can bookmark this link and try again in a few minutes\");\n                    // For now, don't throw an error - let the UI handle the empty data gracefully\n                    console.log(\"Returning empty payment link data - transaction may still be processing\");\n                }\n            }\n            return paymentLink;\n        } catch (error) {\n            console.error(\"Contract call error:\", error);\n            throw new Error(\"Payment link not found or contract error\");\n        }\n    }\n    /**\n   * Get user's payment links\n   */ async getUserLinks(userEVMAddress) {\n        // Initialize contract if not already done\n        if (!this.contract) {\n            await this.initReadOnlyContract();\n        }\n        try {\n            return await this.contract.getUserSolanaLinks(userEVMAddress);\n        } catch (error) {\n            console.error(\"Error getting user links:\", error);\n            return [];\n        }\n    }\n    /**\n   * Pay a payment link using Solana Native SDK\n   */ async payLink(linkId1, amountSOL) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        console.log(\"Starting payment process...\");\n        console.log(\"Link ID:\", linkId1);\n        console.log(\"Amount SOL:\", amountSOL);\n        // First, get the payment link details to find the recipient\n        const linkData = await this.getPaymentLink(linkId1);\n        console.log(\"Payment link data:\", linkData);\n        if (!linkData.isActive) {\n            throw new Error(\"Payment link is no longer active\");\n        }\n        // Convert SOL to lamports\n        const amountLamports = Math.floor(amountSOL * 1e9);\n        let transferSignature;\n        try {\n            var _hexString_match, _transactionStatus_, _transactionStatus_1;\n            // Step 1: Perform the actual SOL transfer first\n            console.log(\"Step 1: Performing SOL transfer...\");\n            console.log(\"From:\", this.solanaUser.publicKey.toBase58());\n            console.log(\"To recipient bytes32:\", linkData.solanaCreator);\n            console.log(\"Amount lamports:\", amountLamports);\n            // Convert recipient Solana address from bytes32 to PublicKey\n            // Remove '0x' prefix if present\n            const hexString = linkData.solanaCreator.startsWith(\"0x\") ? linkData.solanaCreator.slice(2) : linkData.solanaCreator;\n            // Convert hex string to byte array\n            const bytes = new Uint8Array(((_hexString_match = hexString.match(/.{2}/g)) === null || _hexString_match === void 0 ? void 0 : _hexString_match.map((byte)=>parseInt(byte, 16))) || []);\n            // For bytes32 from Solana addresses, we need to find the actual 32-byte public key\n            // The bytes32 should contain the 32-byte Solana public key, possibly with leading zeros\n            let recipientPubkey;\n            if (bytes.length === 32) {\n                // Direct conversion from 32 bytes\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(bytes);\n            } else if (bytes.length > 32) {\n                // Take the last 32 bytes if it's longer\n                const last32Bytes = bytes.slice(-32);\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(last32Bytes);\n            } else {\n                // Pad with leading zeros if shorter\n                const paddedBytes = new Uint8Array(32);\n                paddedBytes.set(bytes, 32 - bytes.length);\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(paddedBytes);\n            }\n            console.log(\"Recipient PublicKey:\", recipientPubkey.toBase58());\n            // Create the SOL transfer transaction\n            const { SystemProgram, Transaction } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"));\n            // Create transfer instruction\n            const transferIx = SystemProgram.transfer({\n                fromPubkey: this.solanaUser.publicKey,\n                toPubkey: recipientPubkey,\n                lamports: amountLamports\n            });\n            // Create transaction\n            const transferTx = new Transaction().add(transferIx);\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for SOL transfer...\");\n            const { blockhash, lastValidBlockHeight: transferBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh SOL transfer blockhash:\", blockhash);\n            console.log(\"Last valid block height:\", transferBlockHeight);\n            transferTx.recentBlockhash = blockhash;\n            transferTx.feePayer = this.solanaUser.publicKey;\n            // Sign and send the SOL transfer immediately\n            console.log(\"Signing and sending SOL transfer with fresh blockhash...\");\n            const signedTransferTx = await this.solanaUser.walletAdapter.signTransaction(transferTx);\n            transferSignature = await this.connection.sendRawTransaction(signedTransferTx.serialize());\n            console.log(\"SOL transfer sent:\", transferSignature);\n            // Wait for transfer confirmation using the modern API\n            await this.connection.confirmTransaction({\n                signature: transferSignature,\n                ...await this.connection.getLatestBlockhash()\n            });\n            console.log(\"SOL transfer confirmed\");\n            // Step 2: Record the payment in the contract\n            console.log(\"Step 2: Recording payment in contract...\");\n            // Convert Solana PublicKey to bytes32\n            const payerSolanaBytes32 = (0,ethers__WEBPACK_IMPORTED_MODULE_8__.zeroPadValue)((0,ethers__WEBPACK_IMPORTED_MODULE_8__.hexlify)(this.solanaUser.publicKey.toBytes()), 32);\n            // Get current nonce\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Current nonce:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"paySolanaLink\", [\n                linkId1,\n                amountLamports,\n                payerSolanaBytes32\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for contract call...\");\n            const { blockhash: contractBlockhash, lastValidBlockHeight: contractBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh contract call blockhash:\", contractBlockhash);\n            console.log(\"Last valid block height:\", contractBlockHeight);\n            scheduledTransaction.recentBlockhash = contractBlockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            // Sign with wallet adapter (frontend approach)\n            console.log(\"Signing contract call with fresh blockhash...\");\n            const signedTx = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            // Send transaction immediately\n            console.log(\"Sending contract call transaction immediately...\");\n            await this.connection.sendRawTransaction(signedTx.serialize());\n            // Wait for transaction execution on Neon EVM\n            const transactionStatus = await this.proxyApi.waitTransactionTreeExecution(this.solanaUser.neonWallet, nonce, 60000);\n            if (transactionStatus.length === 0 || transactionStatus[0].status !== \"Success\") {\n                console.warn(\"Contract payment recording failed, but SOL transfer succeeded\");\n                console.log(\"Transfer signature:\", transferSignature);\n            // Don't throw error - the payment went through even if recording failed\n            }\n            console.log(\"Payment completed successfully!\");\n            console.log(\"SOL transfer:\", transferSignature);\n            console.log(\"Contract record:\", (_transactionStatus_ = transactionStatus[0]) === null || _transactionStatus_ === void 0 ? void 0 : _transactionStatus_.transactionHash);\n            return {\n                txHash: ((_transactionStatus_1 = transactionStatus[0]) === null || _transactionStatus_1 === void 0 ? void 0 : _transactionStatus_1.transactionHash) || \"contract-recording-failed\",\n                transferSignature\n            };\n        } catch (error) {\n            console.error(\"Error paying link:\", error);\n            if (transferSignature) {\n                console.log(\"Note: SOL transfer may have succeeded:\", transferSignature);\n            }\n            throw error;\n        }\n    }\n    /**\n   * Deactivate a payment link\n   */ async deactivateLink(linkId1) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        try {\n            // Get current nonce\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Current nonce:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"deactivateSolanaLink\", [\n                linkId1\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for deactivate transaction...\");\n            const { blockhash, lastValidBlockHeight: deactivateBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh deactivate blockhash:\", blockhash);\n            console.log(\"Last valid block height:\", deactivateBlockHeight);\n            scheduledTransaction.recentBlockhash = blockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            // Sign with wallet adapter (frontend approach)\n            console.log(\"Signing deactivate transaction with fresh blockhash...\");\n            const signedTx = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            // Send transaction immediately\n            console.log(\"Sending deactivate transaction immediately...\");\n            await this.connection.sendRawTransaction(signedTx.serialize());\n            // Wait for transaction execution\n            const transactionStatus = await this.proxyApi.waitTransactionTreeExecution(this.solanaUser.neonWallet, nonce, 60000);\n            if (transactionStatus.length === 0 || transactionStatus[0].status !== \"Success\") {\n                throw new Error(\"Deactivation transaction failed to execute on Neon EVM\");\n            }\n            return {\n                txHash: transactionStatus[0].transactionHash\n            };\n        } catch (error) {\n            throw error;\n        }\n    }\n    /**\n   * Create a shareable URL for a payment link\n   */ createPaymentURL(linkId1) {\n        return \"\".concat(window.location.origin, \"?pay=\").concat(linkId1);\n    }\n    /**\n   * Extract link ID from URL\n   */ static extractLinkIdFromURL(url) {\n        try {\n            const urlObj = new URL(url);\n            return urlObj.searchParams.get(\"pay\");\n        } catch (e) {\n            return null;\n        }\n    }\n    /**\n   * Get the user's EVM address derived from Solana public key\n   */ getUserEVMAddress() {\n        var _this_solanaUser;\n        return ((_this_solanaUser = this.solanaUser) === null || _this_solanaUser === void 0 ? void 0 : _this_solanaUser.neonWallet) || null;\n    }\n    constructor(){\n        this.chainId = null;\n        this.contract = null;\n        this.connection = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Connection(SOLANA_RPC_URL, \"confirmed\");\n        this.proxyApi = new _neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__.NeonProxyRpcApi(NEON_PROXY_RPC_URL);\n    }\n}\n// Export singleton instance\nconst solanaNativeContract = new SolanaNativeContract();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3NvbGFuYS1uYXRpdmUtY29udHJhY3QudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBZ0U7QUFDMEM7QUFDcEQ7QUFDVjtBQUU1Qyx1Q0FBdUM7QUFDdkMsTUFBTU8scUJBQXFCRCw4Q0FBV0E7QUFFdEMsTUFBTUUsbUJBQW1CQyw0Q0FBZ0QsSUFBSTtBQUM3RSxNQUFNRyxvQkFBb0JILDRCQUFvQyxJQUFJO0FBQ2xFLE1BQU1LLHFCQUFxQixHQUFxQixPQUFsQkYsbUJBQWtCO0FBQ2hELE1BQU1HLGlCQUFpQjtBQWFoQixNQUFNQztJQWFYOztHQUVDLEdBQ0QsTUFBTUMscUJBQXFCQyxhQUFrQixFQUFpQjtRQUM1RCxJQUFJLENBQUNBLGNBQWNDLFNBQVMsRUFBRTtZQUM1QixNQUFNLElBQUlDLE1BQU07UUFDbEI7UUFFQSxJQUFJO2dCQXVDaUMsaUNBV007WUFqRHpDQyxRQUFRQyxHQUFHLENBQUM7WUFDWkQsUUFBUUMsR0FBRyxDQUFDLHNCQUFzQkosY0FBY0MsU0FBUyxDQUFDSSxRQUFRO1lBRWxFLHlEQUF5RDtZQUN6RCxNQUFNLEVBQ0pDLFFBQVEsRUFDUkMsT0FBTyxFQUNQQyxVQUFVLEVBQ1ZDLGdCQUFnQixFQUNoQkMsY0FBYyxFQUNmLEdBQUcsTUFBTSxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDWixjQUFjQyxTQUFTO1lBRXBERSxRQUFRQyxHQUFHLENBQUMsZUFBZUc7WUFDM0JKLFFBQVFDLEdBQUcsQ0FBQyx1QkFBdUJNLGVBQWVMLFFBQVE7WUFFMUQsbURBQW1EO1lBQ25ELElBQUksQ0FBQ0UsT0FBTyxHQUFHQTtZQUNmLElBQUksQ0FBQ0MsVUFBVSxHQUFHO2dCQUNoQixHQUFHQSxVQUFVO2dCQUNiUixlQUFlQSxjQUFjLGlDQUFpQztZQUNoRTtZQUVBLGdGQUFnRjtZQUNoRixJQUFJLENBQUMsSUFBSSxDQUFDUSxVQUFVLENBQUNLLGNBQWMsRUFBRTtnQkFDbkMsTUFB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O1lBQ0YsTUFBTUMsU0FBUyxJQUFJQyxJQUFJRjtZQUN2QixPQUFPQyxPQUFPRSxZQUFZLENBQUNDLEdBQUcsQ0FBQztRQUNqQyxFQUFFLFVBQU07WUFDTixPQUFPO1FBQ1Q7SUFDRjtJQUVBOztHQUVDLEdBQ0RDLG9CQUFtQztZQUMxQjtRQUFQLE9BQU8seUJBQUksQ0FBQzVLLFVBQVUsY0FBZix3REFBaUJVLFVBQVUsS0FBSTtJQUN4QztJQXJyQkFtSyxhQUFjO2FBSE45SyxVQUF5QjthQUN6QmUsV0FBbUM7UUFHekMsSUFBSSxDQUFDZ0MsVUFBVSxHQUFHLElBQUl4RSx1REFBVUEsQ0FBQ2UsZ0JBQWdCO1FBQ2pELElBQUksQ0FBQ2MsUUFBUSxHQUFHLElBQUk1QixpRUFBZUEsQ0FBQ2E7SUFDdEM7QUFtckJGO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU0wTCx1QkFBdUIsSUFBSXhMLHVCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy9zb2xhbmEtbmF0aXZlLWNvbnRyYWN0LnRzP2Q0YzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29ubmVjdGlvbiwgUHVibGljS2V5LCBLZXlwYWlyIH0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJ1xuaW1wb3J0IHsgTmVvblByb3h5UnBjQXBpLCBjcmVhdGVCYWxhbmNlQWNjb3VudEluc3RydWN0aW9uLCBTb2xhbmFOZW9uQWNjb3VudCB9IGZyb20gJ0BuZW9uZXZtL3NvbGFuYS1zaWduJ1xuaW1wb3J0IHsgZXRoZXJzLCBoZXhsaWZ5LCB6ZXJvUGFkVmFsdWUgfSBmcm9tICdldGhlcnMnXG5pbXBvcnQgQ29udHJhY3RBQkkgZnJvbSAnLi9jb250cmFjdEFCSS5qc29uJ1xuXG4vLyBVc2UgdGhlIGFjdHVhbCBkZXBsb3llZCBjb250cmFjdCBBQklcbmNvbnN0IFNPTEFOQV9USVBDQVJEX0FCSSA9IENvbnRyYWN0QUJJXG5cbmNvbnN0IENPTlRSQUNUX0FERFJFU1MgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19USVBDQVJEX0NPTlRSQUNUX0FERFJFU1MgfHwgJzB4Q0ZFMDNjN2M2NzQ1NkQwOTRDMDE2MkY5MDMwMzkzRkMyY0NjNDBDYidcbmNvbnN0IE5FT05fQ09SRV9SUENfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfTkVPTl9SUENfVVJMIHx8ICdodHRwczovL2Rldm5ldC5uZW9uZXZtLm9yZydcbmNvbnN0IE5FT05fUFJPWFlfUlBDX1VSTCA9IGAke05FT05fQ09SRV9SUENfVVJMfS9zb2xgXG5jb25zdCBTT0xBTkFfUlBDX1VSTCA9ICdodHRwczovL2FwaS5kZXZuZXQuc29sYW5hLmNvbSdcblxuZXhwb3J0IGludGVyZmFjZSBQYXltZW50TGluayB7XG4gIGV2bUNyZWF0b3I6IHN0cmluZ1xuICBzb2xhbmFDcmVhdG9yOiBzdHJpbmdcbiAgYW1vdW50OiBiaWdpbnRcbiAgaXNGbGV4aWJsZTogYm9vbGVhblxuICBpc0FjdGl2ZTogYm9vbGVhblxuICB0b3RhbFJlY2VpdmVkOiBiaWdpbnRcbiAgcGF5bWVudENvdW50OiBudW1iZXJcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xufVxuXG5leHBvcnQgY2xhc3MgU29sYW5hTmF0aXZlQ29udHJhY3Qge1xuICBwcml2YXRlIGNvbm5lY3Rpb246IENvbm5lY3Rpb25cbiAgcHJpdmF0ZSBwcm94eUFwaTogTmVvblByb3h5UnBjQXBpXG4gIHByaXZhdGUgc29sYW5hVXNlcjogYW55XG4gIHByaXZhdGUgY2hhaW5JZDogbnVtYmVyIHwgbnVsbCA9IG51bGxcbiAgcHJpdmF0ZSBjb250cmFjdDogZXRoZXJzLkNvbnRyYWN0IHwgbnVsbCA9IG51bGxcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdGlvbihTT0xBTkFfUlBDX1VSTCwgJ2NvbmZpcm1lZCcpXG4gICAgdGhpcy5wcm94eUFwaSA9IG5ldyBOZW9uUHJveHlScGNBcGkoTkVPTl9QUk9YWV9SUENfVVJMKVxuICB9XG5cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB3aXRoIFNvbGFuYSB3YWxsZXQgdXNpbmcgdGhlIHJlY29tbWVuZGVkIFNvbGFuYU5lb25BY2NvdW50IGFwcHJvYWNoXG4gICAqL1xuICBhc3luYyBpbml0V2l0aFNvbGFuYVdhbGxldCh3YWxsZXRBZGFwdGVyOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXdhbGxldEFkYXB0ZXIucHVibGljS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBub3QgY29ubmVjdGVkJylcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/CflKcgVXNpbmcgcmVjb21tZW5kZWQgU29sYW5hTmVvbkFjY291bnQgYXBwcm9hY2guLi4nKVxuICAgICAgY29uc29sZS5sb2coJ1dhbGxldCBwdWJsaWMga2V5OicsIHdhbGxldEFkYXB0ZXIucHVibGljS2V5LnRvQmFzZTU4KCkpXG4gICAgICBcbiAgICAgIC8vIFVzZSBwcm94eUFwaS5pbml0IHdpdGgganVzdCB0aGUgcHVibGljIGtleSAobGlrZSBkZW1vKVxuICAgICAgY29uc3Qge1xuICAgICAgICBwcm92aWRlcixcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgc29sYW5hVXNlcixcbiAgICAgICAgdG9rZW5NaW50QWRkcmVzcyxcbiAgICAgICAgcHJvZ3JhbUFkZHJlc3NcbiAgICAgIH0gPSBhd2FpdCB0aGlzLnByb3h5QXBpLmluaXQod2FsbGV0QWRhcHRlci5wdWJsaWNLZXkpXG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCctIENoYWluIElEOicsIGNoYWluSWQpXG4gICAgICBjb25zb2xlLmxvZygnLSBOZW9uIEVWTSBQcm9ncmFtOicsIHByb2dyYW1BZGRyZXNzLnRvQmFzZTU4KCkpXG4gICAgICBcbiAgICAgIC8vIFN0b3JlIHRoZSByZXN1bHQgd2l0aCB3YWxsZXQgYWRhcHRlciBmb3Igc2lnbmluZ1xuICAgICAgdGhpcy5jaGFpbklkID0gY2hhaW5JZFxuICAgICAgdGhpcy5zb2xhbmFVc2VyID0ge1xuICAgICAgICAuLi5zb2xhbmFVc2VyLFxuICAgICAgICB3YWxsZXRBZGFwdGVyOiB3YWxsZXRBZGFwdGVyIC8vIEFkZCB3YWxsZXQgYWRhcHRlciBmb3Igc2lnbmluZ1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYmFsYW5jZSBhZGRyZXNzIGlmIGl0IGRvZXNuJ3QgZXhpc3QgKHVzaW5nIFNvbGFuYU5lb25BY2NvdW50IGFwcHJvYWNoKVxuICAgICAgaWYgKCF0aGlzLnNvbGFuYVVzZXIuYmFsYW5jZUFkZHJlc3MpIHtcbiAgICAgICAgY29uc3QgeyBTb2xhbmFOZW9uQWNjb3VudCB9ID0gYXdhaXQgaW1wb3J0KCdAbmVvbmV2bS9zb2xhbmEtc2lnbicpXG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBuZXcgU29sYW5hTmVvbkFjY291bnQoXG4gICAgICAgICAgdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleSxcbiAgICAgICAgICB0aGlzLnNvbGFuYVVzZXIubmVvbkV2bVByb2dyYW0sXG4gICAgICAgICAgdGhpcy5zb2xhbmFVc2VyLnRva2VuTWludCxcbiAgICAgICAgICB0aGlzLnNvbGFuYVVzZXIuY2hhaW5JZFxuICAgICAgICApXG4gICAgICAgIHRoaXMuc29sYW5hVXNlci5iYWxhbmNlQWRkcmVzcyA9IGFjY291bnQuYmFsYW5jZUFkZHJlc3NcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ+KchSBXYWxsZXQgaW5pdGlhbGl6ZWQgdXNpbmcgU29sYW5hTmVvbkFjY291bnQgYXBwcm9hY2ghJylcbiAgICAgIGNvbnNvbGUubG9nKCfwn5ONIENvbm5lY3RlZCB3YWxsZXQgcHVibGljIGtleTonLCB3YWxsZXRBZGFwdGVyLnB1YmxpY0tleS50b0Jhc2U1OCgpKVxuICAgICAgY29uc29sZS5sb2coJ/Cfk40gU29sYW5hIHVzZXIgcHVibGljIGtleTonLCB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LnRvQmFzZTU4KCkpXG4gICAgICBjb25zb2xlLmxvZygn8J+TjSBEZXJpdmVkIEVWTSBhZGRyZXNzOicsIHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0KVxuICAgICAgY29uc29sZS5sb2coJ/CfkrAgQmFsYW5jZSBhZGRyZXNzOicsIHRoaXMuc29sYW5hVXNlci5iYWxhbmNlQWRkcmVzcz8udG9CYXNlNTgoKSB8fCAnTm90IGF2YWlsYWJsZScpXG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBGdWxsIHNvbGFuYVVzZXIgb2JqZWN0OicsIHRoaXMuc29sYW5hVXNlcilcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IHRoZXkgbWF0Y2hcbiAgICAgIGlmICh3YWxsZXRBZGFwdGVyLnB1YmxpY0tleS50b0Jhc2U1OCgpID09PSB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LnRvQmFzZTU4KCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBXYWxsZXQgcHVibGljIGtleXMgbWF0Y2ggY29ycmVjdGx5IScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgTUlTTUFUQ0g6IFdhbGxldCBhZGFwdGVyIGFuZCBzb2xhbmEgdXNlciBoYXZlIGRpZmZlcmVudCBwdWJsaWMga2V5cyEnKVxuICAgICAgICBjb25zb2xlLmVycm9yKCdXYWxsZXQgYWRhcHRlcjonLCB3YWxsZXRBZGFwdGVyLnB1YmxpY0tleS50b0Jhc2U1OCgpKVxuICAgICAgICBjb25zb2xlLmVycm9yKCdTb2xhbmEgdXNlcjonLCB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LnRvQmFzZTU4KCkpXG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZygn8J+SsCBGaW5hbCBiYWxhbmNlIGFkZHJlc3M6JywgdGhpcy5zb2xhbmFVc2VyLmJhbGFuY2VBZGRyZXNzPy50b0Jhc2U1OCgpIHx8ICdTdGlsbCBub3QgYXZhaWxhYmxlJylcblxuICAgICAgLy8gQ3JlYXRlIGNvbnRyYWN0IGluc3RhbmNlXG4gICAgICBjb25zdCByZWFkT25seVByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoTkVPTl9DT1JFX1JQQ19VUkwpXG4gICAgICB0aGlzLmNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChDT05UUkFDVF9BRERSRVNTLCBTT0xBTkFfVElQQ0FSRF9BQkksIHJlYWRPbmx5UHJvdmlkZXIpXG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSB0aGUgZGVyaXZlZCBFVk0gYWRkcmVzcyBpcyB2YWxpZFxuICAgICAgY29uc29sZS5sb2coJ/CflI0gVmVyaWZ5aW5nIGRlcml2ZWQgRVZNIGFkZHJlc3MuLi4nKVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBFVk0gYWRkcmVzcyBoYXMgYmVlbiB1c2VkIGJlZm9yZSAoaGFzIHRyYW5zYWN0aW9uIGhpc3RvcnkpXG4gICAgICAgIGNvbnN0IHR4Q291bnQgPSBhd2FpdCByZWFkT25seVByb3ZpZGVyLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQpXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OKIEVWTSBhZGRyZXNzIHRyYW5zYWN0aW9uIGNvdW50OicsIHR4Q291bnQpXG4gICAgICAgIFxuICAgICAgICBpZiAodHhDb3VudCA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIFRoaXMgRVZNIGFkZHJlc3MgaGFzIHRyYW5zYWN0aW9uIGhpc3RvcnkgLSBpdCBleGlzdHMgb24tY2hhaW4hJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygn4oS577iPIFRoaXMgRVZNIGFkZHJlc3MgaXMgbmV3IChubyB0cmFuc2FjdGlvbiBoaXN0b3J5IHlldCknKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCfihLnvuI8gVGhlIGFkZHJlc3Mgd2lsbCBiZSByZWdpc3RlcmVkIG9uLWNoYWluIHdoZW4gZmlyc3QgdHJhbnNhY3Rpb24gaXMgbWFkZScpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHZlcmlmeUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfimqDvuI8gQ291bGQgbm90IHZlcmlmeSBFVk0gYWRkcmVzczonLCB2ZXJpZnlFcnJvcilcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IGNvbnRyYWN0IGlzIGRlcGxveWVkIGF0IHRoaXMgYWRkcmVzc1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coJ1ZlcmlmeWluZyBjb250cmFjdCBhdCBhZGRyZXNzOicsIENPTlRSQUNUX0FERFJFU1MpXG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCByZWFkT25seVByb3ZpZGVyLmdldENvZGUoQ09OVFJBQ1RfQUREUkVTUylcbiAgICAgICAgY29uc29sZS5sb2coJ0NvbnRyYWN0IGNvZGUgbGVuZ3RoOicsIGNvZGUubGVuZ3RoKVxuICAgICAgICBpZiAoY29kZSA9PT0gJzB4Jykge1xuICAgICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIE5vIGNvbnRyYWN0IGNvZGUgZm91bmQgYXQgYWRkcmVzczonLCBDT05UUkFDVF9BRERSRVNTKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCdUaGlzIG1pZ2h0IG1lYW4gdGhlIGNvbnRyYWN0IGlzIG5vdCBkZXBsb3llZCBvciBhZGRyZXNzIGlzIGluY29ycmVjdCcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBDb250cmFjdCBmb3VuZCBhdCBhZGRyZXNzJylcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIENvbnRyYWN0IGZvdW5kIGFuZCByZWFkeSBmb3IgdHJhbnNhY3Rpb25zJylcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAodmVyaWZ5RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gdmVyaWZ5IGNvbnRyYWN0OicsIHZlcmlmeUVycm9yKVxuICAgICAgfVxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIFNvbGFuYSBOYXRpdmUgU0RLOicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgcGF5bWVudCBsaW5rIHVzaW5nIFNvbGFuYSBOYXRpdmUgU0RLXG4gICAqL1xuICBhc3luYyBjcmVhdGVQYXltZW50TGluayhcbiAgICBzdWdnZXN0ZWRBbW91bnRTT0w6IG51bWJlcixcbiAgICBpc0ZsZXhpYmxlOiBib29sZWFuLFxuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgKTogUHJvbWlzZTx7IGxpbmtJZDogc3RyaW5nOyB0eEhhc2g6IHN0cmluZyB9PiB7XG4gICAgaWYgKCF0aGlzLnNvbGFuYVVzZXIgfHwgIXRoaXMuY29udHJhY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIGNvbm5lY3Qgd2FsbGV0IGZpcnN0JylcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IFNPTCB0byBsYW1wb3J0cyAoMSBTT0wgPSAxZTkgbGFtcG9ydHMpXG4gICAgY29uc3QgYW1vdW50TGFtcG9ydHMgPSBNYXRoLmZsb29yKHN1Z2dlc3RlZEFtb3VudFNPTCAqIDFlOSlcblxuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgY3VycmVudCBub25jZSAoZXhhY3RseSBsaWtlIHdvcmtpbmcgZXhhbXBsZXMpXG4gICAgICBjb25zdCBub25jZSA9IE51bWJlcihhd2FpdCB0aGlzLnByb3h5QXBpLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQpKVxuICAgICAgY29uc29sZS5sb2coJ0N1cnJlbnQgbm9uY2U6Jywgbm9uY2UpXG5cbiAgICAgIC8vIFByZXBhcmUgY29udHJhY3QgY2FsbCBkYXRhXG4gICAgICBjb25zdCBpZmFjZSA9IG5ldyBldGhlcnMuSW50ZXJmYWNlKFNPTEFOQV9USVBDQVJEX0FCSSlcbiAgICAgIGNvbnN0IGRhdGEgPSBpZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoJ2NyZWF0ZVNvbGFuYVBheW1lbnRMaW5rJywgW1xuICAgICAgICBhbW91bnRMYW1wb3J0cyxcbiAgICAgICAgaXNGbGV4aWJsZSxcbiAgICAgICAgZGVzY3JpcHRpb25cbiAgICAgIF0pXG5cbiAgICAgIC8vIENyZWF0ZSB0cmFuc2FjdGlvbiBkYXRhXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkRhdGEgPSB7XG4gICAgICAgIGZyb206IHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0LFxuICAgICAgICB0bzogQ09OVFJBQ1RfQUREUkVTUyxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfVxuXG4gICAgICAvLyBEZWJ1ZzogQ2hlY2sgd2hhdCBzb2xhbmFQYXllciB3ZSdyZSB1c2luZ1xuICAgICAgY29uc29sZS5sb2coJ/CflI0gVHJhbnNhY3Rpb24gY3JlYXRpb24gZGVidWc6JylcbiAgICAgIGNvbnNvbGUubG9nKCctIHNvbGFuYVBheWVyIGZvciBnYXMgZXN0aW1hdGlvbjonLCB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LnRvQmFzZTU4KCkpXG4gICAgICBjb25zb2xlLmxvZygnLSBmcm9tIGFkZHJlc3MgaW4gdHJhbnNhY3Rpb25EYXRhOicsIHRyYW5zYWN0aW9uRGF0YS5mcm9tKVxuICAgICAgY29uc29sZS5sb2coJy0gbm9uY2U6Jywgbm9uY2UpXG5cbiAgICAgIC8vIEVzdGltYXRlIGdhc1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25HYXMgPSBhd2FpdCB0aGlzLnByb3h5QXBpLmVzdGltYXRlU2NoZWR1bGVkVHJhbnNhY3Rpb25HYXMoe1xuICAgICAgICBzb2xhbmFQYXllcjogdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleSxcbiAgICAgICAgdHJhbnNhY3Rpb25zOiBbdHJhbnNhY3Rpb25EYXRhXSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnNvbGUubG9nKCdHYXMgZXN0aW1hdGlvbiBjb21wbGV0ZWQnKVxuXG4gICAgICAvLyBDcmVhdGUgc2NoZWR1bGVkIHRyYW5zYWN0aW9uXG4gICAgICBsZXQgeyBzY2hlZHVsZWRUcmFuc2FjdGlvbiB9ID0gYXdhaXQgdGhpcy5wcm94eUFwaS5jcmVhdGVTY2hlZHVsZWRUcmFuc2FjdGlvbih7XG4gICAgICAgIHRyYW5zYWN0aW9uR2FzLFxuICAgICAgICB0cmFuc2FjdGlvbkRhdGEsXG4gICAgICAgIG5vbmNlXG4gICAgICB9KVxuXG4gICAgICBjb25zb2xlLmxvZygnU2NoZWR1bGVkIHRyYW5zYWN0aW9uIGNyZWF0ZWQnKVxuXG4gICAgICAvLyBDaGVjayBpZiBiYWxhbmNlIGFjY291bnQgZXhpc3RzLCBpZiBub3QgY3JlYXRlIGl0XG4gICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldEFjY291bnRJbmZvKHRoaXMuc29sYW5hVXNlci5iYWxhbmNlQWRkcmVzcylcbiAgICAgIGlmIChhY2NvdW50ID09PSBudWxsKSB7XG4gICAgICAgIHNjaGVkdWxlZFRyYW5zYWN0aW9uLmluc3RydWN0aW9ucy51bnNoaWZ0KFxuICAgICAgICAgIGNyZWF0ZUJhbGFuY2VBY2NvdW50SW5zdHJ1Y3Rpb24oXG4gICAgICAgICAgICB0aGlzLnNvbGFuYVVzZXIubmVvbkV2bVByb2dyYW0sXG4gICAgICAgICAgICB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LFxuICAgICAgICAgICAgdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsXG4gICAgICAgICAgICB0aGlzLmNoYWluSWQhXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIFNpZ24gYW5kIHNlbmQgdHJhbnNhY3Rpb24gdXNpbmcgZXhhY3QgdGVzdCBwYXR0ZXJuXG4gICAgICBjb25zdCB7IGJsb2NraGFzaCB9ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgpXG4gICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBibG9ja2hhc2hcbiAgICAgIHNjaGVkdWxlZFRyYW5zYWN0aW9uLmZlZVBheWVyID0gdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBQcmUtc2lnbmluZyBkZWJ1ZzonKVxuICAgICAgY29uc29sZS5sb2coJy0gQ29ubmVjdGVkIHdhbGxldDonLCB0aGlzLnNvbGFuYVVzZXIud2FsbGV0QWRhcHRlci5wdWJsaWNLZXk/LnRvQmFzZTU4KCkpXG4gICAgICBjb25zb2xlLmxvZygnLSBTb2xhbmEgdXNlcjonLCB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LnRvQmFzZTU4KCkpXG4gICAgICBjb25zb2xlLmxvZygnLSBUcmFuc2FjdGlvbiBmZWVQYXllcjonLCBzY2hlZHVsZWRUcmFuc2FjdGlvbi5mZWVQYXllcj8udG9CYXNlNTgoKSlcbiAgICAgIGNvbnNvbGUubG9nKCctIEFyZSB0aGV5IHRoZSBzYW1lPycsIHRoaXMuc29sYW5hVXNlci53YWxsZXRBZGFwdGVyLnB1YmxpY0tleT8udG9CYXNlNTgoKSA9PT0gdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleS50b0Jhc2U1OCgpKVxuICAgICAgXG4gICAgICAvLyBTaWduIHRoZSB0cmFuc2FjdGlvbiB1c2luZyB3YWxsZXQgYWRhcHRlciAoZnJvbnRlbmQgYXBwcm9hY2gpXG4gICAgICBjb25zb2xlLmxvZygn8J+TnSBTaWduaW5nIHRyYW5zYWN0aW9uIHdpdGggd2FsbGV0IGFkYXB0ZXIuLi4nKVxuICAgICAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb24gPSBhd2FpdCB0aGlzLnNvbGFuYVVzZXIud2FsbGV0QWRhcHRlci5zaWduVHJhbnNhY3Rpb24oc2NoZWR1bGVkVHJhbnNhY3Rpb24pXG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdTdWJtaXR0aW5nIHRyYW5zYWN0aW9uLi4uJylcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24uc2VyaWFsaXplKCkpXG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgVHJhbnNhY3Rpb24gc3VibWl0dGVkIScpXG4gICAgICBjb25zb2xlLmxvZygn8J+UlyBTaWduYXR1cmU6Jywgc2lnbmF0dXJlKVxuXG4gICAgICAvLyBXYWl0IGZvciBjb25maXJtYXRpb25cbiAgICAgIGNvbnNvbGUubG9nKGBXYWl0aW5nIGZvciBwYXltZW50IGNvbmZpcm1hdGlvbi4uLmApO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMDApKTtcblxuICAgICAgLy8gQ2hlY2sgdHJhbnNhY3Rpb24gc3RhdHVzXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjb25maXJtYXRpb24gPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZ2V0U2lnbmF0dXJlU3RhdHVzKHNpZ25hdHVyZSk7XG4gICAgICAgIGlmIChjb25maXJtYXRpb24udmFsdWU/LmNvbmZpcm1hdGlvblN0YXR1cykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgUGF5bWVudCBzdGF0dXM6ICR7Y29uZmlybWF0aW9uLnZhbHVlLmNvbmZpcm1hdGlvblN0YXR1c31gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyeSB0byBnZXQgcGF5bWVudCBkZXRhaWxzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYCAgIEdldHRpbmcgcGF5bWVudCB0cmFuc2FjdGlvbiBkZXRhaWxzLi4uYCk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgbmVvblR4UmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9kZXZuZXQubmVvbmV2bS5vcmcvc29sJywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgbWV0aG9kOiBcIm5lb25fZ2V0VHJhbnNhY3Rpb25CeVNlbmRlck5vbmNlXCIsXG4gICAgICAgICAgICAgIHBhcmFtczogW3RoaXMuc29sYW5hVXNlci5wdWJsaWNLZXkudG9CYXNlNTgoKSwgbm9uY2VdLFxuICAgICAgICAgICAgICBpZDogMSxcbiAgICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBuZW9uVHhSZXN1bHQgPSBhd2FpdCBuZW9uVHhSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKG5lb25UeFJlc3VsdC5yZXN1bHQgJiYgbmVvblR4UmVzdWx0LnJlc3VsdC5oYXNoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIE5lb24gRVZNIHBheW1lbnQgaGFzaDogJHtuZW9uVHhSZXN1bHQucmVzdWx0Lmhhc2h9YCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENoZWNrIHVwZGF0ZWQgbGluayBkZXRhaWxzXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBsaW5rRGV0YWlscyA9IGF3YWl0IHNvbGFuYVRpcENhcmQuZ2V0U29sYW5hUGF5bWVudExpbmsoY3JlYXRlZExpbmtJZCk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn46JIFVwZGF0ZWQgUGF5bWVudCBMaW5rIERldGFpbHM6YCk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBUb3RhbCBSZWNlaXZlZDogJHtldGhlcnMuZm9ybWF0VW5pdHMobGlua0RldGFpbHMudG90YWxSZWNlaXZlZCwgOSl9IFNPTGApO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgUGF5bWVudCBDb3VudDogJHtsaW5rRGV0YWlscy5wYXltZW50Q291bnR9YCk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBBY3RpdmU6ICR7bGlua0RldGFpbHMuaXNBY3RpdmV9YCk7XG4gICAgICAgICAgICB9IGNhdGNoIChsaW5rRXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYOKEue+4jyBDb3VsZCBub3QgZ2V0IHVwZGF0ZWQgbGluayBkZXRhaWxzOiAke2xpbmtFcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4oS577iPIE5lb24gRVZNIHBheW1lbnQgdHJhbnNhY3Rpb24gbm90IGZvdW5kIHlldCAobWF5IHN0aWxsIGJlIHByb2Nlc3NpbmcpYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICB9IGNhdGNoIChuZW9uRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4oS577iPIENvdWxkIG5vdCBnZXQgTmVvbiBwYXltZW50IGRldGFpbHM6ICR7bmVvbkVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICB9IGNhdGNoIChjb25maXJtRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coYOKEue+4jyBQYXltZW50IGNvbmZpcm1hdGlvbiBjaGVjazogJHtjb25maXJtRXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYPCfjokgUGF5bWVudCB0cmFuc2FjdGlvbiBjb21wbGV0ZWQhYCk7XG5cbiAgICAgIC8vIEdldCB0aGUgbGluayBJRCBmcm9tIHRyYW5zYWN0aW9uIHJlY2VpcHRcbiAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3h5QXBpLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpXG4gICAgICBjb25zb2xlLmxvZygnRnVsbCB0cmFuc2FjdGlvbiByZWNlaXB0OicsIEpTT04uc3RyaW5naWZ5KHJlY2VpcHQsIG51bGwsIDIpKVxuICAgICAgXG5cbiAgICAgIC8vIEV4dHJhY3QgYWxsIG5lb25Mb2dzIGZyb20gc29sYW5hVHJhbnNhY3Rpb25zXG4gICAgICBjb25zdCBhbGxOZW9uTG9nczogYW55W10gPSBbXVxuICAgICAgaWYgKHJlY2VpcHQucmVzdWx0Py5zb2xhbmFUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBzb2xUeCBvZiByZWNlaXB0LnJlc3VsdC5zb2xhbmFUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICBpZiAoc29sVHguc29sYW5hSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIHNvbFR4LnNvbGFuYUluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24ubmVvbkxvZ3MgJiYgaW5zdHJ1Y3Rpb24ubmVvbkxvZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGFsbE5lb25Mb2dzLnB1c2goLi4uaW5zdHJ1Y3Rpb24ubmVvbkxvZ3MpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ0ZvdW5kJywgYWxsTmVvbkxvZ3MubGVuZ3RoLCAnbmVvbkxvZ3MgdG8gcGFyc2UnKVxuXG5cbiAgICAgIC8vIElmIHdlIGNvdWxkbid0IGV4dHJhY3QgZnJvbSBsb2dzLCBpbnZlc3RpZ2F0ZSBmdXJ0aGVyXG4gICAgICBpZiAoIWxpbmtJZCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdDb3VsZCBub3QgZXh0cmFjdCBsaW5rIElEIGZyb20gdHJhbnNhY3Rpb24gZXZlbnRzIScpXG4gICAgICAgIGNvbnNvbGUubG9nKCdUaGlzIHN1Z2dlc3RzIHRoZSBjb250cmFjdCBjYWxsIG1heSBoYXZlIGZhaWxlZCBzaWxlbnRseScpXG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgdHJhbnNhY3Rpb24gYWN0dWFsbHkgcmV2ZXJ0ZWRcbiAgICAgICAgY29uc29sZS5sb2coJ0NoZWNraW5nIGZvciByZXZlcnQgZGF0YS4uLicpXG4gICAgICAgIGlmIChyZWNlaXB0LnJlc3VsdD8ubmVvblJldmVydERhdGEpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnUmV2ZXJ0IGRhdGEgZm91bmQ6JywgcmVjZWlwdC5yZXN1bHQubmVvblJldmVydERhdGEpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBkZWNvZGUgdGhlIHJldmVydCByZWFzb25cbiAgICAgICAgICAgIGNvbnN0IHJldmVydFJlYXNvbiA9IGV0aGVycy50b1V0ZjhTdHJpbmcocmVjZWlwdC5yZXN1bHQubmVvblJldmVydERhdGEpXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUmV2ZXJ0IHJlYXNvbjonLCByZXZlcnRSZWFzb24pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnRyYWN0IGNhbGwgcmV2ZXJ0ZWQ6ICR7cmV2ZXJ0UmVhc29ufWApXG4gICAgICAgICAgfSBjYXRjaCAoZGVjb2RlRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb3VsZCBub3QgZGVjb2RlIHJldmVydCByZWFzb246JywgZGVjb2RlRXJyb3IpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRyYWN0IGNhbGwgcmV2ZXJ0ZWQgd2l0aCB1bmtub3duIHJlYXNvbicpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBMZXQncyB0cnkgdG8gdW5kZXJzdGFuZCB3aHkgdGhlIGV2ZW50IHdhc24ndCBlbWl0dGVkXG4gICAgICAgIGNvbnNvbGUubG9nKCdBbmFseXppbmcgZnVuY3Rpb24gY2FsbC4uLicpXG4gICAgICAgIGNvbnNvbGUubG9nKCdDb250cmFjdCBhZGRyZXNzOicsIENPTlRSQUNUX0FERFJFU1MpXG4gICAgICAgIGNvbnNvbGUubG9nKCdGcm9tIGFkZHJlc3M6JywgdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQpXG4gICAgICAgIGNvbnNvbGUubG9nKCdGdW5jdGlvbiBkYXRhIGluIHJhdyB0eDonLCByZWNlaXB0LnJlc3VsdD8ubmVvblJhd1RyYW5zYWN0aW9uKVxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgdXNlciBpcyByZWdpc3RlcmVkXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgaXNSZWdpc3RlcmVkID0gYXdhaXQgdGhpcy5jb250cmFjdCEuaXNTb2xhbmFVc2VyKHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0KVxuICAgICAgICAgIGNvbnNvbGUubG9nKCdJcyB1c2VyIHJlZ2lzdGVyZWQgYXMgU29sYW5hIHVzZXI6JywgaXNSZWdpc3RlcmVkKVxuICAgICAgICAgIFxuICAgICAgICAgIGlmICghaXNSZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZXIgaXMgbm90IHJlZ2lzdGVyZWQgYXMgYSBTb2xhbmEgdXNlciB3aXRoIHRoZSBjb250cmFjdC4gVGhpcyBpcyByZXF1aXJlZCB0byBjcmVhdGUgcGF5bWVudCBsaW5rcy4nKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAocmVnaXN0cmF0aW9uRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY2hlY2sgdXNlciByZWdpc3RyYXRpb246JywgcmVnaXN0cmF0aW9uRXJyb3IpXG4gICAgICAgICAgdGhyb3cgcmVnaXN0cmF0aW9uRXJyb3JcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIHNvbWV0aGluZyBlbHNlIHdlbnQgd3JvbmdcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXltZW50IGxpbmsgY3JlYXRpb24gZmFpbGVkOiBDb250cmFjdCBjYWxsIGV4ZWN1dGVkIGJ1dCBubyBldmVudCB3YXMgZW1pdHRlZC4gVGhlIHRyYW5zYWN0aW9uIG1heSBoYXZlIGZhaWxlZCBzaWxlbnRseS4nKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5rSWQsXG4gICAgICAgIHR4SGFzaFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHBheW1lbnQgbGluazonLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgcmVhZC1vbmx5IGNvbnRyYWN0IGFjY2VzcyAod2l0aG91dCB3YWxsZXQpXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGluaXRSZWFkT25seUNvbnRyYWN0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5jb250cmFjdCkge1xuICAgICAgLy8gQ3JlYXRlIGEgc2ltcGxlIEpTT04gUlBDIHByb3ZpZGVyIGZvciByZWFkIG9wZXJhdGlvbnNcbiAgICAgIGNvbnN0IHJlYWRPbmx5UHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihORU9OX0NPUkVfUlBDX1VSTClcbiAgICAgIHRoaXMuY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KENPTlRSQUNUX0FERFJFU1MsIFNPTEFOQV9USVBDQVJEX0FCSSwgcmVhZE9ubHlQcm92aWRlcilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHBheW1lbnQgbGluayBkZXRhaWxzXG4gICAqL1xuICBhc3luYyBnZXRQYXltZW50TGluayhsaW5rSWQ6IHN0cmluZyk6IFByb21pc2U8UGF5bWVudExpbms+IHtcbiAgICAvLyBJbml0aWFsaXplIGNvbnRyYWN0IGlmIG5vdCBhbHJlYWR5IGRvbmVcbiAgICBpZiAoIXRoaXMuY29udHJhY3QpIHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdFJlYWRPbmx5Q29udHJhY3QoKVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIHBheW1lbnQgbGluayB3aXRoIElEOicsIGxpbmtJZClcbiAgICBjb25zb2xlLmxvZygnQ29udHJhY3QgYWRkcmVzczonLCBDT05UUkFDVF9BRERSRVNTKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY29udHJhY3QhLmdldFNvbGFuYVBheW1lbnRMaW5rKGxpbmtJZClcbiAgICAgIGNvbnNvbGUubG9nKCdSYXcgY29udHJhY3QgcmVzdWx0OicsIHJlc3VsdClcbiAgICAgIFxuICAgICAgY29uc3QgcGF5bWVudExpbmsgPSB7XG4gICAgICAgIGV2bUNyZWF0b3I6IHJlc3VsdC5ldm1DcmVhdG9yLFxuICAgICAgICBzb2xhbmFDcmVhdG9yOiByZXN1bHQuc29sYW5hQ3JlYXRvcixcbiAgICAgICAgYW1vdW50OiByZXN1bHQuYW1vdW50LFxuICAgICAgICBpc0ZsZXhpYmxlOiByZXN1bHQuaXNGbGV4aWJsZSxcbiAgICAgICAgaXNBY3RpdmU6IHJlc3VsdC5pc0FjdGl2ZSxcbiAgICAgICAgdG90YWxSZWNlaXZlZDogcmVzdWx0LnRvdGFsUmVjZWl2ZWQsXG4gICAgICAgIHBheW1lbnRDb3VudDogTnVtYmVyKHJlc3VsdC5wYXltZW50Q291bnQpLFxuICAgICAgICBkZXNjcmlwdGlvbjogcmVzdWx0LmRlc2NyaXB0aW9uXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgbG9va3MgbGlrZSBhbiBlbXB0eS9ub24tZXhpc3RlbnQgbGluayAodHJhbnNhY3Rpb24gbm90IHByb2Nlc3NlZCB5ZXQpXG4gICAgICBpZiAocmVzdWx0LmV2bUNyZWF0b3IgPT09ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnICYmIFxuICAgICAgICAgIHJlc3VsdC5hbW91bnQgPT09IEJpZ0ludCgwKSAmJiBcbiAgICAgICAgICAhcmVzdWx0LmlzQWN0aXZlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignUGF5bWVudCBsaW5rIGFwcGVhcnMgdG8gYmUgZW1wdHkvbm9uLWV4aXN0ZW50JylcbiAgICAgICAgXG4gICAgICAgIC8vIElmIHRoaXMgbG9va3MgbGlrZSBhIHRyYW5zYWN0aW9uIGhhc2ggKDY2IGNoYXJzLCBzdGFydHMgd2l0aCAweCksIHByb3ZpZGUgaGVscGZ1bCBpbmZvXG4gICAgICAgIGlmIChsaW5rSWQubGVuZ3RoID09PSA2NiAmJiBsaW5rSWQuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5KhIFRoaXMgYXBwZWFycyB0byBiZSBhIHRyYW5zYWN0aW9uIGhhc2ggLSB0aGUgcGF5bWVudCBsaW5rIG1heSBzdGlsbCBiZSBwcm9jZXNzaW5nJylcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+SoSBOZW9uIG9wZXJhdG9ycyB3aWxsIGV2ZW50dWFsbHkgcHJvY2VzcyB0aGlzIHRyYW5zYWN0aW9uIGFuZCBjcmVhdGUgdGhlIHBheW1lbnQgbGluaycpXG4gICAgICAgICAgY29uc29sZS5sb2coJ/CfkqEgWW91IGNhbiBib29rbWFyayB0aGlzIGxpbmsgYW5kIHRyeSBhZ2FpbiBpbiBhIGZldyBtaW51dGVzJylcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGb3Igbm93LCBkb24ndCB0aHJvdyBhbiBlcnJvciAtIGxldCB0aGUgVUkgaGFuZGxlIHRoZSBlbXB0eSBkYXRhIGdyYWNlZnVsbHlcbiAgICAgICAgICBjb25zb2xlLmxvZygnUmV0dXJuaW5nIGVtcHR5IHBheW1lbnQgbGluayBkYXRhIC0gdHJhbnNhY3Rpb24gbWF5IHN0aWxsIGJlIHByb2Nlc3NpbmcnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBwYXltZW50TGlua1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDb250cmFjdCBjYWxsIGVycm9yOicsIGVycm9yKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXltZW50IGxpbmsgbm90IGZvdW5kIG9yIGNvbnRyYWN0IGVycm9yJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHVzZXIncyBwYXltZW50IGxpbmtzXG4gICAqL1xuICBhc3luYyBnZXRVc2VyTGlua3ModXNlckVWTUFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICAvLyBJbml0aWFsaXplIGNvbnRyYWN0IGlmIG5vdCBhbHJlYWR5IGRvbmVcbiAgICBpZiAoIXRoaXMuY29udHJhY3QpIHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdFJlYWRPbmx5Q29udHJhY3QoKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb250cmFjdCEuZ2V0VXNlclNvbGFuYUxpbmtzKHVzZXJFVk1BZGRyZXNzKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHVzZXIgbGlua3M6JywgZXJyb3IpXG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGF5IGEgcGF5bWVudCBsaW5rIHVzaW5nIFNvbGFuYSBOYXRpdmUgU0RLXG4gICAqL1xuICBhc3luYyBwYXlMaW5rKFxuICAgIGxpbmtJZDogc3RyaW5nLFxuICAgIGFtb3VudFNPTDogbnVtYmVyXG4gICk6IFByb21pc2U8eyB0eEhhc2g6IHN0cmluZzsgdHJhbnNmZXJTaWduYXR1cmU/OiBzdHJpbmcgfT4ge1xuICAgIGlmICghdGhpcy5zb2xhbmFVc2VyIHx8ICF0aGlzLmNvbnRyYWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBjb25uZWN0IHdhbGxldCBmaXJzdCcpXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIHBheW1lbnQgcHJvY2Vzcy4uLicpXG4gICAgY29uc29sZS5sb2coJ0xpbmsgSUQ6JywgbGlua0lkKVxuICAgIGNvbnNvbGUubG9nKCdBbW91bnQgU09MOicsIGFtb3VudFNPTClcblxuICAgIC8vIEZpcnN0LCBnZXQgdGhlIHBheW1lbnQgbGluayBkZXRhaWxzIHRvIGZpbmQgdGhlIHJlY2lwaWVudFxuICAgIGNvbnN0IGxpbmtEYXRhID0gYXdhaXQgdGhpcy5nZXRQYXltZW50TGluayhsaW5rSWQpXG4gICAgY29uc29sZS5sb2coJ1BheW1lbnQgbGluayBkYXRhOicsIGxpbmtEYXRhKVxuXG4gICAgaWYgKCFsaW5rRGF0YS5pc0FjdGl2ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXltZW50IGxpbmsgaXMgbm8gbG9uZ2VyIGFjdGl2ZScpXG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBTT0wgdG8gbGFtcG9ydHNcbiAgICBjb25zdCBhbW91bnRMYW1wb3J0cyA9IE1hdGguZmxvb3IoYW1vdW50U09MICogMWU5KVxuICAgIFxuICAgIGxldCB0cmFuc2ZlclNpZ25hdHVyZTogc3RyaW5nIHwgdW5kZWZpbmVkXG5cbiAgICB0cnkge1xuICAgICAgLy8gU3RlcCAxOiBQZXJmb3JtIHRoZSBhY3R1YWwgU09MIHRyYW5zZmVyIGZpcnN0XG4gICAgICBjb25zb2xlLmxvZygnU3RlcCAxOiBQZXJmb3JtaW5nIFNPTCB0cmFuc2Zlci4uLicpXG4gICAgICBjb25zb2xlLmxvZygnRnJvbTonLCB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LnRvQmFzZTU4KCkpXG4gICAgICBjb25zb2xlLmxvZygnVG8gcmVjaXBpZW50IGJ5dGVzMzI6JywgbGlua0RhdGEuc29sYW5hQ3JlYXRvcilcbiAgICAgIGNvbnNvbGUubG9nKCdBbW91bnQgbGFtcG9ydHM6JywgYW1vdW50TGFtcG9ydHMpXG5cbiAgICAgIC8vIENvbnZlcnQgcmVjaXBpZW50IFNvbGFuYSBhZGRyZXNzIGZyb20gYnl0ZXMzMiB0byBQdWJsaWNLZXlcbiAgICAgIC8vIFJlbW92ZSAnMHgnIHByZWZpeCBpZiBwcmVzZW50XG4gICAgICBjb25zdCBoZXhTdHJpbmcgPSBsaW5rRGF0YS5zb2xhbmFDcmVhdG9yLnN0YXJ0c1dpdGgoJzB4JykgXG4gICAgICAgID8gbGlua0RhdGEuc29sYW5hQ3JlYXRvci5zbGljZSgyKSBcbiAgICAgICAgOiBsaW5rRGF0YS5zb2xhbmFDcmVhdG9yXG4gICAgICBcbiAgICAgIC8vIENvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG4gICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGhleFN0cmluZy5tYXRjaCgvLnsyfS9nKT8ubWFwKGJ5dGUgPT4gcGFyc2VJbnQoYnl0ZSwgMTYpKSB8fCBbXSlcbiAgICAgIFxuICAgICAgLy8gRm9yIGJ5dGVzMzIgZnJvbSBTb2xhbmEgYWRkcmVzc2VzLCB3ZSBuZWVkIHRvIGZpbmQgdGhlIGFjdHVhbCAzMi1ieXRlIHB1YmxpYyBrZXlcbiAgICAgIC8vIFRoZSBieXRlczMyIHNob3VsZCBjb250YWluIHRoZSAzMi1ieXRlIFNvbGFuYSBwdWJsaWMga2V5LCBwb3NzaWJseSB3aXRoIGxlYWRpbmcgemVyb3NcbiAgICAgIGxldCByZWNpcGllbnRQdWJrZXlcbiAgICAgIFxuICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMzIpIHtcbiAgICAgICAgLy8gRGlyZWN0IGNvbnZlcnNpb24gZnJvbSAzMiBieXRlc1xuICAgICAgICByZWNpcGllbnRQdWJrZXkgPSBuZXcgKGF3YWl0IGltcG9ydCgnQHNvbGFuYS93ZWIzLmpzJykpLlB1YmxpY0tleShieXRlcylcbiAgICAgIH0gZWxzZSBpZiAoYnl0ZXMubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgLy8gVGFrZSB0aGUgbGFzdCAzMiBieXRlcyBpZiBpdCdzIGxvbmdlclxuICAgICAgICBjb25zdCBsYXN0MzJCeXRlcyA9IGJ5dGVzLnNsaWNlKC0zMilcbiAgICAgICAgcmVjaXBpZW50UHVia2V5ID0gbmV3IChhd2FpdCBpbXBvcnQoJ0Bzb2xhbmEvd2ViMy5qcycpKS5QdWJsaWNLZXkobGFzdDMyQnl0ZXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBQYWQgd2l0aCBsZWFkaW5nIHplcm9zIGlmIHNob3J0ZXJcbiAgICAgICAgY29uc3QgcGFkZGVkQnl0ZXMgPSBuZXcgVWludDhBcnJheSgzMilcbiAgICAgICAgcGFkZGVkQnl0ZXMuc2V0KGJ5dGVzLCAzMiAtIGJ5dGVzLmxlbmd0aClcbiAgICAgICAgcmVjaXBpZW50UHVia2V5ID0gbmV3IChhd2FpdCBpbXBvcnQoJ0Bzb2xhbmEvd2ViMy5qcycpKS5QdWJsaWNLZXkocGFkZGVkQnl0ZXMpXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdSZWNpcGllbnQgUHVibGljS2V5OicsIHJlY2lwaWVudFB1YmtleS50b0Jhc2U1OCgpKVxuXG4gICAgICAvLyBDcmVhdGUgdGhlIFNPTCB0cmFuc2ZlciB0cmFuc2FjdGlvblxuICAgICAgY29uc3QgeyBTeXN0ZW1Qcm9ncmFtLCBUcmFuc2FjdGlvbiB9ID0gYXdhaXQgaW1wb3J0KCdAc29sYW5hL3dlYjMuanMnKVxuXG4gICAgICAvLyBDcmVhdGUgdHJhbnNmZXIgaW5zdHJ1Y3Rpb25cbiAgICAgIGNvbnN0IHRyYW5zZmVySXggPSBTeXN0ZW1Qcm9ncmFtLnRyYW5zZmVyKHtcbiAgICAgICAgZnJvbVB1YmtleTogdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleSxcbiAgICAgICAgdG9QdWJrZXk6IHJlY2lwaWVudFB1YmtleSxcbiAgICAgICAgbGFtcG9ydHM6IGFtb3VudExhbXBvcnRzXG4gICAgICB9KVxuXG4gICAgICAvLyBDcmVhdGUgdHJhbnNhY3Rpb25cbiAgICAgIGNvbnN0IHRyYW5zZmVyVHggPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQodHJhbnNmZXJJeClcbiAgICAgIFxuICAgICAgLy8gR2V0IGZyZXNoIHJlY2VudCBibG9ja2hhc2ggcmlnaHQgYmVmb3JlIHNpZ25pbmdcbiAgICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIGZyZXNoIGJsb2NraGFzaCBmb3IgU09MIHRyYW5zZmVyLi4uJylcbiAgICAgIGNvbnN0IHsgYmxvY2toYXNoLCBsYXN0VmFsaWRCbG9ja0hlaWdodDogdHJhbnNmZXJCbG9ja0hlaWdodCB9ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgnY29uZmlybWVkJylcbiAgICAgIGNvbnNvbGUubG9nKCdGcmVzaCBTT0wgdHJhbnNmZXIgYmxvY2toYXNoOicsIGJsb2NraGFzaClcbiAgICAgIGNvbnNvbGUubG9nKCdMYXN0IHZhbGlkIGJsb2NrIGhlaWdodDonLCB0cmFuc2ZlckJsb2NrSGVpZ2h0KVxuICAgICAgXG4gICAgICB0cmFuc2ZlclR4LnJlY2VudEJsb2NraGFzaCA9IGJsb2NraGFzaFxuICAgICAgdHJhbnNmZXJUeC5mZWVQYXllciA9IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXlcblxuICAgICAgLy8gU2lnbiBhbmQgc2VuZCB0aGUgU09MIHRyYW5zZmVyIGltbWVkaWF0ZWx5XG4gICAgICBjb25zb2xlLmxvZygnU2lnbmluZyBhbmQgc2VuZGluZyBTT0wgdHJhbnNmZXIgd2l0aCBmcmVzaCBibG9ja2hhc2guLi4nKVxuICAgICAgY29uc3Qgc2lnbmVkVHJhbnNmZXJUeCA9IGF3YWl0IHRoaXMuc29sYW5hVXNlci53YWxsZXRBZGFwdGVyLnNpZ25UcmFuc2FjdGlvbih0cmFuc2ZlclR4KVxuICAgICAgdHJhbnNmZXJTaWduYXR1cmUgPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uc2VuZFJhd1RyYW5zYWN0aW9uKHNpZ25lZFRyYW5zZmVyVHguc2VyaWFsaXplKCkpXG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdTT0wgdHJhbnNmZXIgc2VudDonLCB0cmFuc2ZlclNpZ25hdHVyZSlcbiAgICAgIFxuICAgICAgLy8gV2FpdCBmb3IgdHJhbnNmZXIgY29uZmlybWF0aW9uIHVzaW5nIHRoZSBtb2Rlcm4gQVBJXG4gICAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHtcbiAgICAgICAgc2lnbmF0dXJlOiB0cmFuc2ZlclNpZ25hdHVyZSxcbiAgICAgICAgLi4uKGF3YWl0IHRoaXMuY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goKSlcbiAgICAgIH0pXG4gICAgICBjb25zb2xlLmxvZygnU09MIHRyYW5zZmVyIGNvbmZpcm1lZCcpXG5cbiAgICAgIC8vIFN0ZXAgMjogUmVjb3JkIHRoZSBwYXltZW50IGluIHRoZSBjb250cmFjdFxuICAgICAgY29uc29sZS5sb2coJ1N0ZXAgMjogUmVjb3JkaW5nIHBheW1lbnQgaW4gY29udHJhY3QuLi4nKVxuICAgICAgXG4gICAgICAvLyBDb252ZXJ0IFNvbGFuYSBQdWJsaWNLZXkgdG8gYnl0ZXMzMlxuICAgICAgY29uc3QgcGF5ZXJTb2xhbmFCeXRlczMyID0gemVyb1BhZFZhbHVlKGhleGxpZnkodGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleS50b0J5dGVzKCkpLCAzMilcblxuICAgICAgLy8gR2V0IGN1cnJlbnQgbm9uY2VcbiAgICAgIGNvbnN0IG5vbmNlID0gTnVtYmVyKGF3YWl0IHRoaXMucHJveHlBcGkuZ2V0VHJhbnNhY3Rpb25Db3VudCh0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCkpXG4gICAgICBjb25zb2xlLmxvZygnQ3VycmVudCBub25jZTonLCBub25jZSlcblxuICAgICAgLy8gUHJlcGFyZSBjb250cmFjdCBjYWxsIGRhdGFcbiAgICAgIGNvbnN0IGlmYWNlID0gbmV3IGV0aGVycy5JbnRlcmZhY2UoU09MQU5BX1RJUENBUkRfQUJJKVxuICAgICAgY29uc3QgZGF0YSA9IGlmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YSgncGF5U29sYW5hTGluaycsIFtcbiAgICAgICAgbGlua0lkLFxuICAgICAgICBhbW91bnRMYW1wb3J0cyxcbiAgICAgICAgcGF5ZXJTb2xhbmFCeXRlczMyXG4gICAgICBdKVxuXG4gICAgICAvLyBDcmVhdGUgdHJhbnNhY3Rpb24gZGF0YVxuICAgICAgY29uc3QgdHJhbnNhY3Rpb25EYXRhID0ge1xuICAgICAgICBmcm9tOiB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCxcbiAgICAgICAgdG86IENPTlRSQUNUX0FERFJFU1MsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH1cblxuICAgICAgLy8gRXN0aW1hdGUgZ2FzXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkdhcyA9IGF3YWl0IHRoaXMucHJveHlBcGkuZXN0aW1hdGVTY2hlZHVsZWRUcmFuc2FjdGlvbkdhcyh7XG4gICAgICAgIHNvbGFuYVBheWVyOiB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LFxuICAgICAgICB0cmFuc2FjdGlvbnM6IFt0cmFuc2FjdGlvbkRhdGFdLFxuICAgICAgfSlcblxuICAgICAgLy8gQ3JlYXRlIHNjaGVkdWxlZCB0cmFuc2FjdGlvblxuICAgICAgbGV0IHsgc2NoZWR1bGVkVHJhbnNhY3Rpb24gfSA9IGF3YWl0IHRoaXMucHJveHlBcGkuY3JlYXRlU2NoZWR1bGVkVHJhbnNhY3Rpb24oe1xuICAgICAgICB0cmFuc2FjdGlvbkdhcyxcbiAgICAgICAgdHJhbnNhY3Rpb25EYXRhLFxuICAgICAgICBub25jZVxuICAgICAgfSlcblxuICAgICAgLy8gR2V0IGZyZXNoIHJlY2VudCBibG9ja2hhc2ggcmlnaHQgYmVmb3JlIHNpZ25pbmdcbiAgICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIGZyZXNoIGJsb2NraGFzaCBmb3IgY29udHJhY3QgY2FsbC4uLicpXG4gICAgICBjb25zdCB7IGJsb2NraGFzaDogY29udHJhY3RCbG9ja2hhc2gsIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiBjb250cmFjdEJsb2NrSGVpZ2h0IH0gPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCdjb25maXJtZWQnKVxuICAgICAgY29uc29sZS5sb2coJ0ZyZXNoIGNvbnRyYWN0IGNhbGwgYmxvY2toYXNoOicsIGNvbnRyYWN0QmxvY2toYXNoKVxuICAgICAgY29uc29sZS5sb2coJ0xhc3QgdmFsaWQgYmxvY2sgaGVpZ2h0OicsIGNvbnRyYWN0QmxvY2tIZWlnaHQpXG4gICAgICBcbiAgICAgIHNjaGVkdWxlZFRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGNvbnRyYWN0QmxvY2toYXNoXG4gICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5mZWVQYXllciA9IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXlcblxuICAgICAgLy8gU2lnbiB3aXRoIHdhbGxldCBhZGFwdGVyIChmcm9udGVuZCBhcHByb2FjaClcbiAgICAgIGNvbnNvbGUubG9nKCdTaWduaW5nIGNvbnRyYWN0IGNhbGwgd2l0aCBmcmVzaCBibG9ja2hhc2guLi4nKVxuICAgICAgY29uc3Qgc2lnbmVkVHggPSBhd2FpdCB0aGlzLnNvbGFuYVVzZXIud2FsbGV0QWRhcHRlci5zaWduVHJhbnNhY3Rpb24oc2NoZWR1bGVkVHJhbnNhY3Rpb24pXG4gICAgICBcbiAgICAgIC8vIFNlbmQgdHJhbnNhY3Rpb24gaW1tZWRpYXRlbHlcbiAgICAgIGNvbnNvbGUubG9nKCdTZW5kaW5nIGNvbnRyYWN0IGNhbGwgdHJhbnNhY3Rpb24gaW1tZWRpYXRlbHkuLi4nKVxuICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihzaWduZWRUeC5zZXJpYWxpemUoKSlcblxuICAgICAgLy8gV2FpdCBmb3IgdHJhbnNhY3Rpb24gZXhlY3V0aW9uIG9uIE5lb24gRVZNXG4gICAgICBjb25zdCB0cmFuc2FjdGlvblN0YXR1cyA9IGF3YWl0IHRoaXMucHJveHlBcGkud2FpdFRyYW5zYWN0aW9uVHJlZUV4ZWN1dGlvbihcbiAgICAgICAgdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsIFxuICAgICAgICBub25jZSwgXG4gICAgICAgIDYwMDAwXG4gICAgICApXG5cbiAgICAgIGlmICh0cmFuc2FjdGlvblN0YXR1cy5sZW5ndGggPT09IDAgfHwgdHJhbnNhY3Rpb25TdGF0dXNbMF0uc3RhdHVzICE9PSAnU3VjY2VzcycpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDb250cmFjdCBwYXltZW50IHJlY29yZGluZyBmYWlsZWQsIGJ1dCBTT0wgdHJhbnNmZXIgc3VjY2VlZGVkJylcbiAgICAgICAgY29uc29sZS5sb2coJ1RyYW5zZmVyIHNpZ25hdHVyZTonLCB0cmFuc2ZlclNpZ25hdHVyZSlcbiAgICAgICAgLy8gRG9uJ3QgdGhyb3cgZXJyb3IgLSB0aGUgcGF5bWVudCB3ZW50IHRocm91Z2ggZXZlbiBpZiByZWNvcmRpbmcgZmFpbGVkXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdQYXltZW50IGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkhJylcbiAgICAgIGNvbnNvbGUubG9nKCdTT0wgdHJhbnNmZXI6JywgdHJhbnNmZXJTaWduYXR1cmUpXG4gICAgICBjb25zb2xlLmxvZygnQ29udHJhY3QgcmVjb3JkOicsIHRyYW5zYWN0aW9uU3RhdHVzWzBdPy50cmFuc2FjdGlvbkhhc2gpXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR4SGFzaDogdHJhbnNhY3Rpb25TdGF0dXNbMF0/LnRyYW5zYWN0aW9uSGFzaCB8fCAnY29udHJhY3QtcmVjb3JkaW5nLWZhaWxlZCcsXG4gICAgICAgIHRyYW5zZmVyU2lnbmF0dXJlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGF5aW5nIGxpbms6JywgZXJyb3IpXG4gICAgICBpZiAodHJhbnNmZXJTaWduYXR1cmUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ05vdGU6IFNPTCB0cmFuc2ZlciBtYXkgaGF2ZSBzdWNjZWVkZWQ6JywgdHJhbnNmZXJTaWduYXR1cmUpXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWFjdGl2YXRlIGEgcGF5bWVudCBsaW5rXG4gICAqL1xuICBhc3luYyBkZWFjdGl2YXRlTGluayhsaW5rSWQ6IHN0cmluZyk6IFByb21pc2U8eyB0eEhhc2g6IHN0cmluZyB9PiB7XG4gICAgaWYgKCF0aGlzLnNvbGFuYVVzZXIgfHwgIXRoaXMuY29udHJhY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIGNvbm5lY3Qgd2FsbGV0IGZpcnN0JylcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gR2V0IGN1cnJlbnQgbm9uY2VcbiAgICAgIGNvbnN0IG5vbmNlID0gTnVtYmVyKGF3YWl0IHRoaXMucHJveHlBcGkuZ2V0VHJhbnNhY3Rpb25Db3VudCh0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCkpXG4gICAgICBjb25zb2xlLmxvZygnQ3VycmVudCBub25jZTonLCBub25jZSlcblxuICAgICAgLy8gUHJlcGFyZSBjb250cmFjdCBjYWxsIGRhdGFcbiAgICAgIGNvbnN0IGlmYWNlID0gbmV3IGV0aGVycy5JbnRlcmZhY2UoU09MQU5BX1RJUENBUkRfQUJJKVxuICAgICAgY29uc3QgZGF0YSA9IGlmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YSgnZGVhY3RpdmF0ZVNvbGFuYUxpbmsnLCBbbGlua0lkXSlcblxuICAgICAgLy8gQ3JlYXRlIHRyYW5zYWN0aW9uIGRhdGFcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uRGF0YSA9IHtcbiAgICAgICAgZnJvbTogdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsXG4gICAgICAgIHRvOiBDT05UUkFDVF9BRERSRVNTLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9XG5cbiAgICAgIC8vIEVzdGltYXRlIGdhc1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25HYXMgPSBhd2FpdCB0aGlzLnByb3h5QXBpLmVzdGltYXRlU2NoZWR1bGVkVHJhbnNhY3Rpb25HYXMoe1xuICAgICAgICBzb2xhbmFQYXllcjogdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleSxcbiAgICAgICAgdHJhbnNhY3Rpb25zOiBbdHJhbnNhY3Rpb25EYXRhXSxcbiAgICAgIH0pXG5cbiAgICAgIC8vIENyZWF0ZSBzY2hlZHVsZWQgdHJhbnNhY3Rpb25cbiAgICAgIGxldCB7IHNjaGVkdWxlZFRyYW5zYWN0aW9uIH0gPSBhd2FpdCB0aGlzLnByb3h5QXBpLmNyZWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgdHJhbnNhY3Rpb25HYXMsXG4gICAgICAgIHRyYW5zYWN0aW9uRGF0YSxcbiAgICAgICAgbm9uY2VcbiAgICAgIH0pXG5cbiAgICAgIC8vIEdldCBmcmVzaCByZWNlbnQgYmxvY2toYXNoIHJpZ2h0IGJlZm9yZSBzaWduaW5nXG4gICAgICBjb25zb2xlLmxvZygnR2V0dGluZyBmcmVzaCBibG9ja2hhc2ggZm9yIGRlYWN0aXZhdGUgdHJhbnNhY3Rpb24uLi4nKVxuICAgICAgY29uc3QgeyBibG9ja2hhc2gsIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiBkZWFjdGl2YXRlQmxvY2tIZWlnaHQgfSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goJ2NvbmZpcm1lZCcpXG4gICAgICBjb25zb2xlLmxvZygnRnJlc2ggZGVhY3RpdmF0ZSBibG9ja2hhc2g6JywgYmxvY2toYXNoKVxuICAgICAgY29uc29sZS5sb2coJ0xhc3QgdmFsaWQgYmxvY2sgaGVpZ2h0OicsIGRlYWN0aXZhdGVCbG9ja0hlaWdodClcbiAgICAgIFxuICAgICAgc2NoZWR1bGVkVHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoXG4gICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5mZWVQYXllciA9IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXlcblxuICAgICAgLy8gU2lnbiB3aXRoIHdhbGxldCBhZGFwdGVyIChmcm9udGVuZCBhcHByb2FjaClcbiAgICAgIGNvbnNvbGUubG9nKCdTaWduaW5nIGRlYWN0aXZhdGUgdHJhbnNhY3Rpb24gd2l0aCBmcmVzaCBibG9ja2hhc2guLi4nKVxuICAgICAgY29uc3Qgc2lnbmVkVHggPSBhd2FpdCB0aGlzLnNvbGFuYVVzZXIud2FsbGV0QWRhcHRlci5zaWduVHJhbnNhY3Rpb24oc2NoZWR1bGVkVHJhbnNhY3Rpb24pXG4gICAgICBcbiAgICAgIC8vIFNlbmQgdHJhbnNhY3Rpb24gaW1tZWRpYXRlbHlcbiAgICAgIGNvbnNvbGUubG9nKCdTZW5kaW5nIGRlYWN0aXZhdGUgdHJhbnNhY3Rpb24gaW1tZWRpYXRlbHkuLi4nKVxuICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihzaWduZWRUeC5zZXJpYWxpemUoKSlcblxuICAgICAgLy8gV2FpdCBmb3IgdHJhbnNhY3Rpb24gZXhlY3V0aW9uXG4gICAgICBjb25zdCB0cmFuc2FjdGlvblN0YXR1cyA9IGF3YWl0IHRoaXMucHJveHlBcGkud2FpdFRyYW5zYWN0aW9uVHJlZUV4ZWN1dGlvbihcbiAgICAgICAgdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsIFxuICAgICAgICBub25jZSwgXG4gICAgICAgIDYwMDAwXG4gICAgICApXG5cbiAgICAgIGlmICh0cmFuc2FjdGlvblN0YXR1cy5sZW5ndGggPT09IDAgfHwgdHJhbnNhY3Rpb25TdGF0dXNbMF0uc3RhdHVzICE9PSAnU3VjY2VzcycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWFjdGl2YXRpb24gdHJhbnNhY3Rpb24gZmFpbGVkIHRvIGV4ZWN1dGUgb24gTmVvbiBFVk0nKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eEhhc2g6IHRyYW5zYWN0aW9uU3RhdHVzWzBdLnRyYW5zYWN0aW9uSGFzaFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNoYXJlYWJsZSBVUkwgZm9yIGEgcGF5bWVudCBsaW5rXG4gICAqL1xuICBjcmVhdGVQYXltZW50VVJMKGxpbmtJZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn0/cGF5PSR7bGlua0lkfWBcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IGxpbmsgSUQgZnJvbSBVUkxcbiAgICovXG4gIHN0YXRpYyBleHRyYWN0TGlua0lkRnJvbVVSTCh1cmw6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1cmxPYmogPSBuZXcgVVJMKHVybClcbiAgICAgIHJldHVybiB1cmxPYmouc2VhcmNoUGFyYW1zLmdldCgncGF5JylcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdXNlcidzIEVWTSBhZGRyZXNzIGRlcml2ZWQgZnJvbSBTb2xhbmEgcHVibGljIGtleVxuICAgKi9cbiAgZ2V0VXNlckVWTUFkZHJlc3MoKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuc29sYW5hVXNlcj8ubmVvbldhbGxldCB8fCBudWxsXG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IHNvbGFuYU5hdGl2ZUNvbnRyYWN0ID0gbmV3IFNvbGFuYU5hdGl2ZUNvbnRyYWN0KCkiXSwibmFtZXMiOlsiQ29ubmVjdGlvbiIsIk5lb25Qcm94eVJwY0FwaSIsImNyZWF0ZUJhbGFuY2VBY2NvdW50SW5zdHJ1Y3Rpb24iLCJldGhlcnMiLCJoZXhsaWZ5IiwiemVyb1BhZFZhbHVlIiwiQ29udHJhY3RBQkkiLCJTT0xBTkFfVElQQ0FSRF9BQkkiLCJDT05UUkFDVF9BRERSRVNTIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1RJUENBUkRfQ09OVFJBQ1RfQUREUkVTUyIsIk5FT05fQ09SRV9SUENfVVJMIiwiTkVYVF9QVUJMSUNfTkVPTl9SUENfVVJMIiwiTkVPTl9QUk9YWV9SUENfVVJMIiwiU09MQU5BX1JQQ19VUkwiLCJTb2xhbmFOYXRpdmVDb250cmFjdCIsImluaXRXaXRoU29sYW5hV2FsbGV0Iiwid2FsbGV0QWRhcHRlciIsInB1YmxpY0tleSIsIkVycm9yIiwiY29uc29sZSIsImxvZyIsInRvQmFzZTU4IiwicHJvdmlkZXIiLCJjaGFpbklkIiwic29sYW5hVXNlciIsInRva2VuTWludEFkZHJlc3MiLCJwcm9ncmFtQWRkcmVzcyIsInByb3h5QXBpIiwiaW5pdCIsImJhbGFuY2VBZGRyZXNzIiwiU29sYW5hTmVvbkFjY291bnQiLCJhY2NvdW50IiwibmVvbkV2bVByb2dyYW0iLCJ0b2tlbk1pbnQiLCJuZW9uV2FsbGV0IiwiZXJyb3IiLCJyZWFkT25seVByb3ZpZGVyIiwiSnNvblJwY1Byb3ZpZGVyIiwiY29udHJhY3QiLCJDb250cmFjdCIsInR4Q291bnQiLCJnZXRUcmFuc2FjdGlvbkNvdW50IiwidmVyaWZ5RXJyb3IiLCJjb2RlIiwiZ2V0Q29kZSIsImxlbmd0aCIsIndhcm4iLCJjcmVhdGVQYXltZW50TGluayIsInN1Z2dlc3RlZEFtb3VudFNPTCIsImlzRmxleGlibGUiLCJkZXNjcmlwdGlvbiIsImFtb3VudExhbXBvcnRzIiwiTWF0aCIsImZsb29yIiwic2NoZWR1bGVkVHJhbnNhY3Rpb24iLCJyZWNlaXB0Iiwibm9uY2UiLCJOdW1iZXIiLCJpZmFjZSIsIkludGVyZmFjZSIsImRhdGEiLCJlbmNvZGVGdW5jdGlvbkRhdGEiLCJ0cmFuc2FjdGlvbkRhdGEiLCJmcm9tIiwidG8iLCJ0cmFuc2FjdGlvbkdhcyIsImVzdGltYXRlU2NoZWR1bGVkVHJhbnNhY3Rpb25HYXMiLCJzb2xhbmFQYXllciIsInRyYW5zYWN0aW9ucyIsImNyZWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uIiwiY29ubmVjdGlvbiIsImdldEFjY291bnRJbmZvIiwiaW5zdHJ1Y3Rpb25zIiwidW5zaGlmdCIsImJsb2NraGFzaCIsImdldExhdGVzdEJsb2NraGFzaCIsInJlY2VudEJsb2NraGFzaCIsImZlZVBheWVyIiwic2lnbmVkVHJhbnNhY3Rpb24iLCJzaWduVHJhbnNhY3Rpb24iLCJzaWduYXR1cmUiLCJzZW5kUmF3VHJhbnNhY3Rpb24iLCJzZXJpYWxpemUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJjb25maXJtYXRpb24iLCJnZXRTaWduYXR1cmVTdGF0dXMiLCJ2YWx1ZSIsImNvbmZpcm1hdGlvblN0YXR1cyIsIm5lb25UeFJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJwYXJhbXMiLCJpZCIsImpzb25ycGMiLCJuZW9uVHhSZXN1bHQiLCJqc29uIiwicmVzdWx0IiwiaGFzaCIsImxpbmtEZXRhaWxzIiwic29sYW5hVGlwQ2FyZCIsImdldFNvbGFuYVBheW1lbnRMaW5rIiwiY3JlYXRlZExpbmtJZCIsImZvcm1hdFVuaXRzIiwidG90YWxSZWNlaXZlZCIsInBheW1lbnRDb3VudCIsImlzQWN0aXZlIiwibGlua0Vycm9yIiwibWVzc2FnZSIsIm5lb25FcnJvciIsImNvbmZpcm1FcnJvciIsImdldFRyYW5zYWN0aW9uUmVjZWlwdCIsInR4SGFzaCIsImFsbE5lb25Mb2dzIiwic29sYW5hVHJhbnNhY3Rpb25zIiwic29sVHgiLCJzb2xhbmFJbnN0cnVjdGlvbnMiLCJpbnN0cnVjdGlvbiIsIm5lb25Mb2dzIiwicHVzaCIsImxpbmtJZCIsIm5lb25SZXZlcnREYXRhIiwicmV2ZXJ0UmVhc29uIiwidG9VdGY4U3RyaW5nIiwiZGVjb2RlRXJyb3IiLCJuZW9uUmF3VHJhbnNhY3Rpb24iLCJpc1JlZ2lzdGVyZWQiLCJpc1NvbGFuYVVzZXIiLCJyZWdpc3RyYXRpb25FcnJvciIsImluaXRSZWFkT25seUNvbnRyYWN0IiwiZ2V0UGF5bWVudExpbmsiLCJwYXltZW50TGluayIsImV2bUNyZWF0b3IiLCJzb2xhbmFDcmVhdG9yIiwiYW1vdW50IiwiQmlnSW50Iiwic3RhcnRzV2l0aCIsImdldFVzZXJMaW5rcyIsInVzZXJFVk1BZGRyZXNzIiwiZ2V0VXNlclNvbGFuYUxpbmtzIiwicGF5TGluayIsImFtb3VudFNPTCIsImxpbmtEYXRhIiwidHJhbnNmZXJTaWduYXR1cmUiLCJoZXhTdHJpbmciLCJ0cmFuc2FjdGlvblN0YXR1cyIsInNsaWNlIiwiYnl0ZXMiLCJVaW50OEFycmF5IiwibWF0Y2giLCJtYXAiLCJieXRlIiwicGFyc2VJbnQiLCJyZWNpcGllbnRQdWJrZXkiLCJQdWJsaWNLZXkiLCJsYXN0MzJCeXRlcyIsInBhZGRlZEJ5dGVzIiwic2V0IiwiU3lzdGVtUHJvZ3JhbSIsIlRyYW5zYWN0aW9uIiwidHJhbnNmZXJJeCIsInRyYW5zZmVyIiwiZnJvbVB1YmtleSIsInRvUHVia2V5IiwibGFtcG9ydHMiLCJ0cmFuc2ZlclR4IiwiYWRkIiwibGFzdFZhbGlkQmxvY2tIZWlnaHQiLCJ0cmFuc2ZlckJsb2NrSGVpZ2h0Iiwic2lnbmVkVHJhbnNmZXJUeCIsImNvbmZpcm1UcmFuc2FjdGlvbiIsInBheWVyU29sYW5hQnl0ZXMzMiIsInRvQnl0ZXMiLCJjb250cmFjdEJsb2NraGFzaCIsImNvbnRyYWN0QmxvY2tIZWlnaHQiLCJzaWduZWRUeCIsIndhaXRUcmFuc2FjdGlvblRyZWVFeGVjdXRpb24iLCJzdGF0dXMiLCJ0cmFuc2FjdGlvbkhhc2giLCJkZWFjdGl2YXRlTGluayIsImRlYWN0aXZhdGVCbG9ja0hlaWdodCIsImNyZWF0ZVBheW1lbnRVUkwiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIm9yaWdpbiIsImV4dHJhY3RMaW5rSWRGcm9tVVJMIiwidXJsIiwidXJsT2JqIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwiZ2V0IiwiZ2V0VXNlckVWTUFkZHJlc3MiLCJjb25zdHJ1Y3RvciIsInNvbGFuYU5hdGl2ZUNvbnRyYWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/solana-native-contract.ts\n"));

/***/ })

});