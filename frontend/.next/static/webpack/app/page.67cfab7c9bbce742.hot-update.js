"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/solana-native-contract.ts":
/*!*****************************************!*\
  !*** ./utils/solana-native-contract.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaNativeContract: function() { return /* binding */ SolanaNativeContract; },\n/* harmony export */   solanaNativeContract: function() { return /* binding */ solanaNativeContract; }\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var _neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @neonevm/solana-sign */ \"(app-pages-browser)/./node_modules/@neonevm/solana-sign/dist/esm/index.mjs\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/units.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _contractABI_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contractABI.json */ \"(app-pages-browser)/./utils/contractABI.json\");\n\n\n\n\n// Use the actual deployed contract ABI\nconst SOLANA_TIPCARD_ABI = _contractABI_json__WEBPACK_IMPORTED_MODULE_2__;\nconst CONTRACT_ADDRESS = \"0xCFE03c7c67456D094C0162F9030393FC2cCc40Cb\" || 0;\nconst NEON_CORE_RPC_URL = \"https://devnet.neonevm.org\" || 0;\nconst NEON_PROXY_RPC_URL = \"\".concat(NEON_CORE_RPC_URL, \"/sol\");\nconst SOLANA_RPC_URL = \"https://api.devnet.solana.com\";\nclass SolanaNativeContract {\n    /**\n   * Initialize with Solana wallet using the recommended SolanaNeonAccount approach\n   */ async initWithSolanaWallet(walletAdapter) {\n        if (!walletAdapter.publicKey) {\n            throw new Error(\"Wallet not connected\");\n        }\n        try {\n            var _this_solanaUser_balanceAddress;\n            console.log(\"\\uD83D\\uDD27 Using recommended SolanaNeonAccount approach...\");\n            console.log(\"Wallet public key:\", walletAdapter.publicKey.toBase58());\n            // Use proxyApi.init with just the public key (like demo)\n            const { provider, chainId, solanaUser, tokenMintAddress, programAddress } = await this.proxyApi.init(walletAdapter.publicKey);\n            console.log(\"- Chain ID:\", chainId);\n            console.log(\"- Neon EVM Program:\", programAddress.toBase58());\n            // Store the result with wallet adapter for signing\n            this.chainId = chainId;\n            this.solanaUser = {\n                ...solanaUser,\n                walletAdapter: walletAdapter // Add wallet adapter for signing\n            };\n            // Create balance address if it doesn't exist (using SolanaNeonAccount approach)\n            if (!this.solanaUser.balanceAddress) {\n                const { SolanaNeonAccount } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @neonevm/solana-sign */ \"(app-pages-browser)/./node_modules/@neonevm/solana-sign/dist/esm/index.mjs\"));\n                const account = new SolanaNeonAccount(this.solanaUser.publicKey, this.solanaUser.neonEvmProgram, this.solanaUser.tokenMint, this.solanaUser.chainId);\n                this.solanaUser.balanceAddress = account.balanceAddress;\n            }\n            // Verify they match\n            if (walletAdapter.publicKey.toBase58() === this.solanaUser.publicKey.toBase58()) {\n                console.log(\"✅ Wallet public keys match correctly!\");\n            } else {\n                console.error(\"❌ MISMATCH: Wallet adapter and solana user have different public keys!\");\n                console.error(\"Wallet adapter:\", walletAdapter.publicKey.toBase58());\n                console.error(\"Solana user:\", this.solanaUser.publicKey.toBase58());\n            }\n            console.log(\"\\uD83D\\uDCB0 Final balance address:\", ((_this_solanaUser_balanceAddress = this.solanaUser.balanceAddress) === null || _this_solanaUser_balanceAddress === void 0 ? void 0 : _this_solanaUser_balanceAddress.toBase58()) || \"Still not available\");\n            // Create contract instance\n            const readOnlyProvider = new ethers__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider(NEON_CORE_RPC_URL);\n            this.contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.Contract(CONTRACT_ADDRESS, SOLANA_TIPCARD_ABI, readOnlyProvider);\n            try {\n                // Check if this EVM address has been used before (has transaction history)\n                const txCount = await readOnlyProvider.getTransactionCount(this.solanaUser.neonWallet);\n                console.log(\"\\uD83D\\uDCCA EVM address transaction count:\", txCount);\n                if (txCount > 0) {\n                    console.log(\"✅ This EVM address has transaction history - it exists on-chain!\");\n                } else {\n                    console.log(\"ℹ️ This EVM address is new (no transaction history yet)\");\n                    console.log(\"ℹ️ The address will be registered on-chain when first transaction is made\");\n                }\n            } catch (verifyError) {\n                console.log(\"⚠️ Could not verify EVM address:\", verifyError);\n            }\n            // Verify contract is deployed at this address\n            try {\n                const code = await readOnlyProvider.getCode(CONTRACT_ADDRESS);\n                if (code === \"0x\") {\n                    console.warn(\"⚠️ No contract code found at address:\", CONTRACT_ADDRESS);\n                    console.log(\"This might mean the contract is not deployed or address is incorrect\");\n                } else {\n                    console.log(\"✅ Contract found at address\");\n                    console.log(\"✅ Contract found and ready for transactions\");\n                }\n            } catch (verifyError) {\n                console.warn(\"Failed to verify contract:\", verifyError);\n            }\n        } catch (error) {\n            console.error(\"Failed to initialize Solana Native SDK:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Create a payment link using Solana Native SDK\n   */ async createPaymentLink(suggestedAmountSOL, isFlexible, description) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        // Convert SOL to lamports using ethers for precision (1 SOL = 1e9 lamports)\n        const amountLamports = ethers__WEBPACK_IMPORTED_MODULE_5__.parseUnits(suggestedAmountSOL.toString(), 9);\n        let signature = \"\";\n        try {\n            // Get current nonce (exactly like working examples)\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Current nonce:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_6__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"createSolanaPaymentLink\", [\n                amountLamports,\n                isFlexible,\n                description\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Check if balance account exists, if not create it\n            const account = await this.connection.getAccountInfo(this.solanaUser.balanceAddress);\n            if (account === null) {\n                scheduledTransaction.instructions.unshift((0,_neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__.createBalanceAccountInstruction)(this.solanaUser.neonEvmProgram, this.solanaUser.publicKey, this.solanaUser.neonWallet, this.chainId));\n            }\n            // Sign and send transaction using exact test pattern\n            const { blockhash } = await this.connection.getLatestBlockhash();\n            scheduledTransaction.recentBlockhash = blockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            const signedTransaction = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            console.log(\"Submitting transaction...\");\n            signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n            console.log(\"\\uD83D\\uDD17 Signature:\", signature);\n            // Wait for Solana confirmation first (like the test)\n            console.log(\"Waiting for Solana confirmation...\");\n            await this.connection.confirmTransaction({\n                signature: signature,\n                ...await this.connection.getLatestBlockhash()\n            });\n            console.log(\"✅ Solana transaction confirmed\");\n            // Wait additional time for Neon processing (like the test)\n            console.log(\"Waiting for Neon EVM processing...\");\n            await new Promise((resolve)=>setTimeout(resolve, 3000)); // Wait 3 more seconds like test\n            // Check transaction status\n            try {\n                console.log(\"Getting Neon EVM transaction details...\");\n                const neonTxResponse = await fetch(\"https://devnet.neonevm.org/sol\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        method: \"neon_getTransactionBySenderNonce\",\n                        params: [\n                            this.solanaUser.neonWallet,\n                            nonce\n                        ],\n                        id: 1,\n                        jsonrpc: \"2.0\"\n                    })\n                });\n                const neonTxResult = await neonTxResponse.json();\n                console.log(\"Neon EVM txn result: \", neonTxResult);\n                if (neonTxResult.result && neonTxResult.result.hash) {\n                    const neonTxHash = neonTxResult.result.hash;\n                    console.log(\"✅ Neon EVM payment hash: \".concat(neonTxHash));\n                    // Retry getting the transaction receipt with proper waiting\n                    let actualLinkId = null;\n                    for(let attempt = 1; attempt <= 5; attempt++){\n                        console.log(\"Getting transaction receipt (attempt \".concat(attempt, \"/5)...\"));\n                        try {\n                            const receiptResponse = await fetch(\"https://devnet.neonevm.org/sol\", {\n                                method: \"POST\",\n                                headers: {\n                                    \"Content-Type\": \"application/json\"\n                                },\n                                body: JSON.stringify({\n                                    method: \"eth_getTransactionReceipt\",\n                                    params: [\n                                        neonTxHash\n                                    ],\n                                    id: 1,\n                                    jsonrpc: \"2.0\"\n                                })\n                            });\n                            const receiptResult = await receiptResponse.json();\n                            if (receiptResult.result && receiptResult.result.logs) {\n                                console.log(\"\\uD83D\\uDCCB Transaction receipt found with \".concat(receiptResult.result.logs.length, \" logs\"));\n                                // Look for SolanaLinkCreated event to extract the actual link ID\n                                for (const log of receiptResult.result.logs){\n                                    try {\n                                        const iface = new ethers__WEBPACK_IMPORTED_MODULE_6__.Interface(SOLANA_TIPCARD_ABI);\n                                        const decoded = iface.parseLog(log);\n                                        if (decoded && decoded.name === \"SolanaLinkCreated\") {\n                                            actualLinkId = decoded.args.linkId;\n                                            console.log(\"\\uD83C\\uDF89 Found SolanaLinkCreated event!\");\n                                            console.log(\"   Actual Link ID: \".concat(actualLinkId));\n                                            console.log(\"   Creator: \".concat(decoded.args.evmCreator));\n                                            console.log(\"   Amount: \".concat(ethers__WEBPACK_IMPORTED_MODULE_5__.formatUnits(decoded.args.amount, 9), \" SOL\"));\n                                            console.log('   Description: \"'.concat(decoded.args.description, '\"'));\n                                            return {\n                                                linkId: actualLinkId !== null && actualLinkId !== void 0 ? actualLinkId : neonTxHash,\n                                                txHash: neonTxHash // Keep transaction hash for reference\n                                            };\n                                        }\n                                    } catch (parseError) {\n                                    // Not our event, continue\n                                    }\n                                }\n                                console.log(\"⚠️ SolanaLinkCreated event not found in transaction logs\");\n                                break; // Receipt exists but no event - don't retry\n                            } else {\n                                console.log(\"⚠️ No transaction receipt found yet (attempt \".concat(attempt, \"/5)\"));\n                                if (attempt < 5) {\n                                    console.log(\"Waiting 5 seconds before next attempt...\");\n                                    await new Promise((resolve)=>setTimeout(resolve, 5000));\n                                }\n                            }\n                        } catch (receiptError) {\n                            console.log(\"⚠️ Receipt fetch error (attempt \".concat(attempt, \"/5): \").concat(receiptError.message));\n                            if (attempt < 5) {\n                                await new Promise((resolve)=>setTimeout(resolve, 5000));\n                            }\n                        }\n                    }\n                    // Fallback to transaction hash if we can't find the event\n                    console.log(\"Using transaction hash as fallback link ID\");\n                    return {\n                        linkId: neonTxHash,\n                        txHash: neonTxHash\n                    };\n                } else {\n                    console.log(\"ℹ️ Neon EVM payment transaction not found yet (may still be processing)\");\n                }\n            } catch (neonError) {\n                console.log(\"ℹ️ Could not get Neon payment details: \".concat(neonError.message));\n            }\n        } catch (confirmError) {\n            console.log(\"ℹ️ Payment confirmation check: \".concat(confirmError.message));\n        }\n        console.log(\"\\uD83C\\uDF89 Payment transaction completed!\");\n        // Return signature as fallback\n        return {\n            linkId: signature,\n            txHash: signature\n        };\n    }\n    catch(error) {\n        console.error(\"Error creating payment link:\", error);\n        throw error;\n    }\n    /**\n   * Initialize read-only contract access (without wallet)\n   */ async initReadOnlyContract() {\n        if (!this.contract) {\n            // Create a simple JSON RPC provider for read operations\n            const readOnlyProvider = new ethers__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider(NEON_CORE_RPC_URL);\n            this.contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.Contract(CONTRACT_ADDRESS, SOLANA_TIPCARD_ABI, readOnlyProvider);\n        }\n    }\n    /**\n   * Get payment link details\n   */ async getPaymentLink(linkId) {\n        // Initialize contract if not already done\n        if (!this.contract) {\n            await this.initReadOnlyContract();\n        }\n        console.log(\"Getting payment link with ID:\", linkId);\n        console.log(\"Contract address:\", CONTRACT_ADDRESS);\n        try {\n            const result = await this.contract.getSolanaPaymentLink(linkId);\n            console.log(\"Raw contract result:\", result);\n            const paymentLink = {\n                evmCreator: result.evmCreator,\n                solanaCreator: result.solanaCreator,\n                amount: result.amount,\n                isFlexible: result.isFlexible,\n                isActive: result.isActive,\n                totalReceived: result.totalReceived,\n                paymentCount: Number(result.paymentCount),\n                description: result.description\n            };\n            // Check if this looks like an empty/non-existent link (transaction not processed yet)\n            if (result.evmCreator === \"0x0000000000000000000000000000000000000000\" && result.amount === BigInt(0) && !result.isActive) {\n                console.warn(\"Payment link appears to be empty/non-existent\");\n                // If this looks like a transaction hash (66 chars, starts with 0x), provide helpful info\n                if (linkId.length === 66 && linkId.startsWith(\"0x\")) {\n                    console.log(\"\\uD83D\\uDCA1 This appears to be a transaction hash - the payment link may still be processing\");\n                    console.log(\"\\uD83D\\uDCA1 Neon operators will eventually process this transaction and create the payment link\");\n                    console.log(\"\\uD83D\\uDCA1 You can bookmark this link and try again in a few minutes\");\n                    // For now, don't throw an error - let the UI handle the empty data gracefully\n                    console.log(\"Returning empty payment link data - transaction may still be processing\");\n                }\n            }\n            return paymentLink;\n        } catch (error) {\n            console.error(\"Contract call error:\", error);\n            throw new Error(\"Payment link not found or contract error\");\n        }\n    }\n    /**\n   * Get user's payment links\n   */ async getUserLinks(userEVMAddress) {\n        // Initialize contract if not already done\n        if (!this.contract) {\n            await this.initReadOnlyContract();\n        }\n        try {\n            return await this.contract.getUserSolanaLinks(userEVMAddress);\n        } catch (error) {\n            console.error(\"Error getting user links:\", error);\n            return [];\n        }\n    }\n    /**\n   * Pay a payment link using Solana Native SDK\n   */ async payLink(linkId, amountSOL) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        console.log(\"Starting payment process...\");\n        console.log(\"Link ID:\", linkId);\n        console.log(\"Amount SOL:\", amountSOL);\n        // First, get the payment link details to find the recipient\n        const linkData = await this.getPaymentLink(linkId);\n        console.log(\"Payment link data:\", linkData);\n        if (!linkData.isActive) {\n            throw new Error(\"Payment link is no longer active\");\n        }\n        // Convert SOL to lamports\n        const amountLamports = Math.floor(amountSOL * 1e9);\n        let transferSignature;\n        try {\n            var _hexString_match, _transactionStatus_, _transactionStatus_1;\n            // Step 1: Perform the actual SOL transfer first\n            console.log(\"Step 1: Performing SOL transfer...\");\n            console.log(\"From:\", this.solanaUser.publicKey.toBase58());\n            console.log(\"To recipient bytes32:\", linkData.solanaCreator);\n            console.log(\"Amount lamports:\", amountLamports);\n            // Convert recipient Solana address from bytes32 to PublicKey\n            // Remove '0x' prefix if present\n            const hexString = linkData.solanaCreator.startsWith(\"0x\") ? linkData.solanaCreator.slice(2) : linkData.solanaCreator;\n            // Convert hex string to byte array\n            const bytes = new Uint8Array(((_hexString_match = hexString.match(/.{2}/g)) === null || _hexString_match === void 0 ? void 0 : _hexString_match.map((byte)=>parseInt(byte, 16))) || []);\n            // For bytes32 from Solana addresses, we need to find the actual 32-byte public key\n            // The bytes32 should contain the 32-byte Solana public key, possibly with leading zeros\n            let recipientPubkey;\n            if (bytes.length === 32) {\n                // Direct conversion from 32 bytes\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(bytes);\n            } else if (bytes.length > 32) {\n                // Take the last 32 bytes if it's longer\n                const last32Bytes = bytes.slice(-32);\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(last32Bytes);\n            } else {\n                // Pad with leading zeros if shorter\n                const paddedBytes = new Uint8Array(32);\n                paddedBytes.set(bytes, 32 - bytes.length);\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(paddedBytes);\n            }\n            console.log(\"Recipient PublicKey:\", recipientPubkey.toBase58());\n            // Create the SOL transfer transaction\n            const { SystemProgram, Transaction } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"));\n            // Create transfer instruction\n            const transferIx = SystemProgram.transfer({\n                fromPubkey: this.solanaUser.publicKey,\n                toPubkey: recipientPubkey,\n                lamports: amountLamports\n            });\n            // Create transaction\n            const transferTx = new Transaction().add(transferIx);\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for SOL transfer...\");\n            const { blockhash, lastValidBlockHeight: transferBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh SOL transfer blockhash:\", blockhash);\n            console.log(\"Last valid block height:\", transferBlockHeight);\n            transferTx.recentBlockhash = blockhash;\n            transferTx.feePayer = this.solanaUser.publicKey;\n            // Sign and send the SOL transfer immediately\n            console.log(\"Signing and sending SOL transfer with fresh blockhash...\");\n            const signedTransferTx = await this.solanaUser.walletAdapter.signTransaction(transferTx);\n            transferSignature = await this.connection.sendRawTransaction(signedTransferTx.serialize());\n            console.log(\"SOL transfer sent:\", transferSignature);\n            // Wait for transfer confirmation using the modern API\n            await this.connection.confirmTransaction({\n                signature: transferSignature,\n                ...await this.connection.getLatestBlockhash()\n            });\n            console.log(\"SOL transfer confirmed\");\n            // Step 2: Record the payment in the contract\n            console.log(\"Step 2: Recording payment in contract...\");\n            // Convert Solana PublicKey to bytes32\n            const payerSolanaBytes32 = (0,ethers__WEBPACK_IMPORTED_MODULE_7__.zeroPadValue)((0,ethers__WEBPACK_IMPORTED_MODULE_7__.hexlify)(this.solanaUser.publicKey.toBytes()), 32);\n            // Get current nonce\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Current nonce:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_6__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"paySolanaLink\", [\n                linkId,\n                amountLamports,\n                payerSolanaBytes32\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for contract call...\");\n            const { blockhash: contractBlockhash, lastValidBlockHeight: contractBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh contract call blockhash:\", contractBlockhash);\n            console.log(\"Last valid block height:\", contractBlockHeight);\n            scheduledTransaction.recentBlockhash = contractBlockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            // Sign with wallet adapter (frontend approach)\n            console.log(\"Signing contract call with fresh blockhash...\");\n            const signedTx = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            // Send transaction immediately\n            console.log(\"Sending contract call transaction immediately...\");\n            await this.connection.sendRawTransaction(signedTx.serialize());\n            // Wait for transaction execution on Neon EVM\n            const transactionStatus = await this.proxyApi.waitTransactionTreeExecution(this.solanaUser.neonWallet, nonce, 60000);\n            if (transactionStatus.length === 0 || transactionStatus[0].status !== \"Success\") {\n                console.warn(\"Contract payment recording failed, but SOL transfer succeeded\");\n                console.log(\"Transfer signature:\", transferSignature);\n            // Don't throw error - the payment went through even if recording failed\n            }\n            console.log(\"Payment completed successfully!\");\n            console.log(\"SOL transfer:\", transferSignature);\n            console.log(\"Contract record:\", (_transactionStatus_ = transactionStatus[0]) === null || _transactionStatus_ === void 0 ? void 0 : _transactionStatus_.transactionHash);\n            return {\n                txHash: ((_transactionStatus_1 = transactionStatus[0]) === null || _transactionStatus_1 === void 0 ? void 0 : _transactionStatus_1.transactionHash) || \"contract-recording-failed\",\n                transferSignature\n            };\n        } catch (error) {\n            console.error(\"Error paying link:\", error);\n            if (transferSignature) {\n                console.log(\"Note: SOL transfer may have succeeded:\", transferSignature);\n            }\n            throw error;\n        }\n    }\n    /**\n   * Deactivate a payment link\n   */ async deactivateLink(linkId) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        try {\n            // Get current nonce\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Current nonce:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_6__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"deactivateSolanaLink\", [\n                linkId\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for deactivate transaction...\");\n            const { blockhash, lastValidBlockHeight: deactivateBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh deactivate blockhash:\", blockhash);\n            console.log(\"Last valid block height:\", deactivateBlockHeight);\n            scheduledTransaction.recentBlockhash = blockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            // Sign with wallet adapter (frontend approach)\n            console.log(\"Signing deactivate transaction with fresh blockhash...\");\n            const signedTx = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            // Send transaction immediately\n            console.log(\"Sending deactivate transaction immediately...\");\n            await this.connection.sendRawTransaction(signedTx.serialize());\n            // Wait for transaction execution\n            const transactionStatus = await this.proxyApi.waitTransactionTreeExecution(this.solanaUser.neonWallet, nonce, 60000);\n            if (transactionStatus.length === 0 || transactionStatus[0].status !== \"Success\") {\n                throw new Error(\"Deactivation transaction failed to execute on Neon EVM\");\n            }\n            return {\n                txHash: transactionStatus[0].transactionHash\n            };\n        } catch (error) {\n            throw error;\n        }\n    }\n    /**\n   * Create a shareable URL for a payment link\n   */ createPaymentURL(linkId) {\n        return \"\".concat(window.location.origin, \"?pay=\").concat(linkId);\n    }\n    /**\n   * Extract link ID from URL\n   */ static extractLinkIdFromURL(url) {\n        try {\n            const urlObj = new URL(url);\n            return urlObj.searchParams.get(\"pay\");\n        } catch (e) {\n            return null;\n        }\n    }\n    /**\n   * Get the user's EVM address derived from Solana public key\n   */ getUserEVMAddress() {\n        var _this_solanaUser;\n        return ((_this_solanaUser = this.solanaUser) === null || _this_solanaUser === void 0 ? void 0 : _this_solanaUser.neonWallet) || null;\n    }\n    constructor(){\n        this.chainId = null;\n        this.contract = null;\n        this.connection = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Connection(SOLANA_RPC_URL, \"confirmed\");\n        this.proxyApi = new _neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__.NeonProxyRpcApi(NEON_PROXY_RPC_URL);\n    }\n}\n// Export singleton instance\nconst solanaNativeContract = new SolanaNativeContract();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3NvbGFuYS1uYXRpdmUtY29udHJhY3QudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFnRTtBQUMwQztBQUNwRDtBQUNWO0FBRTVDLHVDQUF1QztBQUN2QyxNQUFNTyxxQkFBcUJELDhDQUFXQTtBQUV0QyxNQUFNRSxtQkFBbUJDLDRDQUFnRCxJQUFJO0FBQzdFLE1BQU1HLG9CQUFvQkgsNEJBQW9DLElBQUk7QUFDbEUsTUFBTUsscUJBQXFCLEdBQXFCLE9BQWxCRixtQkFBa0I7QUFDaEQsTUFBTUcsaUJBQWlCO0FBYWhCLE1BQU1DO0lBYVg7O0dBRUMsR0FDRCxNQUFNQyxxQkFBcUJDLGFBQWtCLEVBQWlCO1FBQzVELElBQUksQ0FBQ0EsY0FBY0MsU0FBUyxFQUFFO1lBQzVCLE1BQU0sSUFBSUMsTUFBTTtRQUNsQjtRQUVBLElBQUk7Z0JBMkN1QztZQTFDekNDLFFBQVFDLEdBQUcsQ0FBQztZQUNaRCxRQUFRQyxHQUFHLENBQUMsc0JBQXNCSixjQUFjQyxTQUFTLENBQUNJLFFBQVE7WUFFbEUseURBQXlEO1lBQ3pELE1BQU0sRUFDSkMsUUFBUSxFQUNSQyxPQUFPLEVBQ1BDLFVBQVUsRUFDVkMsZ0JBQWdCLEVBQ2hCQyxjQUFjLEVBQ2YsR0FBRyxNQUFNLElBQUksQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNaLGNBQWNDLFNBQVM7WUFFcERFLFFBQVFDLEdBQUcsQ0FBQyxlQUFlRztZQUMzQkosUUFBUUMsR0FBRyxDQUFDLHVCQUF1Qk0sZUFBZUwsUUFBUTtZQUUxRCxtREFBbUQ7WUFDbkQsSUFBSSxDQUFDRSxPQUFPLEdBQUdBO1lBQ2YsSUFBSSxDQUFDQyxVQUFVLEdBQUc7Z0JBQ2hCLEdBQUdBLFVBQVU7Z0JBQ2JSLGVBQWVBLGNBQWMsaUNBQWlDO1lBQ2hFO1lBRUEsZ0ZBQWdGO1lBQ2hGLElBQUksQ0FBQyxJQUFJLENBQUNRLFVBQVUsQ0FBQ0ssY0FBYyxFQUFFO2dCQUNuQyxNQUFNLEVBQUVDLGlCQUFpQixFQUFFLEdBQUcsTUFBTSw4TEFBTztnQkFDM0MsTUFBTUMsVUFBVSxJQUFJRCxrQkFDbEIsSUFBSSxDQUFDTixVQUFVLENBQUNQLFNBQVMsRUFDekIsSUFBSSxDQUFDTyxVQUFVLENBQUNRLGNBQWMsRUFDOUIsSUFBSSxDQUFDUixVQUFVLENBQUNTLFNBQVMsRUFDekIsSUFBSSxDQUFDVCxVQUFVLENBQUNELE9BQU87Z0JBRXpCLElBQUksQ0FBQ0MsVUFBVSxDQUFDSyxjQUFjLEdBQUdFLFFBQVFGLGNBQWM7WUFDekQ7WUFFQSxvQkFBb0I7WUFDcEIsSUFBSWIsY0FBY0MsU0FBUyxDQUFDSSxRQUFRLE9BQU8sSUFBSSxDQUFDRyxVQUFVLENBQUNQLFNBQVMsQ0FBQ0ksUUFBUSxJQUFJO2dCQUMvRUYsUUFBUUMsR0FBRyxDQUFDO1lBQ2QsT0FBTztnQkFDTEQsUUFBUWUsS0FBSyxDQUFDO2dCQUNkZixRQUFRZSxLQUFLLENBQUMsbUJBQW1CbEIsY0FBY0MsU0FBUyxDQUFDSSxRQUFRO2dCQUNqRUYsUUFBUWUsS0FBSyxDQUFDLGdCQUFnQixJQUFJLENBQUNWLFVBQVUsQ0FBQ1AsU0FBUyxDQUFDSSxRQUFRO1lBQ2xFO1lBQ0FGLFFBQVFDLEdBQUcsQ0FBQyx1Q0FBNkIsd0NBQUksQ0FBQ0ksVUFBVSxDQUFDSyxjQUFjLGNBQTlCLHNGQUFnQ1IsUUFBUSxPQUFNO1lBRXZGLDJCQUEyQjtZQUMzQixNQUFNYyxtQkFBbUIsSUFBSWxDLG1EQUFzQixDQUFDUztZQUNwRCxJQUFJLENBQUMyQixRQUFRLEdBQUcsSUFBSXBDLDRDQUFlLENBQUNLLGtCQUFrQkQsb0JBQW9COEI7WUFFMUUsSUFBSTtnQkFDRiwyRUFBMkU7Z0JBQzNFLE1BQU1JLFVBQVUsTUFBTUosaUJBQWlCSyxtQkFBbUIsQ0FBQyxJQUFJLENBQUNoQixVQUFVLENBQUNpQixVQUFVO2dCQUNyRnRCLFFBQVFDLEdBQUcsQ0FBQywrQ0FBcUNtQjtnQkFFakQsSUFBSUEsVUFBVSxHQUFHO29CQUNmcEIsUUFBUUMsR0FBRyxDQUFDO2dCQUNkLE9BQU87b0JBQ0xELFFBQVFDLEdBQUcsQ0FBQztvQkFDWkQsUUFBUUMsR0FBRyxDQUFDO2dCQUNkO1lBQ0YsRUFBRSxPQUFPc0IsYUFBYTtnQkFDcEJ2QixRQUFRQyxHQUFHLENBQUMsb0NBQW9Dc0I7WUFDbEQ7WUFFQSw4Q0FBOEM7WUFDOUMsSUFBSTtnQkFDRixNQUFNQyxPQUFPLE1BQU1SLGlCQUFpQlMsT0FBTyxDQUFDdEM7Z0JBQzVDLElBQUlxQyxTQUFTLE1BQU07b0JBQ2pCeEIsUUFBUTBCLElBQUksQ0FBQyx5Q0FBeUN2QztvQkFDdERhLFFBQVFDLEdBQUcsQ0FBQztnQkFDZCxPQUFPO29CQUNMRCxRQUFRQyxHQUFHLENBQUM7b0JBRVpELFFBQVFDLEdBQUcsQ0FBQztnQkFDZDtZQUNGLEVBQUUsT0FBT3NCLGFBQWE7Z0JBQ3BCdkIsUUFBUTBCLElBQUksQ0FBQyw4QkFBOEJIO1lBQzdDO1FBRUYsRUFBRSxPQUFPUixPQUFPO1lBQ2RmLFFBQVFlLEtBQUssQ0FBQywyQ0FBMkNBO1lBQ3pELE1BQU1BO1FBQ1I7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBTVksa0JBQ0pDLGtCQUEwQixFQUMxQkMsVUFBbUIsRUFDbkJDLFdBQW1CLEVBQzBCO1FBQzdDLElBQUksQ0FBQyxJQUFJLENBQUN6QixVQUFVLElBQUksQ0FBQyxJQUFJLENBQUNhLFFBQVEsRUFBRTtZQUN0QyxNQUFNLElBQUluQixNQUFNO1FBQ2xCO1FBRUEsNEVBQTRFO1FBQzVFLE1BQU1nQyxpQkFBaUJqRCw4Q0FBaUIsQ0FBQzhDLG1CQUFtQkssUUFBUSxJQUFJO1FBQ3hFLElBQUlDLFlBQW9CO1FBRXhCLElBQUk7WUFDRixvREFBb0Q7WUFDcEQsTUFBTUMsUUFBUUMsT0FBTyxNQUFNLElBQUksQ0FBQzVCLFFBQVEsQ0FBQ2EsbUJBQW1CLENBQUMsSUFBSSxDQUFDaEIsVUFBVSxDQUFDaUIsVUFBVTtZQUN2RnRCLFFBQVFDLEdBQUcsQ0FBQyxrQkFBa0JrQztZQUU5Qiw2QkFBNkI7WUFDN0IsTUFBTUUsUUFBUSxJQUFJdkQsNkNBQWdCLENBQUNJO1lBQ25DLE1BQU1xRCxPQUFPRixNQUFNRyxrQkFBa0IsQ0FBQywyQkFBMkI7Z0JBQy9EVDtnQkFDQUY7Z0JBQ0FDO2FBQ0Q7WUFFRCwwQkFBMEI7WUFDMUIsTUFBTVcsa0JBQWtCO2dCQUN0QkMsTUFBTSxJQUFJLENBQUNyQyxVQUFVLENBQUNpQixVQUFVO2dCQUNoQ3FCLElBQUl4RDtnQkFDSm9ELE1BQU1BO1lBQ1I7WUFFQSxlQUFlO1lBQ2YsTUFBTUssaUJBQWlCLE1BQU0sSUFBSSxDQUFDcEMsUUFBUSxDQUFDcUMsK0JBQStCLENBQUM7Z0JBQ3pFQyxhQUFhLElBQUksQ0FBQ3pDLFVBQVUsQ0FBQ1AsU0FBUztnQkFDdENpRCxjQUFjO29CQUFDTjtpQkFBZ0I7WUFDakM7WUFFQSwrQkFBK0I7WUFDL0IsSUFBSSxFQUFFTyxvQkFBb0IsRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDeEMsUUFBUSxDQUFDeUMsMEJBQTBCLENBQUM7Z0JBQzVFTDtnQkFDQUg7Z0JBQ0FOO1lBQ0Y7WUFFQSxvREFBb0Q7WUFDcEQsTUFBTXZCLFVBQVUsTUFBTSxJQUFJLENBQUNzQyxVQUFVLENBQUNDLGNBQWMsQ0FBQyxJQUFJLENBQUM5QyxVQUFVLENBQUNLLGNBQWM7WUFDbkYsSUFBSUUsWUFBWSxNQUFNO2dCQUNwQm9DLHFCQUFxQkksWUFBWSxDQUFDQyxPQUFPLENBQ3ZDeEUscUZBQStCQSxDQUM3QixJQUFJLENBQUN3QixVQUFVLENBQUNRLGNBQWMsRUFDOUIsSUFBSSxDQUFDUixVQUFVLENBQUNQLFNBQVMsRUFDekIsSUFBSSxDQUFDTyxVQUFVLENBQUNpQixVQUFVLEVBQzFCLElBQUksQ0FBQ2xCLE9BQU87WUFHbEI7WUFFQSxxREFBcUQ7WUFDckQsTUFBTSxFQUFFa0QsU0FBUyxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUNKLFVBQVUsQ0FBQ0ssa0JBQWtCO1lBQzlEUCxxQkFBcUJRLGVBQWUsR0FBR0Y7WUFDdkNOLHFCQUFxQlMsUUFBUSxHQUFHLElBQUksQ0FBQ3BELFVBQVUsQ0FBQ1AsU0FBUztZQUV6RCxNQUFNNEQsb0JBQW9CLE1BQU0sSUFBSSxDQUFDckQsVUFBVSxDQUFDUixhQUFhLENBQUM4RCxlQUFlLENBQUNYO1lBRTlFaEQsUUFBUUMsR0FBRyxDQUFDO1lBQ1ppQyxZQUFZLE1BQU0sSUFBSSxDQUFDZ0IsVUFBVSxDQUFDVSxrQkFBa0IsQ0FBQ0Ysa0JBQWtCRyxTQUFTO1lBRWhGN0QsUUFBUUMsR0FBRyxDQUFDLDJCQUFpQmlDO1lBRTdCLHFEQUFxRDtZQUNyRGxDLFFBQVFDLEdBQUcsQ0FBRTtZQUNiLE1BQU0sSUFBSSxDQUFDaUQsVUFBVSxDQUFDWSxrQkFBa0IsQ0FBQztnQkFDdkM1QixXQUFXQTtnQkFDWCxHQUFJLE1BQU0sSUFBSSxDQUFDZ0IsVUFBVSxDQUFDSyxrQkFBa0IsRUFBRTtZQUNoRDtZQUNBdkQsUUFBUUMsR0FBRyxDQUFFO1lBRWIsMkRBQTJEO1lBQzNERCxRQUFRQyxHQUFHLENBQUU7WUFDYixNQUFNLElBQUk4RCxRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTLFFBQVEsZ0NBQWdDO1lBRXpGLDJCQUEyQjtZQUMzQixJQUFJO2dCQUNGaEUsUUFBUUMsR0FBRyxDQUFFO2dCQUViLE1BQU1pRSxpQkFBaUIsTUFBTUMsTUFBTSxrQ0FBa0M7b0JBQ25FQyxRQUFRO29CQUNSQyxTQUFTO3dCQUFFLGdCQUFnQjtvQkFBbUI7b0JBQzlDQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7d0JBQ25CSixRQUFRO3dCQUNSSyxRQUFROzRCQUFDLElBQUksQ0FBQ3BFLFVBQVUsQ0FBQ2lCLFVBQVU7NEJBQUVhO3lCQUFNO3dCQUMzQ3VDLElBQUk7d0JBQ0pDLFNBQVM7b0JBQ1g7Z0JBQ0Y7Z0JBRUEsTUFBTUMsZUFBZSxNQUFNVixlQUFlVyxJQUFJO2dCQUM5QzdFLFFBQVFDLEdBQUcsQ0FBQyx5QkFBeUIyRTtnQkFFckMsSUFBSUEsYUFBYUUsTUFBTSxJQUFJRixhQUFhRSxNQUFNLENBQUNDLElBQUksRUFBRTtvQkFDbkQsTUFBTUMsYUFBYUosYUFBYUUsTUFBTSxDQUFDQyxJQUFJO29CQUMzQy9FLFFBQVFDLEdBQUcsQ0FBQyw0QkFBdUMsT0FBWCtFO29CQUV4Qyw0REFBNEQ7b0JBQzVELElBQUlDLGVBQThCO29CQUVsQyxJQUFLLElBQUlDLFVBQVUsR0FBR0EsV0FBVyxHQUFHQSxVQUFXO3dCQUM3Q2xGLFFBQVFDLEdBQUcsQ0FBQyx3Q0FBZ0QsT0FBUmlGLFNBQVE7d0JBRTVELElBQUk7NEJBQ0YsTUFBTUMsa0JBQWtCLE1BQU1oQixNQUFNLGtDQUFrQztnQ0FDcEVDLFFBQVE7Z0NBQ1JDLFNBQVM7b0NBQUUsZ0JBQWdCO2dDQUFtQjtnQ0FDOUNDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztvQ0FDbkJKLFFBQVE7b0NBQ1JLLFFBQVE7d0NBQUNPO3FDQUFXO29DQUNwQk4sSUFBSTtvQ0FDSkMsU0FBUztnQ0FDWDs0QkFDRjs0QkFFQSxNQUFNUyxnQkFBZ0IsTUFBTUQsZ0JBQWdCTixJQUFJOzRCQUVoRCxJQUFJTyxjQUFjTixNQUFNLElBQUlNLGNBQWNOLE1BQU0sQ0FBQ08sSUFBSSxFQUFFO2dDQUNyRHJGLFFBQVFDLEdBQUcsQ0FBQywrQ0FBc0UsT0FBakNtRixjQUFjTixNQUFNLENBQUNPLElBQUksQ0FBQ0MsTUFBTSxFQUFDO2dDQUVsRixpRUFBaUU7Z0NBQ2pFLEtBQUssTUFBTXJGLE9BQU9tRixjQUFjTixNQUFNLENBQUNPLElBQUksQ0FBRTtvQ0FDM0MsSUFBSTt3Q0FDRixNQUFNaEQsUUFBUSxJQUFJdkQsNkNBQWdCLENBQUNJO3dDQUNuQyxNQUFNcUcsVUFBVWxELE1BQU1tRCxRQUFRLENBQUN2Rjt3Q0FDL0IsSUFBSXNGLFdBQVdBLFFBQVFFLElBQUksS0FBSyxxQkFBcUI7NENBQ25EUixlQUFlTSxRQUFRRyxJQUFJLENBQUNDLE1BQU07NENBQ2xDM0YsUUFBUUMsR0FBRyxDQUFFOzRDQUNiRCxRQUFRQyxHQUFHLENBQUMsc0JBQW1DLE9BQWJnRjs0Q0FDbENqRixRQUFRQyxHQUFHLENBQUMsZUFBdUMsT0FBeEJzRixRQUFRRyxJQUFJLENBQUNFLFVBQVU7NENBQ2xENUYsUUFBUUMsR0FBRyxDQUFDLGNBQXlELE9BQTNDbkIsK0NBQWtCLENBQUN5RyxRQUFRRyxJQUFJLENBQUNJLE1BQU0sRUFBRSxJQUFHOzRDQUNyRTlGLFFBQVFDLEdBQUcsQ0FBQyxvQkFBNkMsT0FBekJzRixRQUFRRyxJQUFJLENBQUM1RCxXQUFXLEVBQUM7NENBRXpELE9BQU87Z0RBQ0w2RCxRQUFRVix5QkFBQUEsMEJBQUFBLGVBQWdCRDtnREFDeEJlLFFBQVFmLFdBQWMsc0NBQXNDOzRDQUM5RDt3Q0FDRjtvQ0FDRixFQUFFLE9BQU9nQixZQUFZO29DQUNuQiwwQkFBMEI7b0NBQzVCO2dDQUNGO2dDQUVBaEcsUUFBUUMsR0FBRyxDQUFFO2dDQUNiLE9BQU8sNENBQTRDOzRCQUNyRCxPQUFPO2dDQUNMRCxRQUFRQyxHQUFHLENBQUMsZ0RBQXdELE9BQVJpRixTQUFRO2dDQUNwRSxJQUFJQSxVQUFVLEdBQUc7b0NBQ2ZsRixRQUFRQyxHQUFHLENBQUU7b0NBQ2IsTUFBTSxJQUFJOEQsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBUztnQ0FDbkQ7NEJBQ0Y7d0JBQ0YsRUFBRSxPQUFPaUMsY0FBbUI7NEJBQzFCakcsUUFBUUMsR0FBRyxDQUFDLG1DQUFrRGdHLE9BQWZmLFNBQVEsU0FBNEIsT0FBckJlLGFBQWFDLE9BQU87NEJBQ2xGLElBQUloQixVQUFVLEdBQUc7Z0NBQ2YsTUFBTSxJQUFJbkIsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBUzs0QkFDbkQ7d0JBQ0Y7b0JBQ0Y7b0JBRUEsMERBQTBEO29CQUMxRGhFLFFBQVFDLEdBQUcsQ0FBRTtvQkFDYixPQUFPO3dCQUNMMEYsUUFBUVg7d0JBQ1JlLFFBQVFmO29CQUNWO2dCQUNGLE9BQU87b0JBQ0xoRixRQUFRQyxHQUFHLENBQUU7Z0JBQ2Y7WUFFRixFQUFFLE9BQU9rRyxXQUFXO2dCQUNsQm5HLFFBQVFDLEdBQUcsQ0FBQywwQ0FBdUUsT0FBN0IsVUFBcUJpRyxPQUFPO1lBQ3BGO1FBRUYsRUFBRSxPQUFPRSxjQUFjO1lBQ3JCcEcsUUFBUUMsR0FBRyxDQUFDLGtDQUFrRSxPQUFoQyxhQUF3QmlHLE9BQU87UUFDL0U7UUFFQWxHLFFBQVFDLEdBQUcsQ0FBRTtRQUViLCtCQUErQjtRQUMvQixPQUFPO1lBQ0wwRixRQUFRekQ7WUFDUjZELFFBQVE3RDtRQUNWO0lBQ0Y7SUFBRW1FLE1BQU10RixLQUFVLEVBQUU7UUFDbEJmLFFBQVFlLEtBQUssQ0FBQyxnQ0FBZ0NBO1FBQzlDLE1BQU1BO0lBQ1I7SUFHQTs7R0FFQyxHQUNELE1BQWN1Rix1QkFBc0M7UUFDbEQsSUFBSSxDQUFDLElBQUksQ0FBQ3BGLFFBQVEsRUFBRTtZQUNsQix3REFBd0Q7WUFDeEQsTUFBTUYsbUJBQW1CLElBQUlsQyxtREFBc0IsQ0FBQ1M7WUFDcEQsSUFBSSxDQUFDMkIsUUFBUSxHQUFHLElBQUlwQyw0Q0FBZSxDQUFDSyxrQkFBa0JELG9CQUFvQjhCO1FBQzVFO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE1BQU11RixlQUFlWixNQUFjLEVBQXdCO1FBQ3pELDBDQUEwQztRQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDekUsUUFBUSxFQUFFO1lBQ2xCLE1BQU0sSUFBSSxDQUFDb0Ysb0JBQW9CO1FBQ2pDO1FBRUF0RyxRQUFRQyxHQUFHLENBQUMsaUNBQWlDMEY7UUFDN0MzRixRQUFRQyxHQUFHLENBQUMscUJBQXFCZDtRQUVqQyxJQUFJO1lBQ0YsTUFBTTJGLFNBQVMsTUFBTSxJQUFJLENBQUM1RCxRQUFRLENBQUVzRixvQkFBb0IsQ0FBQ2I7WUFDekQzRixRQUFRQyxHQUFHLENBQUMsd0JBQXdCNkU7WUFFcEMsTUFBTTJCLGNBQWM7Z0JBQ2xCYixZQUFZZCxPQUFPYyxVQUFVO2dCQUM3QmMsZUFBZTVCLE9BQU80QixhQUFhO2dCQUNuQ1osUUFBUWhCLE9BQU9nQixNQUFNO2dCQUNyQmpFLFlBQVlpRCxPQUFPakQsVUFBVTtnQkFDN0I4RSxVQUFVN0IsT0FBTzZCLFFBQVE7Z0JBQ3pCQyxlQUFlOUIsT0FBTzhCLGFBQWE7Z0JBQ25DQyxjQUFjekUsT0FBTzBDLE9BQU8rQixZQUFZO2dCQUN4Qy9FLGFBQWFnRCxPQUFPaEQsV0FBVztZQUNqQztZQUVBLHNGQUFzRjtZQUN0RixJQUFJZ0QsT0FBT2MsVUFBVSxLQUFLLGdEQUN4QmQsT0FBT2dCLE1BQU0sS0FBS2dCLE9BQU8sTUFDekIsQ0FBQ2hDLE9BQU82QixRQUFRLEVBQUU7Z0JBQ2xCM0csUUFBUTBCLElBQUksQ0FBQztnQkFFYix5RkFBeUY7Z0JBQ3pGLElBQUlpRSxPQUFPTCxNQUFNLEtBQUssTUFBTUssT0FBT29CLFVBQVUsQ0FBQyxPQUFPO29CQUNuRC9HLFFBQVFDLEdBQUcsQ0FBQztvQkFDWkQsUUFBUUMsR0FBRyxDQUFDO29CQUNaRCxRQUFRQyxHQUFHLENBQUM7b0JBRVosOEVBQThFO29CQUM5RUQsUUFBUUMsR0FBRyxDQUFDO2dCQUNkO1lBQ0Y7WUFFQSxPQUFPd0c7UUFDVCxFQUFFLE9BQU8xRixPQUFPO1lBQ2RmLFFBQVFlLEtBQUssQ0FBQyx3QkFBd0JBO1lBQ3RDLE1BQU0sSUFBSWhCLE1BQU07UUFDbEI7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBTWlILGFBQWFDLGNBQXNCLEVBQXFCO1FBQzVELDBDQUEwQztRQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDL0YsUUFBUSxFQUFFO1lBQ2xCLE1BQU0sSUFBSSxDQUFDb0Ysb0JBQW9CO1FBQ2pDO1FBRUEsSUFBSTtZQUNGLE9BQU8sTUFBTSxJQUFJLENBQUNwRixRQUFRLENBQUVnRyxrQkFBa0IsQ0FBQ0Q7UUFDakQsRUFBRSxPQUFPbEcsT0FBTztZQUNkZixRQUFRZSxLQUFLLENBQUMsNkJBQTZCQTtZQUMzQyxPQUFPLEVBQUU7UUFDWDtJQUNGO0lBRUE7O0dBRUMsR0FDRCxNQUFNb0csUUFDSnhCLE1BQWMsRUFDZHlCLFNBQWlCLEVBQ3dDO1FBQ3pELElBQUksQ0FBQyxJQUFJLENBQUMvRyxVQUFVLElBQUksQ0FBQyxJQUFJLENBQUNhLFFBQVEsRUFBRTtZQUN0QyxNQUFNLElBQUluQixNQUFNO1FBQ2xCO1FBRUFDLFFBQVFDLEdBQUcsQ0FBQztRQUNaRCxRQUFRQyxHQUFHLENBQUMsWUFBWTBGO1FBQ3hCM0YsUUFBUUMsR0FBRyxDQUFDLGVBQWVtSDtRQUUzQiw0REFBNEQ7UUFDNUQsTUFBTUMsV0FBVyxNQUFNLElBQUksQ0FBQ2QsY0FBYyxDQUFDWjtRQUMzQzNGLFFBQVFDLEdBQUcsQ0FBQyxzQkFBc0JvSDtRQUVsQyxJQUFJLENBQUNBLFNBQVNWLFFBQVEsRUFBRTtZQUN0QixNQUFNLElBQUk1RyxNQUFNO1FBQ2xCO1FBRUEsMEJBQTBCO1FBQzFCLE1BQU1nQyxpQkFBaUJ1RixLQUFLQyxLQUFLLENBQUNILFlBQVk7UUFFOUMsSUFBSUk7UUFFSixJQUFJO2dCQWMyQkMsa0JBZ0lHQyxxQkFHdEJBO1lBaEpWLGdEQUFnRDtZQUNoRDFILFFBQVFDLEdBQUcsQ0FBQztZQUNaRCxRQUFRQyxHQUFHLENBQUMsU0FBUyxJQUFJLENBQUNJLFVBQVUsQ0FBQ1AsU0FBUyxDQUFDSSxRQUFRO1lBQ3ZERixRQUFRQyxHQUFHLENBQUMseUJBQXlCb0gsU0FBU1gsYUFBYTtZQUMzRDFHLFFBQVFDLEdBQUcsQ0FBQyxvQkFBb0I4QjtZQUVoQyw2REFBNkQ7WUFDN0QsZ0NBQWdDO1lBQ2hDLE1BQU0wRixZQUFZSixTQUFTWCxhQUFhLENBQUNLLFVBQVUsQ0FBQyxRQUNoRE0sU0FBU1gsYUFBYSxDQUFDaUIsS0FBSyxDQUFDLEtBQzdCTixTQUFTWCxhQUFhO1lBRTFCLG1DQUFtQztZQUNuQyxNQUFNa0IsUUFBUSxJQUFJQyxXQUFXSixFQUFBQSxtQkFBQUEsVUFBVUssS0FBSyxDQUFDLHNCQUFoQkwsdUNBQUFBLGlCQUEwQk0sR0FBRyxDQUFDQyxDQUFBQSxPQUFRQyxTQUFTRCxNQUFNLFNBQVEsRUFBRTtZQUU1RixtRkFBbUY7WUFDbkYsd0ZBQXdGO1lBQ3hGLElBQUlFO1lBRUosSUFBSU4sTUFBTXRDLE1BQU0sS0FBSyxJQUFJO2dCQUN2QixrQ0FBa0M7Z0JBQ2xDNEMsa0JBQWtCLElBQUksQ0FBQyxNQUFNLDBMQUF3QixFQUFHQyxTQUFTLENBQUNQO1lBQ3BFLE9BQU8sSUFBSUEsTUFBTXRDLE1BQU0sR0FBRyxJQUFJO2dCQUM1Qix3Q0FBd0M7Z0JBQ3hDLE1BQU04QyxjQUFjUixNQUFNRCxLQUFLLENBQUMsQ0FBQztnQkFDakNPLGtCQUFrQixJQUFJLENBQUMsTUFBTSwwTEFBd0IsRUFBR0MsU0FBUyxDQUFDQztZQUNwRSxPQUFPO2dCQUNMLG9DQUFvQztnQkFDcEMsTUFBTUMsY0FBYyxJQUFJUixXQUFXO2dCQUNuQ1EsWUFBWUMsR0FBRyxDQUFDVixPQUFPLEtBQUtBLE1BQU10QyxNQUFNO2dCQUN4QzRDLGtCQUFrQixJQUFJLENBQUMsTUFBTSwwTEFBd0IsRUFBR0MsU0FBUyxDQUFDRTtZQUNwRTtZQUVBckksUUFBUUMsR0FBRyxDQUFDLHdCQUF3QmlJLGdCQUFnQmhJLFFBQVE7WUFFNUQsc0NBQXNDO1lBQ3RDLE1BQU0sRUFBRXFJLGFBQWEsRUFBRUMsV0FBVyxFQUFFLEdBQUcsTUFBTSwwTEFBTztZQUVwRCw4QkFBOEI7WUFDOUIsTUFBTUMsYUFBYUYsY0FBY0csUUFBUSxDQUFDO2dCQUN4Q0MsWUFBWSxJQUFJLENBQUN0SSxVQUFVLENBQUNQLFNBQVM7Z0JBQ3JDOEksVUFBVVY7Z0JBQ1ZXLFVBQVU5RztZQUNaO1lBRUEscUJBQXFCO1lBQ3JCLE1BQU0rRyxhQUFhLElBQUlOLGNBQWNPLEdBQUcsQ0FBQ047WUFFekMsa0RBQWtEO1lBQ2xEekksUUFBUUMsR0FBRyxDQUFDO1lBQ1osTUFBTSxFQUFFcUQsU0FBUyxFQUFFMEYsc0JBQXNCQyxtQkFBbUIsRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDL0YsVUFBVSxDQUFDSyxrQkFBa0IsQ0FBQztZQUMxR3ZELFFBQVFDLEdBQUcsQ0FBQyxpQ0FBaUNxRDtZQUM3Q3RELFFBQVFDLEdBQUcsQ0FBQyw0QkFBNEJnSjtZQUV4Q0gsV0FBV3RGLGVBQWUsR0FBR0Y7WUFDN0J3RixXQUFXckYsUUFBUSxHQUFHLElBQUksQ0FBQ3BELFVBQVUsQ0FBQ1AsU0FBUztZQUUvQyw2Q0FBNkM7WUFDN0NFLFFBQVFDLEdBQUcsQ0FBQztZQUNaLE1BQU1pSixtQkFBbUIsTUFBTSxJQUFJLENBQUM3SSxVQUFVLENBQUNSLGFBQWEsQ0FBQzhELGVBQWUsQ0FBQ21GO1lBQzdFdEIsb0JBQW9CLE1BQU0sSUFBSSxDQUFDdEUsVUFBVSxDQUFDVSxrQkFBa0IsQ0FBQ3NGLGlCQUFpQnJGLFNBQVM7WUFFdkY3RCxRQUFRQyxHQUFHLENBQUMsc0JBQXNCdUg7WUFFbEMsc0RBQXNEO1lBQ3RELE1BQU0sSUFBSSxDQUFDdEUsVUFBVSxDQUFDWSxrQkFBa0IsQ0FBQztnQkFDdkM1QixXQUFXc0Y7Z0JBQ1gsR0FBSSxNQUFNLElBQUksQ0FBQ3RFLFVBQVUsQ0FBQ0ssa0JBQWtCLEVBQUU7WUFDaEQ7WUFDQXZELFFBQVFDLEdBQUcsQ0FBQztZQUVaLDZDQUE2QztZQUM3Q0QsUUFBUUMsR0FBRyxDQUFDO1lBRVosc0NBQXNDO1lBQ3RDLE1BQU1rSixxQkFBcUJuSyxvREFBWUEsQ0FBQ0QsK0NBQU9BLENBQUMsSUFBSSxDQUFDc0IsVUFBVSxDQUFDUCxTQUFTLENBQUNzSixPQUFPLEtBQUs7WUFFdEYsb0JBQW9CO1lBQ3BCLE1BQU1qSCxRQUFRQyxPQUFPLE1BQU0sSUFBSSxDQUFDNUIsUUFBUSxDQUFDYSxtQkFBbUIsQ0FBQyxJQUFJLENBQUNoQixVQUFVLENBQUNpQixVQUFVO1lBQ3ZGdEIsUUFBUUMsR0FBRyxDQUFDLGtCQUFrQmtDO1lBRTlCLDZCQUE2QjtZQUM3QixNQUFNRSxRQUFRLElBQUl2RCw2Q0FBZ0IsQ0FBQ0k7WUFDbkMsTUFBTXFELE9BQU9GLE1BQU1HLGtCQUFrQixDQUFDLGlCQUFpQjtnQkFDckRtRDtnQkFDQTVEO2dCQUNBb0g7YUFDRDtZQUVELDBCQUEwQjtZQUMxQixNQUFNMUcsa0JBQWtCO2dCQUN0QkMsTUFBTSxJQUFJLENBQUNyQyxVQUFVLENBQUNpQixVQUFVO2dCQUNoQ3FCLElBQUl4RDtnQkFDSm9ELE1BQU1BO1lBQ1I7WUFFQSxlQUFlO1lBQ2YsTUFBTUssaUJBQWlCLE1BQU0sSUFBSSxDQUFDcEMsUUFBUSxDQUFDcUMsK0JBQStCLENBQUM7Z0JBQ3pFQyxhQUFhLElBQUksQ0FBQ3pDLFVBQVUsQ0FBQ1AsU0FBUztnQkFDdENpRCxjQUFjO29CQUFDTjtpQkFBZ0I7WUFDakM7WUFFQSwrQkFBK0I7WUFDL0IsSUFBSSxFQUFFTyxvQkFBb0IsRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDeEMsUUFBUSxDQUFDeUMsMEJBQTBCLENBQUM7Z0JBQzVFTDtnQkFDQUg7Z0JBQ0FOO1lBQ0Y7WUFFQSxrREFBa0Q7WUFDbERuQyxRQUFRQyxHQUFHLENBQUM7WUFDWixNQUFNLEVBQUVxRCxXQUFXK0YsaUJBQWlCLEVBQUVMLHNCQUFzQk0sbUJBQW1CLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQ3BHLFVBQVUsQ0FBQ0ssa0JBQWtCLENBQUM7WUFDN0h2RCxRQUFRQyxHQUFHLENBQUMsa0NBQWtDb0o7WUFDOUNySixRQUFRQyxHQUFHLENBQUMsNEJBQTRCcUo7WUFFeEN0RyxxQkFBcUJRLGVBQWUsR0FBRzZGO1lBQ3ZDckcscUJBQXFCUyxRQUFRLEdBQUcsSUFBSSxDQUFDcEQsVUFBVSxDQUFDUCxTQUFTO1lBRXpELCtDQUErQztZQUMvQ0UsUUFBUUMsR0FBRyxDQUFDO1lBQ1osTUFBTXNKLFdBQVcsTUFBTSxJQUFJLENBQUNsSixVQUFVLENBQUNSLGFBQWEsQ0FBQzhELGVBQWUsQ0FBQ1g7WUFFckUsK0JBQStCO1lBQy9CaEQsUUFBUUMsR0FBRyxDQUFDO1lBQ1osTUFBTSxJQUFJLENBQUNpRCxVQUFVLENBQUNVLGtCQUFrQixDQUFDMkYsU0FBUzFGLFNBQVM7WUFFM0QsNkNBQTZDO1lBQzdDLE1BQU02RCxvQkFBb0IsTUFBTSxJQUFJLENBQUNsSCxRQUFRLENBQUNnSiw0QkFBNEIsQ0FDeEUsSUFBSSxDQUFDbkosVUFBVSxDQUFDaUIsVUFBVSxFQUMxQmEsT0FDQTtZQUdGLElBQUl1RixrQkFBa0JwQyxNQUFNLEtBQUssS0FBS29DLGlCQUFpQixDQUFDLEVBQUUsQ0FBQytCLE1BQU0sS0FBSyxXQUFXO2dCQUMvRXpKLFFBQVEwQixJQUFJLENBQUM7Z0JBQ2IxQixRQUFRQyxHQUFHLENBQUMsdUJBQXVCdUg7WUFDbkMsd0VBQXdFO1lBQzFFO1lBRUF4SCxRQUFRQyxHQUFHLENBQUM7WUFDWkQsUUFBUUMsR0FBRyxDQUFDLGlCQUFpQnVIO1lBQzdCeEgsUUFBUUMsR0FBRyxDQUFDLHFCQUFvQnlILHNCQUFBQSxpQkFBaUIsQ0FBQyxFQUFFLGNBQXBCQSwwQ0FBQUEsb0JBQXNCZ0MsZUFBZTtZQUVyRSxPQUFPO2dCQUNMM0QsUUFBUTJCLEVBQUFBLHVCQUFBQSxpQkFBaUIsQ0FBQyxFQUFFLGNBQXBCQSwyQ0FBQUEscUJBQXNCZ0MsZUFBZSxLQUFJO2dCQUNqRGxDO1lBQ0Y7UUFDRixFQUFFLE9BQU96RyxPQUFZO1lBQ25CZixRQUFRZSxLQUFLLENBQUMsc0JBQXNCQTtZQUNwQyxJQUFJeUcsbUJBQW1CO2dCQUNyQnhILFFBQVFDLEdBQUcsQ0FBQywwQ0FBMEN1SDtZQUN4RDtZQUNBLE1BQU16RztRQUNSO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE1BQU00SSxlQUFlaEUsTUFBYyxFQUErQjtRQUNoRSxJQUFJLENBQUMsSUFBSSxDQUFDdEYsVUFBVSxJQUFJLENBQUMsSUFBSSxDQUFDYSxRQUFRLEVBQUU7WUFDdEMsTUFBTSxJQUFJbkIsTUFBTTtRQUNsQjtRQUVBLElBQUk7WUFDRixvQkFBb0I7WUFDcEIsTUFBTW9DLFFBQVFDLE9BQU8sTUFBTSxJQUFJLENBQUM1QixRQUFRLENBQUNhLG1CQUFtQixDQUFDLElBQUksQ0FBQ2hCLFVBQVUsQ0FBQ2lCLFVBQVU7WUFDdkZ0QixRQUFRQyxHQUFHLENBQUMsa0JBQWtCa0M7WUFFOUIsNkJBQTZCO1lBQzdCLE1BQU1FLFFBQVEsSUFBSXZELDZDQUFnQixDQUFDSTtZQUNuQyxNQUFNcUQsT0FBT0YsTUFBTUcsa0JBQWtCLENBQUMsd0JBQXdCO2dCQUFDbUQ7YUFBTztZQUV0RSwwQkFBMEI7WUFDMUIsTUFBTWxELGtCQUFrQjtnQkFDdEJDLE1BQU0sSUFBSSxDQUFDckMsVUFBVSxDQUFDaUIsVUFBVTtnQkFDaENxQixJQUFJeEQ7Z0JBQ0pvRCxNQUFNQTtZQUNSO1lBRUEsZUFBZTtZQUNmLE1BQU1LLGlCQUFpQixNQUFNLElBQUksQ0FBQ3BDLFFBQVEsQ0FBQ3FDLCtCQUErQixDQUFDO2dCQUN6RUMsYUFBYSxJQUFJLENBQUN6QyxVQUFVLENBQUNQLFNBQVM7Z0JBQ3RDaUQsY0FBYztvQkFBQ047aUJBQWdCO1lBQ2pDO1lBRUEsK0JBQStCO1lBQy9CLElBQUksRUFBRU8sb0JBQW9CLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQ3hDLFFBQVEsQ0FBQ3lDLDBCQUEwQixDQUFDO2dCQUM1RUw7Z0JBQ0FIO2dCQUNBTjtZQUNGO1lBRUEsa0RBQWtEO1lBQ2xEbkMsUUFBUUMsR0FBRyxDQUFDO1lBQ1osTUFBTSxFQUFFcUQsU0FBUyxFQUFFMEYsc0JBQXNCWSxxQkFBcUIsRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDMUcsVUFBVSxDQUFDSyxrQkFBa0IsQ0FBQztZQUM1R3ZELFFBQVFDLEdBQUcsQ0FBQywrQkFBK0JxRDtZQUMzQ3RELFFBQVFDLEdBQUcsQ0FBQyw0QkFBNEIySjtZQUV4QzVHLHFCQUFxQlEsZUFBZSxHQUFHRjtZQUN2Q04scUJBQXFCUyxRQUFRLEdBQUcsSUFBSSxDQUFDcEQsVUFBVSxDQUFDUCxTQUFTO1lBRXpELCtDQUErQztZQUMvQ0UsUUFBUUMsR0FBRyxDQUFDO1lBQ1osTUFBTXNKLFdBQVcsTUFBTSxJQUFJLENBQUNsSixVQUFVLENBQUNSLGFBQWEsQ0FBQzhELGVBQWUsQ0FBQ1g7WUFFckUsK0JBQStCO1lBQy9CaEQsUUFBUUMsR0FBRyxDQUFDO1lBQ1osTUFBTSxJQUFJLENBQUNpRCxVQUFVLENBQUNVLGtCQUFrQixDQUFDMkYsU0FBUzFGLFNBQVM7WUFFM0QsaUNBQWlDO1lBQ2pDLE1BQU02RCxvQkFBb0IsTUFBTSxJQUFJLENBQUNsSCxRQUFRLENBQUNnSiw0QkFBNEIsQ0FDeEUsSUFBSSxDQUFDbkosVUFBVSxDQUFDaUIsVUFBVSxFQUMxQmEsT0FDQTtZQUdGLElBQUl1RixrQkFBa0JwQyxNQUFNLEtBQUssS0FBS29DLGlCQUFpQixDQUFDLEVBQUUsQ0FBQytCLE1BQU0sS0FBSyxXQUFXO2dCQUMvRSxNQUFNLElBQUkxSixNQUFNO1lBQ2xCO1lBRUEsT0FBTztnQkFDTGdHLFFBQVEyQixpQkFBaUIsQ0FBQyxFQUFFLENBQUNnQyxlQUFlO1lBQzlDO1FBQ0YsRUFBRSxPQUFPM0ksT0FBWTtZQUNuQixNQUFNQTtRQUNSO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEOEksaUJBQWlCbEUsTUFBYyxFQUFVO1FBQ3ZDLE9BQU8sR0FBaUNBLE9BQTlCbUUsT0FBT0MsUUFBUSxDQUFDQyxNQUFNLEVBQUMsU0FBYyxPQUFQckU7SUFDMUM7SUFFQTs7R0FFQyxHQUNELE9BQU9zRSxxQkFBcUJDLEdBQVcsRUFBaUI7UUFDdEQsSUFBSTtZQUNGLE1BQU1DLFNBQVMsSUFBSUMsSUFBSUY7WUFDdkIsT0FBT0MsT0FBT0UsWUFBWSxDQUFDQyxHQUFHLENBQUM7UUFDakMsRUFBRSxVQUFNO1lBQ04sT0FBTztRQUNUO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEQyxvQkFBbUM7WUFDMUI7UUFBUCxPQUFPLHlCQUFJLENBQUNsSyxVQUFVLGNBQWYsd0RBQWlCaUIsVUFBVSxLQUFJO0lBQ3hDO0lBdHBCQWtKLGFBQWM7YUFITnBLLFVBQXlCO2FBQ3pCYyxXQUFtQztRQUd6QyxJQUFJLENBQUNnQyxVQUFVLEdBQUcsSUFBSXZFLHVEQUFVQSxDQUFDZSxnQkFBZ0I7UUFDakQsSUFBSSxDQUFDYyxRQUFRLEdBQUcsSUFBSTVCLGlFQUFlQSxDQUFDYTtJQUN0QztBQW9wQkY7QUFFQSw0QkFBNEI7QUFDckIsTUFBTWdMLHVCQUF1QixJQUFJOUssdUJBQXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3V0aWxzL3NvbGFuYS1uYXRpdmUtY29udHJhY3QudHM/ZDRjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb25uZWN0aW9uLCBQdWJsaWNLZXksIEtleXBhaXIgfSBmcm9tICdAc29sYW5hL3dlYjMuanMnXG5pbXBvcnQgeyBOZW9uUHJveHlScGNBcGksIGNyZWF0ZUJhbGFuY2VBY2NvdW50SW5zdHJ1Y3Rpb24sIFNvbGFuYU5lb25BY2NvdW50IH0gZnJvbSAnQG5lb25ldm0vc29sYW5hLXNpZ24nXG5pbXBvcnQgeyBldGhlcnMsIGhleGxpZnksIHplcm9QYWRWYWx1ZSB9IGZyb20gJ2V0aGVycydcbmltcG9ydCBDb250cmFjdEFCSSBmcm9tICcuL2NvbnRyYWN0QUJJLmpzb24nXG5cbi8vIFVzZSB0aGUgYWN0dWFsIGRlcGxveWVkIGNvbnRyYWN0IEFCSVxuY29uc3QgU09MQU5BX1RJUENBUkRfQUJJID0gQ29udHJhY3RBQklcblxuY29uc3QgQ09OVFJBQ1RfQUREUkVTUyA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1RJUENBUkRfQ09OVFJBQ1RfQUREUkVTUyB8fCAnMHhDRkUwM2M3YzY3NDU2RDA5NEMwMTYyRjkwMzAzOTNGQzJjQ2M0MENiJ1xuY29uc3QgTkVPTl9DT1JFX1JQQ19VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19ORU9OX1JQQ19VUkwgfHwgJ2h0dHBzOi8vZGV2bmV0Lm5lb25ldm0ub3JnJ1xuY29uc3QgTkVPTl9QUk9YWV9SUENfVVJMID0gYCR7TkVPTl9DT1JFX1JQQ19VUkx9L3NvbGBcbmNvbnN0IFNPTEFOQV9SUENfVVJMID0gJ2h0dHBzOi8vYXBpLmRldm5ldC5zb2xhbmEuY29tJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFBheW1lbnRMaW5rIHtcbiAgZXZtQ3JlYXRvcjogc3RyaW5nXG4gIHNvbGFuYUNyZWF0b3I6IHN0cmluZ1xuICBhbW91bnQ6IGJpZ2ludFxuICBpc0ZsZXhpYmxlOiBib29sZWFuXG4gIGlzQWN0aXZlOiBib29sZWFuXG4gIHRvdGFsUmVjZWl2ZWQ6IGJpZ2ludFxuICBwYXltZW50Q291bnQ6IG51bWJlclxuICBkZXNjcmlwdGlvbjogc3RyaW5nXG59XG5cbmV4cG9ydCBjbGFzcyBTb2xhbmFOYXRpdmVDb250cmFjdCB7XG4gIHByaXZhdGUgY29ubmVjdGlvbjogQ29ubmVjdGlvblxuICBwcml2YXRlIHByb3h5QXBpOiBOZW9uUHJveHlScGNBcGlcbiAgcHJpdmF0ZSBzb2xhbmFVc2VyOiBhbnlcbiAgcHJpdmF0ZSBjaGFpbklkOiBudW1iZXIgfCBudWxsID0gbnVsbFxuICBwcml2YXRlIGNvbnRyYWN0OiBldGhlcnMuQ29udHJhY3QgfCBudWxsID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldyBDb25uZWN0aW9uKFNPTEFOQV9SUENfVVJMLCAnY29uZmlybWVkJylcbiAgICB0aGlzLnByb3h5QXBpID0gbmV3IE5lb25Qcm94eVJwY0FwaShORU9OX1BST1hZX1JQQ19VUkwpXG4gIH1cblxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHdpdGggU29sYW5hIHdhbGxldCB1c2luZyB0aGUgcmVjb21tZW5kZWQgU29sYW5hTmVvbkFjY291bnQgYXBwcm9hY2hcbiAgICovXG4gIGFzeW5jIGluaXRXaXRoU29sYW5hV2FsbGV0KHdhbGxldEFkYXB0ZXI6IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghd2FsbGV0QWRhcHRlci5wdWJsaWNLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBjb25uZWN0ZWQnKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+UpyBVc2luZyByZWNvbW1lbmRlZCBTb2xhbmFOZW9uQWNjb3VudCBhcHByb2FjaC4uLicpXG4gICAgICBjb25zb2xlLmxvZygnV2FsbGV0IHB1YmxpYyBrZXk6Jywgd2FsbGV0QWRhcHRlci5wdWJsaWNLZXkudG9CYXNlNTgoKSlcblxuICAgICAgLy8gVXNlIHByb3h5QXBpLmluaXQgd2l0aCBqdXN0IHRoZSBwdWJsaWMga2V5IChsaWtlIGRlbW8pXG4gICAgICBjb25zdCB7XG4gICAgICAgIHByb3ZpZGVyLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgICBzb2xhbmFVc2VyLFxuICAgICAgICB0b2tlbk1pbnRBZGRyZXNzLFxuICAgICAgICBwcm9ncmFtQWRkcmVzc1xuICAgICAgfSA9IGF3YWl0IHRoaXMucHJveHlBcGkuaW5pdCh3YWxsZXRBZGFwdGVyLnB1YmxpY0tleSlcblxuICAgICAgY29uc29sZS5sb2coJy0gQ2hhaW4gSUQ6JywgY2hhaW5JZClcbiAgICAgIGNvbnNvbGUubG9nKCctIE5lb24gRVZNIFByb2dyYW06JywgcHJvZ3JhbUFkZHJlc3MudG9CYXNlNTgoKSlcblxuICAgICAgLy8gU3RvcmUgdGhlIHJlc3VsdCB3aXRoIHdhbGxldCBhZGFwdGVyIGZvciBzaWduaW5nXG4gICAgICB0aGlzLmNoYWluSWQgPSBjaGFpbklkXG4gICAgICB0aGlzLnNvbGFuYVVzZXIgPSB7XG4gICAgICAgIC4uLnNvbGFuYVVzZXIsXG4gICAgICAgIHdhbGxldEFkYXB0ZXI6IHdhbGxldEFkYXB0ZXIgLy8gQWRkIHdhbGxldCBhZGFwdGVyIGZvciBzaWduaW5nXG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBiYWxhbmNlIGFkZHJlc3MgaWYgaXQgZG9lc24ndCBleGlzdCAodXNpbmcgU29sYW5hTmVvbkFjY291bnQgYXBwcm9hY2gpXG4gICAgICBpZiAoIXRoaXMuc29sYW5hVXNlci5iYWxhbmNlQWRkcmVzcykge1xuICAgICAgICBjb25zdCB7IFNvbGFuYU5lb25BY2NvdW50IH0gPSBhd2FpdCBpbXBvcnQoJ0BuZW9uZXZtL3NvbGFuYS1zaWduJylcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IG5ldyBTb2xhbmFOZW9uQWNjb3VudChcbiAgICAgICAgICB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LFxuICAgICAgICAgIHRoaXMuc29sYW5hVXNlci5uZW9uRXZtUHJvZ3JhbSxcbiAgICAgICAgICB0aGlzLnNvbGFuYVVzZXIudG9rZW5NaW50LFxuICAgICAgICAgIHRoaXMuc29sYW5hVXNlci5jaGFpbklkXG4gICAgICAgIClcbiAgICAgICAgdGhpcy5zb2xhbmFVc2VyLmJhbGFuY2VBZGRyZXNzID0gYWNjb3VudC5iYWxhbmNlQWRkcmVzc1xuICAgICAgfVxuXG4gICAgICAvLyBWZXJpZnkgdGhleSBtYXRjaFxuICAgICAgaWYgKHdhbGxldEFkYXB0ZXIucHVibGljS2V5LnRvQmFzZTU4KCkgPT09IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXkudG9CYXNlNTgoKSkge1xuICAgICAgICBjb25zb2xlLmxvZygn4pyFIFdhbGxldCBwdWJsaWMga2V5cyBtYXRjaCBjb3JyZWN0bHkhJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBNSVNNQVRDSDogV2FsbGV0IGFkYXB0ZXIgYW5kIHNvbGFuYSB1c2VyIGhhdmUgZGlmZmVyZW50IHB1YmxpYyBrZXlzIScpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1dhbGxldCBhZGFwdGVyOicsIHdhbGxldEFkYXB0ZXIucHVibGljS2V5LnRvQmFzZTU4KCkpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NvbGFuYSB1c2VyOicsIHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXkudG9CYXNlNTgoKSlcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKCfwn5KwIEZpbmFsIGJhbGFuY2UgYWRkcmVzczonLCB0aGlzLnNvbGFuYVVzZXIuYmFsYW5jZUFkZHJlc3M/LnRvQmFzZTU4KCkgfHwgJ1N0aWxsIG5vdCBhdmFpbGFibGUnKVxuXG4gICAgICAvLyBDcmVhdGUgY29udHJhY3QgaW5zdGFuY2VcbiAgICAgIGNvbnN0IHJlYWRPbmx5UHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihORU9OX0NPUkVfUlBDX1VSTClcbiAgICAgIHRoaXMuY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KENPTlRSQUNUX0FERFJFU1MsIFNPTEFOQV9USVBDQVJEX0FCSSwgcmVhZE9ubHlQcm92aWRlcilcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBFVk0gYWRkcmVzcyBoYXMgYmVlbiB1c2VkIGJlZm9yZSAoaGFzIHRyYW5zYWN0aW9uIGhpc3RvcnkpXG4gICAgICAgIGNvbnN0IHR4Q291bnQgPSBhd2FpdCByZWFkT25seVByb3ZpZGVyLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQpXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OKIEVWTSBhZGRyZXNzIHRyYW5zYWN0aW9uIGNvdW50OicsIHR4Q291bnQpXG5cbiAgICAgICAgaWYgKHR4Q291bnQgPiAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBUaGlzIEVWTSBhZGRyZXNzIGhhcyB0cmFuc2FjdGlvbiBoaXN0b3J5IC0gaXQgZXhpc3RzIG9uLWNoYWluIScpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ+KEue+4jyBUaGlzIEVWTSBhZGRyZXNzIGlzIG5ldyAobm8gdHJhbnNhY3Rpb24gaGlzdG9yeSB5ZXQpJylcbiAgICAgICAgICBjb25zb2xlLmxvZygn4oS577iPIFRoZSBhZGRyZXNzIHdpbGwgYmUgcmVnaXN0ZXJlZCBvbi1jaGFpbiB3aGVuIGZpcnN0IHRyYW5zYWN0aW9uIGlzIG1hZGUnKVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoICh2ZXJpZnlFcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZygn4pqg77iPIENvdWxkIG5vdCB2ZXJpZnkgRVZNIGFkZHJlc3M6JywgdmVyaWZ5RXJyb3IpXG4gICAgICB9XG5cbiAgICAgIC8vIFZlcmlmeSBjb250cmFjdCBpcyBkZXBsb3llZCBhdCB0aGlzIGFkZHJlc3NcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCByZWFkT25seVByb3ZpZGVyLmdldENvZGUoQ09OVFJBQ1RfQUREUkVTUylcbiAgICAgICAgaWYgKGNvZGUgPT09ICcweCcpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBObyBjb250cmFjdCBjb2RlIGZvdW5kIGF0IGFkZHJlc3M6JywgQ09OVFJBQ1RfQUREUkVTUylcbiAgICAgICAgICBjb25zb2xlLmxvZygnVGhpcyBtaWdodCBtZWFuIHRoZSBjb250cmFjdCBpcyBub3QgZGVwbG95ZWQgb3IgYWRkcmVzcyBpcyBpbmNvcnJlY3QnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgQ29udHJhY3QgZm91bmQgYXQgYWRkcmVzcycpXG5cbiAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIENvbnRyYWN0IGZvdW5kIGFuZCByZWFkeSBmb3IgdHJhbnNhY3Rpb25zJylcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAodmVyaWZ5RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gdmVyaWZ5IGNvbnRyYWN0OicsIHZlcmlmeUVycm9yKVxuICAgICAgfVxuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIFNvbGFuYSBOYXRpdmUgU0RLOicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgcGF5bWVudCBsaW5rIHVzaW5nIFNvbGFuYSBOYXRpdmUgU0RLXG4gICAqL1xuICBhc3luYyBjcmVhdGVQYXltZW50TGluayhcbiAgICBzdWdnZXN0ZWRBbW91bnRTT0w6IG51bWJlcixcbiAgICBpc0ZsZXhpYmxlOiBib29sZWFuLFxuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgKTogUHJvbWlzZTx7IGxpbmtJZDogc3RyaW5nOyB0eEhhc2g6IHN0cmluZyB9PiB7XG4gICAgaWYgKCF0aGlzLnNvbGFuYVVzZXIgfHwgIXRoaXMuY29udHJhY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIGNvbm5lY3Qgd2FsbGV0IGZpcnN0JylcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IFNPTCB0byBsYW1wb3J0cyB1c2luZyBldGhlcnMgZm9yIHByZWNpc2lvbiAoMSBTT0wgPSAxZTkgbGFtcG9ydHMpXG4gICAgY29uc3QgYW1vdW50TGFtcG9ydHMgPSBldGhlcnMucGFyc2VVbml0cyhzdWdnZXN0ZWRBbW91bnRTT0wudG9TdHJpbmcoKSwgOSlcbiAgICBsZXQgc2lnbmF0dXJlOiBzdHJpbmcgPSAnJ1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBjdXJyZW50IG5vbmNlIChleGFjdGx5IGxpa2Ugd29ya2luZyBleGFtcGxlcylcbiAgICAgIGNvbnN0IG5vbmNlID0gTnVtYmVyKGF3YWl0IHRoaXMucHJveHlBcGkuZ2V0VHJhbnNhY3Rpb25Db3VudCh0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCkpXG4gICAgICBjb25zb2xlLmxvZygnQ3VycmVudCBub25jZTonLCBub25jZSlcblxuICAgICAgLy8gUHJlcGFyZSBjb250cmFjdCBjYWxsIGRhdGFcbiAgICAgIGNvbnN0IGlmYWNlID0gbmV3IGV0aGVycy5JbnRlcmZhY2UoU09MQU5BX1RJUENBUkRfQUJJKVxuICAgICAgY29uc3QgZGF0YSA9IGlmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YSgnY3JlYXRlU29sYW5hUGF5bWVudExpbmsnLCBbXG4gICAgICAgIGFtb3VudExhbXBvcnRzLFxuICAgICAgICBpc0ZsZXhpYmxlLFxuICAgICAgICBkZXNjcmlwdGlvblxuICAgICAgXSlcblxuICAgICAgLy8gQ3JlYXRlIHRyYW5zYWN0aW9uIGRhdGFcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uRGF0YSA9IHtcbiAgICAgICAgZnJvbTogdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsXG4gICAgICAgIHRvOiBDT05UUkFDVF9BRERSRVNTLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9XG5cbiAgICAgIC8vIEVzdGltYXRlIGdhc1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25HYXMgPSBhd2FpdCB0aGlzLnByb3h5QXBpLmVzdGltYXRlU2NoZWR1bGVkVHJhbnNhY3Rpb25HYXMoe1xuICAgICAgICBzb2xhbmFQYXllcjogdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleSxcbiAgICAgICAgdHJhbnNhY3Rpb25zOiBbdHJhbnNhY3Rpb25EYXRhXSxcbiAgICAgIH0pXG5cbiAgICAgIC8vIENyZWF0ZSBzY2hlZHVsZWQgdHJhbnNhY3Rpb25cbiAgICAgIGxldCB7IHNjaGVkdWxlZFRyYW5zYWN0aW9uIH0gPSBhd2FpdCB0aGlzLnByb3h5QXBpLmNyZWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgdHJhbnNhY3Rpb25HYXMsXG4gICAgICAgIHRyYW5zYWN0aW9uRGF0YSxcbiAgICAgICAgbm9uY2VcbiAgICAgIH0pXG5cbiAgICAgIC8vIENoZWNrIGlmIGJhbGFuY2UgYWNjb3VudCBleGlzdHMsIGlmIG5vdCBjcmVhdGUgaXRcbiAgICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZ2V0QWNjb3VudEluZm8odGhpcy5zb2xhbmFVc2VyLmJhbGFuY2VBZGRyZXNzKVxuICAgICAgaWYgKGFjY291bnQgPT09IG51bGwpIHtcbiAgICAgICAgc2NoZWR1bGVkVHJhbnNhY3Rpb24uaW5zdHJ1Y3Rpb25zLnVuc2hpZnQoXG4gICAgICAgICAgY3JlYXRlQmFsYW5jZUFjY291bnRJbnN0cnVjdGlvbihcbiAgICAgICAgICAgIHRoaXMuc29sYW5hVXNlci5uZW9uRXZtUHJvZ3JhbSxcbiAgICAgICAgICAgIHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXksXG4gICAgICAgICAgICB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCxcbiAgICAgICAgICAgIHRoaXMuY2hhaW5JZCFcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gU2lnbiBhbmQgc2VuZCB0cmFuc2FjdGlvbiB1c2luZyBleGFjdCB0ZXN0IHBhdHRlcm5cbiAgICAgIGNvbnN0IHsgYmxvY2toYXNoIH0gPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKClcbiAgICAgIHNjaGVkdWxlZFRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGJsb2NraGFzaFxuICAgICAgc2NoZWR1bGVkVHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5XG5cbiAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5zb2xhbmFVc2VyLndhbGxldEFkYXB0ZXIuc2lnblRyYW5zYWN0aW9uKHNjaGVkdWxlZFRyYW5zYWN0aW9uKVxuXG4gICAgICBjb25zb2xlLmxvZygnU3VibWl0dGluZyB0cmFuc2FjdGlvbi4uLicpXG4gICAgICBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uc2VuZFJhd1RyYW5zYWN0aW9uKHNpZ25lZFRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpKVxuXG4gICAgICBjb25zb2xlLmxvZygn8J+UlyBTaWduYXR1cmU6Jywgc2lnbmF0dXJlKVxuXG4gICAgICAvLyBXYWl0IGZvciBTb2xhbmEgY29uZmlybWF0aW9uIGZpcnN0IChsaWtlIHRoZSB0ZXN0KVxuICAgICAgY29uc29sZS5sb2coYFdhaXRpbmcgZm9yIFNvbGFuYSBjb25maXJtYXRpb24uLi5gKTtcbiAgICAgIGF3YWl0IHRoaXMuY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oe1xuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICAgICAgLi4uKGF3YWl0IHRoaXMuY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goKSlcbiAgICAgIH0pO1xuICAgICAgY29uc29sZS5sb2coYOKchSBTb2xhbmEgdHJhbnNhY3Rpb24gY29uZmlybWVkYCk7XG5cbiAgICAgIC8vIFdhaXQgYWRkaXRpb25hbCB0aW1lIGZvciBOZW9uIHByb2Nlc3NpbmcgKGxpa2UgdGhlIHRlc3QpXG4gICAgICBjb25zb2xlLmxvZyhgV2FpdGluZyBmb3IgTmVvbiBFVk0gcHJvY2Vzc2luZy4uLmApO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMDApKTsgLy8gV2FpdCAzIG1vcmUgc2Vjb25kcyBsaWtlIHRlc3RcblxuICAgICAgLy8gQ2hlY2sgdHJhbnNhY3Rpb24gc3RhdHVzXG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZyhgR2V0dGluZyBOZW9uIEVWTSB0cmFuc2FjdGlvbiBkZXRhaWxzLi4uYCk7XG5cbiAgICAgICAgY29uc3QgbmVvblR4UmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9kZXZuZXQubmVvbmV2bS5vcmcvc29sJywge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJuZW9uX2dldFRyYW5zYWN0aW9uQnlTZW5kZXJOb25jZVwiLFxuICAgICAgICAgICAgcGFyYW1zOiBbdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsIG5vbmNlXSxcbiAgICAgICAgICAgIGlkOiAxLFxuICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIlxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG5lb25UeFJlc3VsdCA9IGF3YWl0IG5lb25UeFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJOZW9uIEVWTSB0eG4gcmVzdWx0OiBcIiwgbmVvblR4UmVzdWx0KTtcblxuICAgICAgICBpZiAobmVvblR4UmVzdWx0LnJlc3VsdCAmJiBuZW9uVHhSZXN1bHQucmVzdWx0Lmhhc2gpIHtcbiAgICAgICAgICBjb25zdCBuZW9uVHhIYXNoID0gbmVvblR4UmVzdWx0LnJlc3VsdC5oYXNoO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgTmVvbiBFVk0gcGF5bWVudCBoYXNoOiAke25lb25UeEhhc2h9YCk7XG5cbiAgICAgICAgICAvLyBSZXRyeSBnZXR0aW5nIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0IHdpdGggcHJvcGVyIHdhaXRpbmdcbiAgICAgICAgICBsZXQgYWN0dWFsTGlua0lkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICBcbiAgICAgICAgICBmb3IgKGxldCBhdHRlbXB0ID0gMTsgYXR0ZW1wdCA8PSA1OyBhdHRlbXB0KyspIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBHZXR0aW5nIHRyYW5zYWN0aW9uIHJlY2VpcHQgKGF0dGVtcHQgJHthdHRlbXB0fS81KS4uLmApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCByZWNlaXB0UmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9kZXZuZXQubmVvbmV2bS5vcmcvc29sJywge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIsXG4gICAgICAgICAgICAgICAgICBwYXJhbXM6IFtuZW9uVHhIYXNoXSxcbiAgICAgICAgICAgICAgICAgIGlkOiAxLFxuICAgICAgICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgY29uc3QgcmVjZWlwdFJlc3VsdCA9IGF3YWl0IHJlY2VpcHRSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAocmVjZWlwdFJlc3VsdC5yZXN1bHQgJiYgcmVjZWlwdFJlc3VsdC5yZXN1bHQubG9ncykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OLIFRyYW5zYWN0aW9uIHJlY2VpcHQgZm91bmQgd2l0aCAke3JlY2VpcHRSZXN1bHQucmVzdWx0LmxvZ3MubGVuZ3RofSBsb2dzYCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgU29sYW5hTGlua0NyZWF0ZWQgZXZlbnQgdG8gZXh0cmFjdCB0aGUgYWN0dWFsIGxpbmsgSURcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxvZyBvZiByZWNlaXB0UmVzdWx0LnJlc3VsdC5sb2dzKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZmFjZSA9IG5ldyBldGhlcnMuSW50ZXJmYWNlKFNPTEFOQV9USVBDQVJEX0FCSSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlY29kZWQgPSBpZmFjZS5wYXJzZUxvZyhsb2cpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVjb2RlZCAmJiBkZWNvZGVkLm5hbWUgPT09ICdTb2xhbmFMaW5rQ3JlYXRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhY3R1YWxMaW5rSWQgPSBkZWNvZGVkLmFyZ3MubGlua0lkO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn46JIEZvdW5kIFNvbGFuYUxpbmtDcmVhdGVkIGV2ZW50IWApO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBBY3R1YWwgTGluayBJRDogJHthY3R1YWxMaW5rSWR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIENyZWF0b3I6ICR7ZGVjb2RlZC5hcmdzLmV2bUNyZWF0b3J9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIEFtb3VudDogJHtldGhlcnMuZm9ybWF0VW5pdHMoZGVjb2RlZC5hcmdzLmFtb3VudCwgOSl9IFNPTGApO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICBEZXNjcmlwdGlvbjogXCIke2RlY29kZWQuYXJncy5kZXNjcmlwdGlvbn1cImApO1xuICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rSWQ6IGFjdHVhbExpbmtJZCA/PyBuZW9uVHhIYXNoLCAgLy8gRW5zdXJlIGxpbmtJZCBpcyBhbHdheXMgYSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4SGFzaDogbmVvblR4SGFzaCAgICAvLyBLZWVwIHRyYW5zYWN0aW9uIGhhc2ggZm9yIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IG91ciBldmVudCwgY29udGludWVcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBTb2xhbmFMaW5rQ3JlYXRlZCBldmVudCBub3QgZm91bmQgaW4gdHJhbnNhY3Rpb24gbG9nc2ApO1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBSZWNlaXB0IGV4aXN0cyBidXQgbm8gZXZlbnQgLSBkb24ndCByZXRyeVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDimqDvuI8gTm8gdHJhbnNhY3Rpb24gcmVjZWlwdCBmb3VuZCB5ZXQgKGF0dGVtcHQgJHthdHRlbXB0fS81KWApO1xuICAgICAgICAgICAgICAgIGlmIChhdHRlbXB0IDwgNSkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFdhaXRpbmcgNSBzZWNvbmRzIGJlZm9yZSBuZXh0IGF0dGVtcHQuLi5gKTtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDAwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChyZWNlaXB0RXJyb3I6IGFueSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg4pqg77iPIFJlY2VpcHQgZmV0Y2ggZXJyb3IgKGF0dGVtcHQgJHthdHRlbXB0fS81KTogJHtyZWNlaXB0RXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgaWYgKGF0dGVtcHQgPCA1KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMDApKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIHRyYW5zYWN0aW9uIGhhc2ggaWYgd2UgY2FuJ3QgZmluZCB0aGUgZXZlbnRcbiAgICAgICAgICBjb25zb2xlLmxvZyhgVXNpbmcgdHJhbnNhY3Rpb24gaGFzaCBhcyBmYWxsYmFjayBsaW5rIElEYCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpbmtJZDogbmVvblR4SGFzaCxcbiAgICAgICAgICAgIHR4SGFzaDogbmVvblR4SGFzaFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKEue+4jyBOZW9uIEVWTSBwYXltZW50IHRyYW5zYWN0aW9uIG5vdCBmb3VuZCB5ZXQgKG1heSBzdGlsbCBiZSBwcm9jZXNzaW5nKWApO1xuICAgICAgICB9XG5cbiAgICAgIH0gY2F0Y2ggKG5lb25FcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZyhg4oS577iPIENvdWxkIG5vdCBnZXQgTmVvbiBwYXltZW50IGRldGFpbHM6ICR7KG5lb25FcnJvciBhcyBFcnJvcikubWVzc2FnZX1gKTtcbiAgICAgIH1cblxuICAgIH0gY2F0Y2ggKGNvbmZpcm1FcnJvcikge1xuICAgICAgY29uc29sZS5sb2coYOKEue+4jyBQYXltZW50IGNvbmZpcm1hdGlvbiBjaGVjazogJHsoY29uZmlybUVycm9yIGFzIEVycm9yKS5tZXNzYWdlfWApO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGDwn46JIFBheW1lbnQgdHJhbnNhY3Rpb24gY29tcGxldGVkIWApO1xuXG4gICAgLy8gUmV0dXJuIHNpZ25hdHVyZSBhcyBmYWxsYmFja1xuICAgIHJldHVybiB7XG4gICAgICBsaW5rSWQ6IHNpZ25hdHVyZSxcbiAgICAgIHR4SGFzaDogc2lnbmF0dXJlXG4gICAgfTtcbiAgfSBjYXRjaChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgcGF5bWVudCBsaW5rOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgcmVhZC1vbmx5IGNvbnRyYWN0IGFjY2VzcyAod2l0aG91dCB3YWxsZXQpXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGluaXRSZWFkT25seUNvbnRyYWN0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5jb250cmFjdCkge1xuICAgICAgLy8gQ3JlYXRlIGEgc2ltcGxlIEpTT04gUlBDIHByb3ZpZGVyIGZvciByZWFkIG9wZXJhdGlvbnNcbiAgICAgIGNvbnN0IHJlYWRPbmx5UHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihORU9OX0NPUkVfUlBDX1VSTClcbiAgICAgIHRoaXMuY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KENPTlRSQUNUX0FERFJFU1MsIFNPTEFOQV9USVBDQVJEX0FCSSwgcmVhZE9ubHlQcm92aWRlcilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHBheW1lbnQgbGluayBkZXRhaWxzXG4gICAqL1xuICBhc3luYyBnZXRQYXltZW50TGluayhsaW5rSWQ6IHN0cmluZyk6IFByb21pc2U8UGF5bWVudExpbms+IHtcbiAgICAvLyBJbml0aWFsaXplIGNvbnRyYWN0IGlmIG5vdCBhbHJlYWR5IGRvbmVcbiAgICBpZiAoIXRoaXMuY29udHJhY3QpIHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdFJlYWRPbmx5Q29udHJhY3QoKVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIHBheW1lbnQgbGluayB3aXRoIElEOicsIGxpbmtJZClcbiAgICBjb25zb2xlLmxvZygnQ29udHJhY3QgYWRkcmVzczonLCBDT05UUkFDVF9BRERSRVNTKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY29udHJhY3QhLmdldFNvbGFuYVBheW1lbnRMaW5rKGxpbmtJZClcbiAgICAgIGNvbnNvbGUubG9nKCdSYXcgY29udHJhY3QgcmVzdWx0OicsIHJlc3VsdClcblxuICAgICAgY29uc3QgcGF5bWVudExpbmsgPSB7XG4gICAgICAgIGV2bUNyZWF0b3I6IHJlc3VsdC5ldm1DcmVhdG9yLFxuICAgICAgICBzb2xhbmFDcmVhdG9yOiByZXN1bHQuc29sYW5hQ3JlYXRvcixcbiAgICAgICAgYW1vdW50OiByZXN1bHQuYW1vdW50LFxuICAgICAgICBpc0ZsZXhpYmxlOiByZXN1bHQuaXNGbGV4aWJsZSxcbiAgICAgICAgaXNBY3RpdmU6IHJlc3VsdC5pc0FjdGl2ZSxcbiAgICAgICAgdG90YWxSZWNlaXZlZDogcmVzdWx0LnRvdGFsUmVjZWl2ZWQsXG4gICAgICAgIHBheW1lbnRDb3VudDogTnVtYmVyKHJlc3VsdC5wYXltZW50Q291bnQpLFxuICAgICAgICBkZXNjcmlwdGlvbjogcmVzdWx0LmRlc2NyaXB0aW9uXG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgbG9va3MgbGlrZSBhbiBlbXB0eS9ub24tZXhpc3RlbnQgbGluayAodHJhbnNhY3Rpb24gbm90IHByb2Nlc3NlZCB5ZXQpXG4gICAgICBpZiAocmVzdWx0LmV2bUNyZWF0b3IgPT09ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnICYmXG4gICAgICAgIHJlc3VsdC5hbW91bnQgPT09IEJpZ0ludCgwKSAmJlxuICAgICAgICAhcmVzdWx0LmlzQWN0aXZlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignUGF5bWVudCBsaW5rIGFwcGVhcnMgdG8gYmUgZW1wdHkvbm9uLWV4aXN0ZW50JylcblxuICAgICAgICAvLyBJZiB0aGlzIGxvb2tzIGxpa2UgYSB0cmFuc2FjdGlvbiBoYXNoICg2NiBjaGFycywgc3RhcnRzIHdpdGggMHgpLCBwcm92aWRlIGhlbHBmdWwgaW5mb1xuICAgICAgICBpZiAobGlua0lkLmxlbmd0aCA9PT0gNjYgJiYgbGlua0lkLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+SoSBUaGlzIGFwcGVhcnMgdG8gYmUgYSB0cmFuc2FjdGlvbiBoYXNoIC0gdGhlIHBheW1lbnQgbGluayBtYXkgc3RpbGwgYmUgcHJvY2Vzc2luZycpXG4gICAgICAgICAgY29uc29sZS5sb2coJ/CfkqEgTmVvbiBvcGVyYXRvcnMgd2lsbCBldmVudHVhbGx5IHByb2Nlc3MgdGhpcyB0cmFuc2FjdGlvbiBhbmQgY3JlYXRlIHRoZSBwYXltZW50IGxpbmsnKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5KhIFlvdSBjYW4gYm9va21hcmsgdGhpcyBsaW5rIGFuZCB0cnkgYWdhaW4gaW4gYSBmZXcgbWludXRlcycpXG5cbiAgICAgICAgICAvLyBGb3Igbm93LCBkb24ndCB0aHJvdyBhbiBlcnJvciAtIGxldCB0aGUgVUkgaGFuZGxlIHRoZSBlbXB0eSBkYXRhIGdyYWNlZnVsbHlcbiAgICAgICAgICBjb25zb2xlLmxvZygnUmV0dXJuaW5nIGVtcHR5IHBheW1lbnQgbGluayBkYXRhIC0gdHJhbnNhY3Rpb24gbWF5IHN0aWxsIGJlIHByb2Nlc3NpbmcnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXltZW50TGlua1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDb250cmFjdCBjYWxsIGVycm9yOicsIGVycm9yKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXltZW50IGxpbmsgbm90IGZvdW5kIG9yIGNvbnRyYWN0IGVycm9yJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHVzZXIncyBwYXltZW50IGxpbmtzXG4gICAqL1xuICBhc3luYyBnZXRVc2VyTGlua3ModXNlckVWTUFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICAvLyBJbml0aWFsaXplIGNvbnRyYWN0IGlmIG5vdCBhbHJlYWR5IGRvbmVcbiAgICBpZiAoIXRoaXMuY29udHJhY3QpIHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdFJlYWRPbmx5Q29udHJhY3QoKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb250cmFjdCEuZ2V0VXNlclNvbGFuYUxpbmtzKHVzZXJFVk1BZGRyZXNzKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHVzZXIgbGlua3M6JywgZXJyb3IpXG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGF5IGEgcGF5bWVudCBsaW5rIHVzaW5nIFNvbGFuYSBOYXRpdmUgU0RLXG4gICAqL1xuICBhc3luYyBwYXlMaW5rKFxuICAgIGxpbmtJZDogc3RyaW5nLFxuICAgIGFtb3VudFNPTDogbnVtYmVyXG4gICk6IFByb21pc2U8eyB0eEhhc2g6IHN0cmluZzsgdHJhbnNmZXJTaWduYXR1cmU/OiBzdHJpbmcgfT4ge1xuICAgIGlmICghdGhpcy5zb2xhbmFVc2VyIHx8ICF0aGlzLmNvbnRyYWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBjb25uZWN0IHdhbGxldCBmaXJzdCcpXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIHBheW1lbnQgcHJvY2Vzcy4uLicpXG4gICAgY29uc29sZS5sb2coJ0xpbmsgSUQ6JywgbGlua0lkKVxuICAgIGNvbnNvbGUubG9nKCdBbW91bnQgU09MOicsIGFtb3VudFNPTClcblxuICAgIC8vIEZpcnN0LCBnZXQgdGhlIHBheW1lbnQgbGluayBkZXRhaWxzIHRvIGZpbmQgdGhlIHJlY2lwaWVudFxuICAgIGNvbnN0IGxpbmtEYXRhID0gYXdhaXQgdGhpcy5nZXRQYXltZW50TGluayhsaW5rSWQpXG4gICAgY29uc29sZS5sb2coJ1BheW1lbnQgbGluayBkYXRhOicsIGxpbmtEYXRhKVxuXG4gICAgaWYgKCFsaW5rRGF0YS5pc0FjdGl2ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXltZW50IGxpbmsgaXMgbm8gbG9uZ2VyIGFjdGl2ZScpXG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBTT0wgdG8gbGFtcG9ydHNcbiAgICBjb25zdCBhbW91bnRMYW1wb3J0cyA9IE1hdGguZmxvb3IoYW1vdW50U09MICogMWU5KVxuXG4gICAgbGV0IHRyYW5zZmVyU2lnbmF0dXJlOiBzdHJpbmcgfCB1bmRlZmluZWRcblxuICAgIHRyeSB7XG4gICAgICAvLyBTdGVwIDE6IFBlcmZvcm0gdGhlIGFjdHVhbCBTT0wgdHJhbnNmZXIgZmlyc3RcbiAgICAgIGNvbnNvbGUubG9nKCdTdGVwIDE6IFBlcmZvcm1pbmcgU09MIHRyYW5zZmVyLi4uJylcbiAgICAgIGNvbnNvbGUubG9nKCdGcm9tOicsIHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXkudG9CYXNlNTgoKSlcbiAgICAgIGNvbnNvbGUubG9nKCdUbyByZWNpcGllbnQgYnl0ZXMzMjonLCBsaW5rRGF0YS5zb2xhbmFDcmVhdG9yKVxuICAgICAgY29uc29sZS5sb2coJ0Ftb3VudCBsYW1wb3J0czonLCBhbW91bnRMYW1wb3J0cylcblxuICAgICAgLy8gQ29udmVydCByZWNpcGllbnQgU29sYW5hIGFkZHJlc3MgZnJvbSBieXRlczMyIHRvIFB1YmxpY0tleVxuICAgICAgLy8gUmVtb3ZlICcweCcgcHJlZml4IGlmIHByZXNlbnRcbiAgICAgIGNvbnN0IGhleFN0cmluZyA9IGxpbmtEYXRhLnNvbGFuYUNyZWF0b3Iuc3RhcnRzV2l0aCgnMHgnKVxuICAgICAgICA/IGxpbmtEYXRhLnNvbGFuYUNyZWF0b3Iuc2xpY2UoMilcbiAgICAgICAgOiBsaW5rRGF0YS5zb2xhbmFDcmVhdG9yXG5cbiAgICAgIC8vIENvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG4gICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGhleFN0cmluZy5tYXRjaCgvLnsyfS9nKT8ubWFwKGJ5dGUgPT4gcGFyc2VJbnQoYnl0ZSwgMTYpKSB8fCBbXSlcblxuICAgICAgLy8gRm9yIGJ5dGVzMzIgZnJvbSBTb2xhbmEgYWRkcmVzc2VzLCB3ZSBuZWVkIHRvIGZpbmQgdGhlIGFjdHVhbCAzMi1ieXRlIHB1YmxpYyBrZXlcbiAgICAgIC8vIFRoZSBieXRlczMyIHNob3VsZCBjb250YWluIHRoZSAzMi1ieXRlIFNvbGFuYSBwdWJsaWMga2V5LCBwb3NzaWJseSB3aXRoIGxlYWRpbmcgemVyb3NcbiAgICAgIGxldCByZWNpcGllbnRQdWJrZXlcblxuICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMzIpIHtcbiAgICAgICAgLy8gRGlyZWN0IGNvbnZlcnNpb24gZnJvbSAzMiBieXRlc1xuICAgICAgICByZWNpcGllbnRQdWJrZXkgPSBuZXcgKGF3YWl0IGltcG9ydCgnQHNvbGFuYS93ZWIzLmpzJykpLlB1YmxpY0tleShieXRlcylcbiAgICAgIH0gZWxzZSBpZiAoYnl0ZXMubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgLy8gVGFrZSB0aGUgbGFzdCAzMiBieXRlcyBpZiBpdCdzIGxvbmdlclxuICAgICAgICBjb25zdCBsYXN0MzJCeXRlcyA9IGJ5dGVzLnNsaWNlKC0zMilcbiAgICAgICAgcmVjaXBpZW50UHVia2V5ID0gbmV3IChhd2FpdCBpbXBvcnQoJ0Bzb2xhbmEvd2ViMy5qcycpKS5QdWJsaWNLZXkobGFzdDMyQnl0ZXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBQYWQgd2l0aCBsZWFkaW5nIHplcm9zIGlmIHNob3J0ZXJcbiAgICAgICAgY29uc3QgcGFkZGVkQnl0ZXMgPSBuZXcgVWludDhBcnJheSgzMilcbiAgICAgICAgcGFkZGVkQnl0ZXMuc2V0KGJ5dGVzLCAzMiAtIGJ5dGVzLmxlbmd0aClcbiAgICAgICAgcmVjaXBpZW50UHVia2V5ID0gbmV3IChhd2FpdCBpbXBvcnQoJ0Bzb2xhbmEvd2ViMy5qcycpKS5QdWJsaWNLZXkocGFkZGVkQnl0ZXMpXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdSZWNpcGllbnQgUHVibGljS2V5OicsIHJlY2lwaWVudFB1YmtleS50b0Jhc2U1OCgpKVxuXG4gICAgICAvLyBDcmVhdGUgdGhlIFNPTCB0cmFuc2ZlciB0cmFuc2FjdGlvblxuICAgICAgY29uc3QgeyBTeXN0ZW1Qcm9ncmFtLCBUcmFuc2FjdGlvbiB9ID0gYXdhaXQgaW1wb3J0KCdAc29sYW5hL3dlYjMuanMnKVxuXG4gICAgICAvLyBDcmVhdGUgdHJhbnNmZXIgaW5zdHJ1Y3Rpb25cbiAgICAgIGNvbnN0IHRyYW5zZmVySXggPSBTeXN0ZW1Qcm9ncmFtLnRyYW5zZmVyKHtcbiAgICAgICAgZnJvbVB1YmtleTogdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleSxcbiAgICAgICAgdG9QdWJrZXk6IHJlY2lwaWVudFB1YmtleSxcbiAgICAgICAgbGFtcG9ydHM6IGFtb3VudExhbXBvcnRzXG4gICAgICB9KVxuXG4gICAgICAvLyBDcmVhdGUgdHJhbnNhY3Rpb25cbiAgICAgIGNvbnN0IHRyYW5zZmVyVHggPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQodHJhbnNmZXJJeClcblxuICAgICAgLy8gR2V0IGZyZXNoIHJlY2VudCBibG9ja2hhc2ggcmlnaHQgYmVmb3JlIHNpZ25pbmdcbiAgICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIGZyZXNoIGJsb2NraGFzaCBmb3IgU09MIHRyYW5zZmVyLi4uJylcbiAgICAgIGNvbnN0IHsgYmxvY2toYXNoLCBsYXN0VmFsaWRCbG9ja0hlaWdodDogdHJhbnNmZXJCbG9ja0hlaWdodCB9ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgnY29uZmlybWVkJylcbiAgICAgIGNvbnNvbGUubG9nKCdGcmVzaCBTT0wgdHJhbnNmZXIgYmxvY2toYXNoOicsIGJsb2NraGFzaClcbiAgICAgIGNvbnNvbGUubG9nKCdMYXN0IHZhbGlkIGJsb2NrIGhlaWdodDonLCB0cmFuc2ZlckJsb2NrSGVpZ2h0KVxuXG4gICAgICB0cmFuc2ZlclR4LnJlY2VudEJsb2NraGFzaCA9IGJsb2NraGFzaFxuICAgICAgdHJhbnNmZXJUeC5mZWVQYXllciA9IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXlcblxuICAgICAgLy8gU2lnbiBhbmQgc2VuZCB0aGUgU09MIHRyYW5zZmVyIGltbWVkaWF0ZWx5XG4gICAgICBjb25zb2xlLmxvZygnU2lnbmluZyBhbmQgc2VuZGluZyBTT0wgdHJhbnNmZXIgd2l0aCBmcmVzaCBibG9ja2hhc2guLi4nKVxuICAgICAgY29uc3Qgc2lnbmVkVHJhbnNmZXJUeCA9IGF3YWl0IHRoaXMuc29sYW5hVXNlci53YWxsZXRBZGFwdGVyLnNpZ25UcmFuc2FjdGlvbih0cmFuc2ZlclR4KVxuICAgICAgdHJhbnNmZXJTaWduYXR1cmUgPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uc2VuZFJhd1RyYW5zYWN0aW9uKHNpZ25lZFRyYW5zZmVyVHguc2VyaWFsaXplKCkpXG5cbiAgICAgIGNvbnNvbGUubG9nKCdTT0wgdHJhbnNmZXIgc2VudDonLCB0cmFuc2ZlclNpZ25hdHVyZSlcblxuICAgICAgLy8gV2FpdCBmb3IgdHJhbnNmZXIgY29uZmlybWF0aW9uIHVzaW5nIHRoZSBtb2Rlcm4gQVBJXG4gICAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHtcbiAgICAgICAgc2lnbmF0dXJlOiB0cmFuc2ZlclNpZ25hdHVyZSxcbiAgICAgICAgLi4uKGF3YWl0IHRoaXMuY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goKSlcbiAgICAgIH0pXG4gICAgICBjb25zb2xlLmxvZygnU09MIHRyYW5zZmVyIGNvbmZpcm1lZCcpXG5cbiAgICAgIC8vIFN0ZXAgMjogUmVjb3JkIHRoZSBwYXltZW50IGluIHRoZSBjb250cmFjdFxuICAgICAgY29uc29sZS5sb2coJ1N0ZXAgMjogUmVjb3JkaW5nIHBheW1lbnQgaW4gY29udHJhY3QuLi4nKVxuXG4gICAgICAvLyBDb252ZXJ0IFNvbGFuYSBQdWJsaWNLZXkgdG8gYnl0ZXMzMlxuICAgICAgY29uc3QgcGF5ZXJTb2xhbmFCeXRlczMyID0gemVyb1BhZFZhbHVlKGhleGxpZnkodGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleS50b0J5dGVzKCkpLCAzMilcblxuICAgICAgLy8gR2V0IGN1cnJlbnQgbm9uY2VcbiAgICAgIGNvbnN0IG5vbmNlID0gTnVtYmVyKGF3YWl0IHRoaXMucHJveHlBcGkuZ2V0VHJhbnNhY3Rpb25Db3VudCh0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCkpXG4gICAgICBjb25zb2xlLmxvZygnQ3VycmVudCBub25jZTonLCBub25jZSlcblxuICAgICAgLy8gUHJlcGFyZSBjb250cmFjdCBjYWxsIGRhdGFcbiAgICAgIGNvbnN0IGlmYWNlID0gbmV3IGV0aGVycy5JbnRlcmZhY2UoU09MQU5BX1RJUENBUkRfQUJJKVxuICAgICAgY29uc3QgZGF0YSA9IGlmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YSgncGF5U29sYW5hTGluaycsIFtcbiAgICAgICAgbGlua0lkLFxuICAgICAgICBhbW91bnRMYW1wb3J0cyxcbiAgICAgICAgcGF5ZXJTb2xhbmFCeXRlczMyXG4gICAgICBdKVxuXG4gICAgICAvLyBDcmVhdGUgdHJhbnNhY3Rpb24gZGF0YVxuICAgICAgY29uc3QgdHJhbnNhY3Rpb25EYXRhID0ge1xuICAgICAgICBmcm9tOiB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCxcbiAgICAgICAgdG86IENPTlRSQUNUX0FERFJFU1MsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH1cblxuICAgICAgLy8gRXN0aW1hdGUgZ2FzXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkdhcyA9IGF3YWl0IHRoaXMucHJveHlBcGkuZXN0aW1hdGVTY2hlZHVsZWRUcmFuc2FjdGlvbkdhcyh7XG4gICAgICAgIHNvbGFuYVBheWVyOiB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LFxuICAgICAgICB0cmFuc2FjdGlvbnM6IFt0cmFuc2FjdGlvbkRhdGFdLFxuICAgICAgfSlcblxuICAgICAgLy8gQ3JlYXRlIHNjaGVkdWxlZCB0cmFuc2FjdGlvblxuICAgICAgbGV0IHsgc2NoZWR1bGVkVHJhbnNhY3Rpb24gfSA9IGF3YWl0IHRoaXMucHJveHlBcGkuY3JlYXRlU2NoZWR1bGVkVHJhbnNhY3Rpb24oe1xuICAgICAgICB0cmFuc2FjdGlvbkdhcyxcbiAgICAgICAgdHJhbnNhY3Rpb25EYXRhLFxuICAgICAgICBub25jZVxuICAgICAgfSlcblxuICAgICAgLy8gR2V0IGZyZXNoIHJlY2VudCBibG9ja2hhc2ggcmlnaHQgYmVmb3JlIHNpZ25pbmdcbiAgICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIGZyZXNoIGJsb2NraGFzaCBmb3IgY29udHJhY3QgY2FsbC4uLicpXG4gICAgICBjb25zdCB7IGJsb2NraGFzaDogY29udHJhY3RCbG9ja2hhc2gsIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiBjb250cmFjdEJsb2NrSGVpZ2h0IH0gPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCdjb25maXJtZWQnKVxuICAgICAgY29uc29sZS5sb2coJ0ZyZXNoIGNvbnRyYWN0IGNhbGwgYmxvY2toYXNoOicsIGNvbnRyYWN0QmxvY2toYXNoKVxuICAgICAgY29uc29sZS5sb2coJ0xhc3QgdmFsaWQgYmxvY2sgaGVpZ2h0OicsIGNvbnRyYWN0QmxvY2tIZWlnaHQpXG5cbiAgICAgIHNjaGVkdWxlZFRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGNvbnRyYWN0QmxvY2toYXNoXG4gICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5mZWVQYXllciA9IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXlcblxuICAgICAgLy8gU2lnbiB3aXRoIHdhbGxldCBhZGFwdGVyIChmcm9udGVuZCBhcHByb2FjaClcbiAgICAgIGNvbnNvbGUubG9nKCdTaWduaW5nIGNvbnRyYWN0IGNhbGwgd2l0aCBmcmVzaCBibG9ja2hhc2guLi4nKVxuICAgICAgY29uc3Qgc2lnbmVkVHggPSBhd2FpdCB0aGlzLnNvbGFuYVVzZXIud2FsbGV0QWRhcHRlci5zaWduVHJhbnNhY3Rpb24oc2NoZWR1bGVkVHJhbnNhY3Rpb24pXG5cbiAgICAgIC8vIFNlbmQgdHJhbnNhY3Rpb24gaW1tZWRpYXRlbHlcbiAgICAgIGNvbnNvbGUubG9nKCdTZW5kaW5nIGNvbnRyYWN0IGNhbGwgdHJhbnNhY3Rpb24gaW1tZWRpYXRlbHkuLi4nKVxuICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihzaWduZWRUeC5zZXJpYWxpemUoKSlcblxuICAgICAgLy8gV2FpdCBmb3IgdHJhbnNhY3Rpb24gZXhlY3V0aW9uIG9uIE5lb24gRVZNXG4gICAgICBjb25zdCB0cmFuc2FjdGlvblN0YXR1cyA9IGF3YWl0IHRoaXMucHJveHlBcGkud2FpdFRyYW5zYWN0aW9uVHJlZUV4ZWN1dGlvbihcbiAgICAgICAgdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsXG4gICAgICAgIG5vbmNlLFxuICAgICAgICA2MDAwMFxuICAgICAgKVxuXG4gICAgICBpZiAodHJhbnNhY3Rpb25TdGF0dXMubGVuZ3RoID09PSAwIHx8IHRyYW5zYWN0aW9uU3RhdHVzWzBdLnN0YXR1cyAhPT0gJ1N1Y2Nlc3MnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ29udHJhY3QgcGF5bWVudCByZWNvcmRpbmcgZmFpbGVkLCBidXQgU09MIHRyYW5zZmVyIHN1Y2NlZWRlZCcpXG4gICAgICAgIGNvbnNvbGUubG9nKCdUcmFuc2ZlciBzaWduYXR1cmU6JywgdHJhbnNmZXJTaWduYXR1cmUpXG4gICAgICAgIC8vIERvbid0IHRocm93IGVycm9yIC0gdGhlIHBheW1lbnQgd2VudCB0aHJvdWdoIGV2ZW4gaWYgcmVjb3JkaW5nIGZhaWxlZFxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnUGF5bWVudCBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5IScpXG4gICAgICBjb25zb2xlLmxvZygnU09MIHRyYW5zZmVyOicsIHRyYW5zZmVyU2lnbmF0dXJlKVxuICAgICAgY29uc29sZS5sb2coJ0NvbnRyYWN0IHJlY29yZDonLCB0cmFuc2FjdGlvblN0YXR1c1swXT8udHJhbnNhY3Rpb25IYXNoKVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eEhhc2g6IHRyYW5zYWN0aW9uU3RhdHVzWzBdPy50cmFuc2FjdGlvbkhhc2ggfHwgJ2NvbnRyYWN0LXJlY29yZGluZy1mYWlsZWQnLFxuICAgICAgICB0cmFuc2ZlclNpZ25hdHVyZVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBheWluZyBsaW5rOicsIGVycm9yKVxuICAgICAgaWYgKHRyYW5zZmVyU2lnbmF0dXJlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdOb3RlOiBTT0wgdHJhbnNmZXIgbWF5IGhhdmUgc3VjY2VlZGVkOicsIHRyYW5zZmVyU2lnbmF0dXJlKVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVhY3RpdmF0ZSBhIHBheW1lbnQgbGlua1xuICAgKi9cbiAgYXN5bmMgZGVhY3RpdmF0ZUxpbmsobGlua0lkOiBzdHJpbmcpOiBQcm9taXNlPHsgdHhIYXNoOiBzdHJpbmcgfT4ge1xuICAgIGlmICghdGhpcy5zb2xhbmFVc2VyIHx8ICF0aGlzLmNvbnRyYWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBjb25uZWN0IHdhbGxldCBmaXJzdCcpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBjdXJyZW50IG5vbmNlXG4gICAgICBjb25zdCBub25jZSA9IE51bWJlcihhd2FpdCB0aGlzLnByb3h5QXBpLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQpKVxuICAgICAgY29uc29sZS5sb2coJ0N1cnJlbnQgbm9uY2U6Jywgbm9uY2UpXG5cbiAgICAgIC8vIFByZXBhcmUgY29udHJhY3QgY2FsbCBkYXRhXG4gICAgICBjb25zdCBpZmFjZSA9IG5ldyBldGhlcnMuSW50ZXJmYWNlKFNPTEFOQV9USVBDQVJEX0FCSSlcbiAgICAgIGNvbnN0IGRhdGEgPSBpZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoJ2RlYWN0aXZhdGVTb2xhbmFMaW5rJywgW2xpbmtJZF0pXG5cbiAgICAgIC8vIENyZWF0ZSB0cmFuc2FjdGlvbiBkYXRhXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkRhdGEgPSB7XG4gICAgICAgIGZyb206IHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0LFxuICAgICAgICB0bzogQ09OVFJBQ1RfQUREUkVTUyxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfVxuXG4gICAgICAvLyBFc3RpbWF0ZSBnYXNcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uR2FzID0gYXdhaXQgdGhpcy5wcm94eUFwaS5lc3RpbWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uR2FzKHtcbiAgICAgICAgc29sYW5hUGF5ZXI6IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXksXG4gICAgICAgIHRyYW5zYWN0aW9uczogW3RyYW5zYWN0aW9uRGF0YV0sXG4gICAgICB9KVxuXG4gICAgICAvLyBDcmVhdGUgc2NoZWR1bGVkIHRyYW5zYWN0aW9uXG4gICAgICBsZXQgeyBzY2hlZHVsZWRUcmFuc2FjdGlvbiB9ID0gYXdhaXQgdGhpcy5wcm94eUFwaS5jcmVhdGVTY2hlZHVsZWRUcmFuc2FjdGlvbih7XG4gICAgICAgIHRyYW5zYWN0aW9uR2FzLFxuICAgICAgICB0cmFuc2FjdGlvbkRhdGEsXG4gICAgICAgIG5vbmNlXG4gICAgICB9KVxuXG4gICAgICAvLyBHZXQgZnJlc2ggcmVjZW50IGJsb2NraGFzaCByaWdodCBiZWZvcmUgc2lnbmluZ1xuICAgICAgY29uc29sZS5sb2coJ0dldHRpbmcgZnJlc2ggYmxvY2toYXNoIGZvciBkZWFjdGl2YXRlIHRyYW5zYWN0aW9uLi4uJylcbiAgICAgIGNvbnN0IHsgYmxvY2toYXNoLCBsYXN0VmFsaWRCbG9ja0hlaWdodDogZGVhY3RpdmF0ZUJsb2NrSGVpZ2h0IH0gPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCdjb25maXJtZWQnKVxuICAgICAgY29uc29sZS5sb2coJ0ZyZXNoIGRlYWN0aXZhdGUgYmxvY2toYXNoOicsIGJsb2NraGFzaClcbiAgICAgIGNvbnNvbGUubG9nKCdMYXN0IHZhbGlkIGJsb2NrIGhlaWdodDonLCBkZWFjdGl2YXRlQmxvY2tIZWlnaHQpXG5cbiAgICAgIHNjaGVkdWxlZFRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGJsb2NraGFzaFxuICAgICAgc2NoZWR1bGVkVHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5XG5cbiAgICAgIC8vIFNpZ24gd2l0aCB3YWxsZXQgYWRhcHRlciAoZnJvbnRlbmQgYXBwcm9hY2gpXG4gICAgICBjb25zb2xlLmxvZygnU2lnbmluZyBkZWFjdGl2YXRlIHRyYW5zYWN0aW9uIHdpdGggZnJlc2ggYmxvY2toYXNoLi4uJylcbiAgICAgIGNvbnN0IHNpZ25lZFR4ID0gYXdhaXQgdGhpcy5zb2xhbmFVc2VyLndhbGxldEFkYXB0ZXIuc2lnblRyYW5zYWN0aW9uKHNjaGVkdWxlZFRyYW5zYWN0aW9uKVxuXG4gICAgICAvLyBTZW5kIHRyYW5zYWN0aW9uIGltbWVkaWF0ZWx5XG4gICAgICBjb25zb2xlLmxvZygnU2VuZGluZyBkZWFjdGl2YXRlIHRyYW5zYWN0aW9uIGltbWVkaWF0ZWx5Li4uJylcbiAgICAgIGF3YWl0IHRoaXMuY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24oc2lnbmVkVHguc2VyaWFsaXplKCkpXG5cbiAgICAgIC8vIFdhaXQgZm9yIHRyYW5zYWN0aW9uIGV4ZWN1dGlvblxuICAgICAgY29uc3QgdHJhbnNhY3Rpb25TdGF0dXMgPSBhd2FpdCB0aGlzLnByb3h5QXBpLndhaXRUcmFuc2FjdGlvblRyZWVFeGVjdXRpb24oXG4gICAgICAgIHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0LFxuICAgICAgICBub25jZSxcbiAgICAgICAgNjAwMDBcbiAgICAgIClcblxuICAgICAgaWYgKHRyYW5zYWN0aW9uU3RhdHVzLmxlbmd0aCA9PT0gMCB8fCB0cmFuc2FjdGlvblN0YXR1c1swXS5zdGF0dXMgIT09ICdTdWNjZXNzJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlYWN0aXZhdGlvbiB0cmFuc2FjdGlvbiBmYWlsZWQgdG8gZXhlY3V0ZSBvbiBOZW9uIEVWTScpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR4SGFzaDogdHJhbnNhY3Rpb25TdGF0dXNbMF0udHJhbnNhY3Rpb25IYXNoXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgc2hhcmVhYmxlIFVSTCBmb3IgYSBwYXltZW50IGxpbmtcbiAgICovXG4gIGNyZWF0ZVBheW1lbnRVUkwobGlua0lkOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt3aW5kb3cubG9jYXRpb24ub3JpZ2lufT9wYXk9JHtsaW5rSWR9YFxuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgbGluayBJRCBmcm9tIFVSTFxuICAgKi9cbiAgc3RhdGljIGV4dHJhY3RMaW5rSWRGcm9tVVJMKHVybDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodXJsKVxuICAgICAgcmV0dXJuIHVybE9iai5zZWFyY2hQYXJhbXMuZ2V0KCdwYXknKVxuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB1c2VyJ3MgRVZNIGFkZHJlc3MgZGVyaXZlZCBmcm9tIFNvbGFuYSBwdWJsaWMga2V5XG4gICAqL1xuICBnZXRVc2VyRVZNQWRkcmVzcygpOiBzdHJpbmcgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5zb2xhbmFVc2VyPy5uZW9uV2FsbGV0IHx8IG51bGxcbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3Qgc29sYW5hTmF0aXZlQ29udHJhY3QgPSBuZXcgU29sYW5hTmF0aXZlQ29udHJhY3QoKSJdLCJuYW1lcyI6WyJDb25uZWN0aW9uIiwiTmVvblByb3h5UnBjQXBpIiwiY3JlYXRlQmFsYW5jZUFjY291bnRJbnN0cnVjdGlvbiIsImV0aGVycyIsImhleGxpZnkiLCJ6ZXJvUGFkVmFsdWUiLCJDb250cmFjdEFCSSIsIlNPTEFOQV9USVBDQVJEX0FCSSIsIkNPTlRSQUNUX0FERFJFU1MiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfVElQQ0FSRF9DT05UUkFDVF9BRERSRVNTIiwiTkVPTl9DT1JFX1JQQ19VUkwiLCJORVhUX1BVQkxJQ19ORU9OX1JQQ19VUkwiLCJORU9OX1BST1hZX1JQQ19VUkwiLCJTT0xBTkFfUlBDX1VSTCIsIlNvbGFuYU5hdGl2ZUNvbnRyYWN0IiwiaW5pdFdpdGhTb2xhbmFXYWxsZXQiLCJ3YWxsZXRBZGFwdGVyIiwicHVibGljS2V5IiwiRXJyb3IiLCJjb25zb2xlIiwibG9nIiwidG9CYXNlNTgiLCJwcm92aWRlciIsImNoYWluSWQiLCJzb2xhbmFVc2VyIiwidG9rZW5NaW50QWRkcmVzcyIsInByb2dyYW1BZGRyZXNzIiwicHJveHlBcGkiLCJpbml0IiwiYmFsYW5jZUFkZHJlc3MiLCJTb2xhbmFOZW9uQWNjb3VudCIsImFjY291bnQiLCJuZW9uRXZtUHJvZ3JhbSIsInRva2VuTWludCIsImVycm9yIiwicmVhZE9ubHlQcm92aWRlciIsIkpzb25ScGNQcm92aWRlciIsImNvbnRyYWN0IiwiQ29udHJhY3QiLCJ0eENvdW50IiwiZ2V0VHJhbnNhY3Rpb25Db3VudCIsIm5lb25XYWxsZXQiLCJ2ZXJpZnlFcnJvciIsImNvZGUiLCJnZXRDb2RlIiwid2FybiIsImNyZWF0ZVBheW1lbnRMaW5rIiwic3VnZ2VzdGVkQW1vdW50U09MIiwiaXNGbGV4aWJsZSIsImRlc2NyaXB0aW9uIiwiYW1vdW50TGFtcG9ydHMiLCJwYXJzZVVuaXRzIiwidG9TdHJpbmciLCJzaWduYXR1cmUiLCJub25jZSIsIk51bWJlciIsImlmYWNlIiwiSW50ZXJmYWNlIiwiZGF0YSIsImVuY29kZUZ1bmN0aW9uRGF0YSIsInRyYW5zYWN0aW9uRGF0YSIsImZyb20iLCJ0byIsInRyYW5zYWN0aW9uR2FzIiwiZXN0aW1hdGVTY2hlZHVsZWRUcmFuc2FjdGlvbkdhcyIsInNvbGFuYVBheWVyIiwidHJhbnNhY3Rpb25zIiwic2NoZWR1bGVkVHJhbnNhY3Rpb24iLCJjcmVhdGVTY2hlZHVsZWRUcmFuc2FjdGlvbiIsImNvbm5lY3Rpb24iLCJnZXRBY2NvdW50SW5mbyIsImluc3RydWN0aW9ucyIsInVuc2hpZnQiLCJibG9ja2hhc2giLCJnZXRMYXRlc3RCbG9ja2hhc2giLCJyZWNlbnRCbG9ja2hhc2giLCJmZWVQYXllciIsInNpZ25lZFRyYW5zYWN0aW9uIiwic2lnblRyYW5zYWN0aW9uIiwic2VuZFJhd1RyYW5zYWN0aW9uIiwic2VyaWFsaXplIiwiY29uZmlybVRyYW5zYWN0aW9uIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwibmVvblR4UmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInBhcmFtcyIsImlkIiwianNvbnJwYyIsIm5lb25UeFJlc3VsdCIsImpzb24iLCJyZXN1bHQiLCJoYXNoIiwibmVvblR4SGFzaCIsImFjdHVhbExpbmtJZCIsImF0dGVtcHQiLCJyZWNlaXB0UmVzcG9uc2UiLCJyZWNlaXB0UmVzdWx0IiwibG9ncyIsImxlbmd0aCIsImRlY29kZWQiLCJwYXJzZUxvZyIsIm5hbWUiLCJhcmdzIiwibGlua0lkIiwiZXZtQ3JlYXRvciIsImZvcm1hdFVuaXRzIiwiYW1vdW50IiwidHhIYXNoIiwicGFyc2VFcnJvciIsInJlY2VpcHRFcnJvciIsIm1lc3NhZ2UiLCJuZW9uRXJyb3IiLCJjb25maXJtRXJyb3IiLCJjYXRjaCIsImluaXRSZWFkT25seUNvbnRyYWN0IiwiZ2V0UGF5bWVudExpbmsiLCJnZXRTb2xhbmFQYXltZW50TGluayIsInBheW1lbnRMaW5rIiwic29sYW5hQ3JlYXRvciIsImlzQWN0aXZlIiwidG90YWxSZWNlaXZlZCIsInBheW1lbnRDb3VudCIsIkJpZ0ludCIsInN0YXJ0c1dpdGgiLCJnZXRVc2VyTGlua3MiLCJ1c2VyRVZNQWRkcmVzcyIsImdldFVzZXJTb2xhbmFMaW5rcyIsInBheUxpbmsiLCJhbW91bnRTT0wiLCJsaW5rRGF0YSIsIk1hdGgiLCJmbG9vciIsInRyYW5zZmVyU2lnbmF0dXJlIiwiaGV4U3RyaW5nIiwidHJhbnNhY3Rpb25TdGF0dXMiLCJzbGljZSIsImJ5dGVzIiwiVWludDhBcnJheSIsIm1hdGNoIiwibWFwIiwiYnl0ZSIsInBhcnNlSW50IiwicmVjaXBpZW50UHVia2V5IiwiUHVibGljS2V5IiwibGFzdDMyQnl0ZXMiLCJwYWRkZWRCeXRlcyIsInNldCIsIlN5c3RlbVByb2dyYW0iLCJUcmFuc2FjdGlvbiIsInRyYW5zZmVySXgiLCJ0cmFuc2ZlciIsImZyb21QdWJrZXkiLCJ0b1B1YmtleSIsImxhbXBvcnRzIiwidHJhbnNmZXJUeCIsImFkZCIsImxhc3RWYWxpZEJsb2NrSGVpZ2h0IiwidHJhbnNmZXJCbG9ja0hlaWdodCIsInNpZ25lZFRyYW5zZmVyVHgiLCJwYXllclNvbGFuYUJ5dGVzMzIiLCJ0b0J5dGVzIiwiY29udHJhY3RCbG9ja2hhc2giLCJjb250cmFjdEJsb2NrSGVpZ2h0Iiwic2lnbmVkVHgiLCJ3YWl0VHJhbnNhY3Rpb25UcmVlRXhlY3V0aW9uIiwic3RhdHVzIiwidHJhbnNhY3Rpb25IYXNoIiwiZGVhY3RpdmF0ZUxpbmsiLCJkZWFjdGl2YXRlQmxvY2tIZWlnaHQiLCJjcmVhdGVQYXltZW50VVJMIiwid2luZG93IiwibG9jYXRpb24iLCJvcmlnaW4iLCJleHRyYWN0TGlua0lkRnJvbVVSTCIsInVybCIsInVybE9iaiIsIlVSTCIsInNlYXJjaFBhcmFtcyIsImdldCIsImdldFVzZXJFVk1BZGRyZXNzIiwiY29uc3RydWN0b3IiLCJzb2xhbmFOYXRpdmVDb250cmFjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/solana-native-contract.ts\n"));

/***/ })

});