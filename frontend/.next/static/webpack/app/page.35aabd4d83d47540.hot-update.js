"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/solana-native-contract.ts":
/*!*****************************************!*\
  !*** ./utils/solana-native-contract.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaNativeContract: function() { return /* binding */ SolanaNativeContract; },\n/* harmony export */   solanaNativeContract: function() { return /* binding */ solanaNativeContract; }\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var _neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @neonevm/solana-sign */ \"(app-pages-browser)/./node_modules/@neonevm/solana-sign/dist/esm/index.mjs\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _contractABI_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contractABI.json */ \"(app-pages-browser)/./utils/contractABI.json\");\n\n\n\n\n// Use the actual deployed contract ABI\nconst SOLANA_TIPCARD_ABI = _contractABI_json__WEBPACK_IMPORTED_MODULE_2__;\nconst CONTRACT_ADDRESS = \"0xCFE03c7c67456D094C0162F9030393FC2cCc40Cb\" || 0;\nconst NEON_CORE_RPC_URL = \"https://devnet.neonevm.org\" || 0;\nconst NEON_PROXY_RPC_URL = \"\".concat(NEON_CORE_RPC_URL, \"/sol\");\nconst SOLANA_RPC_URL = \"https://api.devnet.solana.com\";\nclass SolanaNativeContract {\n    /**\n   * Get Neon EVM chain ID\n   */ async getChainId() {\n        try {\n            // Use the proxy API to get chain information\n            const response = await fetch(NEON_PROXY_RPC_URL, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    id: 1,\n                    jsonrpc: \"2.0\",\n                    method: \"eth_chainId\",\n                    params: []\n                })\n            });\n            const result = await response.json();\n            return parseInt(result.result, 16) // Convert hex to decimal\n            ;\n        } catch (error) {\n            console.warn(\"Could not get chain ID, using default:\", error);\n            return 245022927 // Neon Devnet default\n            ;\n        }\n    }\n    /**\n   * Get Neon EVM program address using a temporary initialization\n   */ async getNeonEvmProgram() {\n        try {\n            var _initResult_solanaUser;\n            console.log(\"Attempting to get Neon EVM program via temporary keypair initialization...\");\n            // Create a temporary keypair just to get the program information\n            const { Keypair } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"));\n            const tempKeypair = Keypair.generate();\n            // Use the existing proxyApi to get the information\n            const initResult = await this.proxyApi.init(tempKeypair);\n            console.log(\"Temporary init result:\", initResult);\n            if ((_initResult_solanaUser = initResult.solanaUser) === null || _initResult_solanaUser === void 0 ? void 0 : _initResult_solanaUser.neonEvmProgram) {\n                return initResult.solanaUser.neonEvmProgram;\n            } else {\n                throw new Error(\"No neonEvmProgram in init result\");\n            }\n        } catch (error) {\n            console.warn(\"Temporary init failed, trying direct API call:\", error);\n            try {\n                var _result_result, _result_result1;\n                // Fallback to direct API call\n                const response = await fetch(NEON_PROXY_RPC_URL, {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        id: 1,\n                        jsonrpc: \"2.0\",\n                        method: \"neon_getEvmParams\",\n                        params: []\n                    })\n                });\n                const result = await response.json();\n                console.log(\"Direct API response:\", result);\n                // Check different possible response structures\n                let programAddress;\n                if ((_result_result = result.result) === null || _result_result === void 0 ? void 0 : _result_result.neonEvmProgram) {\n                    programAddress = result.result.neonEvmProgram;\n                } else if ((_result_result1 = result.result) === null || _result_result1 === void 0 ? void 0 : _result_result1.programId) {\n                    programAddress = result.result.programId;\n                } else if (result.result && typeof result.result === \"string\") {\n                    programAddress = result.result;\n                } else {\n                    throw new Error(\"Unexpected response structure\");\n                }\n                console.log(\"Extracted program address:\", programAddress);\n                return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(programAddress);\n            } catch (apiError) {\n                console.warn(\"Direct API call also failed, using default:\", apiError);\n                // Default Neon EVM program for devnet\n                return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(\"eeLSJgWzzxrqKv1UxtRVVH8FX3qCQWUs9QuAjJpETGSm\");\n            }\n        }\n    }\n    /**\n   * Initialize with Solana wallet using the exact same pattern as tests\n   */ async initWithSolanaWallet(walletAdapter) {\n        if (!walletAdapter.publicKey) {\n            throw new Error(\"Wallet not connected\");\n        }\n        try {\n            console.log(\"\\uD83D\\uDD27 Using exact test pattern with wallet adapter...\");\n            console.log(\"Wallet public key:\", walletAdapter.publicKey.toBase58());\n            // Create a temporary keypair for initialization, then override with wallet's public key\n            const { Keypair } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"));\n            const tempKeypair = Keypair.generate();\n            // Use the exact same initialization pattern as the test (with temp keypair)\n            console.log(\"Initializing with proxy API (same as test pattern)...\");\n            const { chainId, solanaUser: tempResult } = await this.proxyApi.init(tempKeypair);\n            // Recalculate the EVM address using the wallet's actual public key\n            // The EVM address should be derived from the wallet's public key, not the temp keypair\n            console.log(\"Recalculating EVM address for wallet public key...\");\n            const actualSolanaNeonAccount = new _neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__.SolanaNeonAccount(walletAdapter.publicKey, tempResult.neonEvmProgram, tempResult.tokenMint, chainId // Keep the same chain ID\n            );\n            // Now create the proper solanaUser object using wallet's public key\n            // but keeping all the other derived values from the temp initialization\n            const walletSolanaUser = {\n                ...tempResult,\n                publicKey: walletAdapter.publicKey,\n                neonWallet: actualSolanaNeonAccount.neonWallet,\n                balanceAddress: actualSolanaNeonAccount.balanceAddress,\n                chainId,\n                walletAdapter: walletAdapter // Add wallet adapter for signing\n            };\n            // Store the result in the same structure as tests\n            this.chainId = chainId;\n            this.solanaUser = walletSolanaUser;\n            console.log(\"✅ Wallet initialized using test pattern!\");\n            console.log(\"\\uD83D\\uDCCD Derived EVM address:\", this.solanaUser.neonWallet);\n            console.log(\"\\uD83D\\uDCB0 Balance address:\", this.solanaUser.balanceAddress.toBase58());\n            console.log(\"Neon SDK initialized with wallet adapter (using SolanaNeonAccount)\");\n            console.log(\"Chain ID:\", this.chainId);\n            console.log(\"Solana User Public Key:\", this.solanaUser.publicKey.toBase58());\n            console.log(\"Solana User Neon Wallet:\", this.solanaUser.neonWallet);\n            console.log(\"Solana User Balance Address:\", this.solanaUser.balanceAddress.toBase58());\n            // Create contract instance\n            const readOnlyProvider = new ethers__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider(NEON_CORE_RPC_URL);\n            this.contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.Contract(CONTRACT_ADDRESS, SOLANA_TIPCARD_ABI, readOnlyProvider);\n            // Verify the derived EVM address is valid\n            console.log(\"\\uD83D\\uDD0D Verifying derived EVM address...\");\n            try {\n                // Check if this EVM address has been used before (has transaction history)\n                const txCount = await readOnlyProvider.getTransactionCount(this.solanaUser.neonWallet);\n                console.log(\"\\uD83D\\uDCCA EVM address transaction count:\", txCount);\n                if (txCount > 0) {\n                    console.log(\"✅ This EVM address has transaction history - it exists on-chain!\");\n                } else {\n                    console.log(\"ℹ️ This EVM address is new (no transaction history yet)\");\n                    console.log(\"ℹ️ The address will be registered on-chain when first transaction is made\");\n                }\n            } catch (verifyError) {\n                console.log(\"⚠️ Could not verify EVM address:\", verifyError);\n            }\n            // Verify contract is deployed at this address\n            try {\n                console.log(\"Verifying contract at address:\", CONTRACT_ADDRESS);\n                const code = await readOnlyProvider.getCode(CONTRACT_ADDRESS);\n                console.log(\"Contract code length:\", code.length);\n                if (code === \"0x\") {\n                    console.warn(\"⚠️ No contract code found at address:\", CONTRACT_ADDRESS);\n                    console.log(\"This might mean the contract is not deployed or address is incorrect\");\n                } else {\n                    console.log(\"✅ Contract found at address\");\n                    console.log(\"✅ Contract found and ready for transactions\");\n                }\n            } catch (verifyError) {\n                console.warn(\"Failed to verify contract:\", verifyError);\n            }\n        } catch (error) {\n            console.error(\"Failed to initialize Solana Native SDK:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Create a payment link using Solana Native SDK\n   */ async createPaymentLink(suggestedAmountSOL, isFlexible, description) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        // Convert SOL to lamports (1 SOL = 1e9 lamports)\n        const amountLamports = Math.floor(suggestedAmountSOL * 1e9);\n        try {\n            var _receipt_result, _receipt_result1, _receipt_result2, _receipt_result_logs, _receipt_result3, _receipt_result4, _receipt_result5, _receipt_result6, _receipt_result7, _receipt_result8, _receipt_result9;\n            // Get current nonce (exactly like working examples)\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Current nonce:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"createSolanaPaymentLink\", [\n                amountLamports,\n                isFlexible,\n                description\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Check if balance account exists, if not create it\n            const account = await this.connection.getAccountInfo(this.solanaUser.balanceAddress);\n            if (account === null) {\n                scheduledTransaction.instructions.unshift((0,_neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__.createBalanceAccountInstruction)(this.solanaUser.neonEvmProgram, this.solanaUser.publicKey, this.solanaUser.neonWallet, this.chainId));\n            }\n            // Sign and send transaction (exactly like working examples)\n            const { blockhash } = await this.connection.getLatestBlockhash();\n            scheduledTransaction.recentBlockhash = blockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            console.log(\"Signing with wallet adapter...\");\n            // Sign transaction using wallet adapter instead of keypair (like in tests)\n            // In tests: scheduledTransaction.sign({ publicKey: solanaUser.publicKey, secretKey: solanaUser.keypair.secretKey })\n            // In frontend: use wallet adapter signing\n            const signedTx = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            console.log(\"Submitting transaction...\");\n            const signature = await this.connection.sendRawTransaction(signedTx.serialize());\n            console.log(\"✅ Transaction submitted!\");\n            console.log(\"\\uD83D\\uDD17 Signature:\", signature);\n            // Wait a bit for processing (like working examples)\n            console.log(\"Waiting for confirmation...\");\n            await new Promise((resolve)=>setTimeout(resolve, 5000));\n            // Wait for transaction execution on Neon EVM\n            const transactionStatus = await this.proxyApi.waitTransactionTreeExecution(this.solanaUser.neonWallet, nonce, 60000 // 60 second timeout\n            );\n            console.log(\"Transaction status:\", transactionStatus);\n            if (transactionStatus.length === 0) {\n                throw new Error(\"No transaction status returned - transaction may not have been processed\");\n            }\n            const txStatus = transactionStatus[0];\n            console.log(\"Transaction execution status:\", txStatus.status);\n            if (txStatus.status === \"NotStarted\") {\n                console.warn(\"⚠️ Transaction was scheduled but not yet executed by Neon operators\");\n                console.log(\"This is expected - Neon will process it eventually\");\n                console.log(\"Transaction hash:\", txStatus.transactionHash);\n                // Since we have a transaction hash, proceed with using it as the payment link ID\n                // The transaction will be processed by Neon operators eventually\n                console.log(\"✅ Using transaction hash as payment link ID - Neon will process it when ready\");\n                return {\n                    linkId: txStatus.transactionHash,\n                    txHash: txStatus.transactionHash\n                };\n            } else if (txStatus.status === \"Failed\") {\n                throw new Error(\"Transaction execution failed. Hash: \".concat(txStatus.transactionHash));\n            } else if (txStatus.status !== \"Success\") {\n                console.warn(\"Transaction finished with unexpected status:\", txStatus.status);\n                // Still try to return the transaction hash in case it's usable\n                return {\n                    linkId: txStatus.transactionHash,\n                    txHash: txStatus.transactionHash\n                };\n            }\n            const txHash = transactionStatus[0].transactionHash;\n            console.log(\"Transaction hash:\", txHash);\n            // Get the link ID from transaction receipt\n            const receipt = await this.proxyApi.getTransactionReceipt(txHash);\n            console.log(\"Full transaction receipt:\", JSON.stringify(receipt, null, 2));\n            let linkId = \"\";\n            // Check if the transaction was successful\n            if (((_receipt_result = receipt.result) === null || _receipt_result === void 0 ? void 0 : _receipt_result.status) !== \"0x1\") {\n                var _receipt_result10;\n                throw new Error(\"Transaction failed - status: \" + ((_receipt_result10 = receipt.result) === null || _receipt_result10 === void 0 ? void 0 : _receipt_result10.status));\n            }\n            // Enhanced debugging of the receipt structure\n            console.log(\"Receipt status:\", (_receipt_result1 = receipt.result) === null || _receipt_result1 === void 0 ? void 0 : _receipt_result1.status);\n            console.log(\"Receipt logs array:\", (_receipt_result2 = receipt.result) === null || _receipt_result2 === void 0 ? void 0 : _receipt_result2.logs);\n            console.log(\"Receipt logs length:\", (_receipt_result3 = receipt.result) === null || _receipt_result3 === void 0 ? void 0 : (_receipt_result_logs = _receipt_result3.logs) === null || _receipt_result_logs === void 0 ? void 0 : _receipt_result_logs.length);\n            console.log(\"Receipt logsBloom:\", (_receipt_result4 = receipt.result) === null || _receipt_result4 === void 0 ? void 0 : _receipt_result4.logsBloom);\n            console.log(\"Receipt contractAddress:\", (_receipt_result5 = receipt.result) === null || _receipt_result5 === void 0 ? void 0 : _receipt_result5.contractAddress);\n            console.log(\"Receipt gasUsed:\", (_receipt_result6 = receipt.result) === null || _receipt_result6 === void 0 ? void 0 : _receipt_result6.gasUsed);\n            console.log(\"Receipt effectiveGasPrice:\", (_receipt_result7 = receipt.result) === null || _receipt_result7 === void 0 ? void 0 : _receipt_result7.effectiveGasPrice);\n            // Check if there's a different location for logs\n            console.log(\"Raw transaction data:\", (_receipt_result8 = receipt.result) === null || _receipt_result8 === void 0 ? void 0 : _receipt_result8.neonRawTransaction);\n            // Note: getTransaction method not available on NeonProxyRpcApi\n            // Transaction details are already in the receipt\n            // Extract all neonLogs from solanaTransactions\n            const allNeonLogs = [];\n            if ((_receipt_result9 = receipt.result) === null || _receipt_result9 === void 0 ? void 0 : _receipt_result9.solanaTransactions) {\n                for (const solTx of receipt.result.solanaTransactions){\n                    if (solTx.solanaInstructions) {\n                        for (const instruction of solTx.solanaInstructions){\n                            if (instruction.neonLogs && instruction.neonLogs.length > 0) {\n                                allNeonLogs.push(...instruction.neonLogs);\n                            }\n                        }\n                    }\n                }\n            }\n            console.log(\"Found\", allNeonLogs.length, \"neonLogs to parse\");\n            // Try to parse logs for the SolanaLinkCreated event\n            if (allNeonLogs.length > 0) {\n                for (const log of allNeonLogs){\n                    try {\n                        console.log(\"Trying to parse neonLog:\", log);\n                        // Check if this log is from our contract\n                        if (log.address.toLowerCase() === CONTRACT_ADDRESS.toLowerCase()) {\n                            console.log(\"Log is from our contract, parsing...\");\n                            // Convert the log to the format expected by ethers\n                            const ethersLog = {\n                                address: log.address,\n                                data: log.data,\n                                topics: log.topics\n                            };\n                            const parsedLog = iface.parseLog(ethersLog);\n                            console.log(\"Parsed log:\", parsedLog);\n                            if ((parsedLog === null || parsedLog === void 0 ? void 0 : parsedLog.name) === \"SolanaLinkCreated\") {\n                                linkId = parsedLog.args.linkId;\n                                console.log(\"✅ Found link ID from SolanaLinkCreated event:\", linkId);\n                                break;\n                            }\n                        } else {\n                            console.log(\"Log from different contract:\", log.address);\n                        }\n                    } catch (e) {\n                        console.log(\"Failed to parse neonLog:\", e);\n                    // Skip logs that can't be parsed\n                    }\n                }\n            } else {\n                console.warn(\"No neonLogs found in transaction receipt!\");\n                console.log(\"This might indicate:\");\n                console.log(\"1. The contract call failed silently\");\n                console.log(\"2. The contract is not at the expected address\");\n                console.log(\"3. The contract function call reverted\");\n                console.log(\"4. Events are not being emitted properly\");\n                // Try calling the contract read method to see if data was actually stored\n                try {\n                    console.log(\"Attempting to read payment link using transaction hash as ID...\");\n                    const testData = await this.contract.getSolanaPaymentLink(txHash);\n                    console.log(\"Contract read result:\", testData);\n                } catch (readError) {\n                    console.log(\"Contract read failed:\", readError);\n                }\n            }\n            // If we couldn't extract from logs, investigate further\n            if (!linkId) {\n                var _receipt_result11, _receipt_result12;\n                console.error(\"Could not extract link ID from transaction events!\");\n                console.log(\"This suggests the contract call may have failed silently\");\n                // Check if the transaction actually reverted\n                console.log(\"Checking for revert data...\");\n                if ((_receipt_result11 = receipt.result) === null || _receipt_result11 === void 0 ? void 0 : _receipt_result11.neonRevertData) {\n                    console.log(\"Revert data found:\", receipt.result.neonRevertData);\n                    try {\n                        // Try to decode the revert reason\n                        const revertReason = ethers__WEBPACK_IMPORTED_MODULE_6__.toUtf8String(receipt.result.neonRevertData);\n                        console.log(\"Revert reason:\", revertReason);\n                        throw new Error(\"Contract call reverted: \".concat(revertReason));\n                    } catch (decodeError) {\n                        console.log(\"Could not decode revert reason:\", decodeError);\n                        throw new Error(\"Contract call reverted with unknown reason\");\n                    }\n                }\n                // Let's try to understand why the event wasn't emitted\n                console.log(\"Analyzing function call...\");\n                console.log(\"Contract address:\", CONTRACT_ADDRESS);\n                console.log(\"From address:\", this.solanaUser.neonWallet);\n                console.log(\"Function data in raw tx:\", (_receipt_result12 = receipt.result) === null || _receipt_result12 === void 0 ? void 0 : _receipt_result12.neonRawTransaction);\n                // Check if user is registered\n                try {\n                    const isRegistered = await this.contract.isSolanaUser(this.solanaUser.neonWallet);\n                    console.log(\"Is user registered as Solana user:\", isRegistered);\n                    if (!isRegistered) {\n                        throw new Error(\"User is not registered as a Solana user with the contract. This is required to create payment links.\");\n                    }\n                } catch (registrationError) {\n                    console.error(\"Failed to check user registration:\", registrationError);\n                    throw registrationError;\n                }\n                // If we get here, something else went wrong\n                throw new Error(\"Payment link creation failed: Contract call executed but no event was emitted. The transaction may have failed silently.\");\n            }\n            return {\n                linkId,\n                txHash\n            };\n        } catch (error) {\n            console.error(\"Error creating payment link:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Initialize read-only contract access (without wallet)\n   */ async initReadOnlyContract() {\n        if (!this.contract) {\n            // Create a simple JSON RPC provider for read operations\n            const readOnlyProvider = new ethers__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider(NEON_CORE_RPC_URL);\n            this.contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.Contract(CONTRACT_ADDRESS, SOLANA_TIPCARD_ABI, readOnlyProvider);\n        }\n    }\n    /**\n   * Get payment link details\n   */ async getPaymentLink(linkId) {\n        // Initialize contract if not already done\n        if (!this.contract) {\n            await this.initReadOnlyContract();\n        }\n        console.log(\"Getting payment link with ID:\", linkId);\n        console.log(\"Contract address:\", CONTRACT_ADDRESS);\n        try {\n            const result = await this.contract.getSolanaPaymentLink(linkId);\n            console.log(\"Raw contract result:\", result);\n            const paymentLink = {\n                evmCreator: result.evmCreator,\n                solanaCreator: result.solanaCreator,\n                amount: result.amount,\n                isFlexible: result.isFlexible,\n                isActive: result.isActive,\n                totalReceived: result.totalReceived,\n                paymentCount: Number(result.paymentCount),\n                description: result.description\n            };\n            // Check if this looks like an empty/non-existent link (transaction not processed yet)\n            if (result.evmCreator === \"0x0000000000000000000000000000000000000000\" && result.amount === BigInt(0) && !result.isActive) {\n                console.warn(\"Payment link appears to be empty/non-existent\");\n                // If this looks like a transaction hash (66 chars, starts with 0x), provide helpful info\n                if (linkId.length === 66 && linkId.startsWith(\"0x\")) {\n                    console.log(\"\\uD83D\\uDCA1 This appears to be a transaction hash - the payment link may still be processing\");\n                    console.log(\"\\uD83D\\uDCA1 Neon operators will eventually process this transaction and create the payment link\");\n                    console.log(\"\\uD83D\\uDCA1 You can bookmark this link and try again in a few minutes\");\n                    // For now, don't throw an error - let the UI handle the empty data gracefully\n                    console.log(\"Returning empty payment link data - transaction may still be processing\");\n                }\n            }\n            return paymentLink;\n        } catch (error) {\n            console.error(\"Contract call error:\", error);\n            throw new Error(\"Payment link not found or contract error\");\n        }\n    }\n    /**\n   * Get user's payment links\n   */ async getUserLinks(userEVMAddress) {\n        // Initialize contract if not already done\n        if (!this.contract) {\n            await this.initReadOnlyContract();\n        }\n        try {\n            return await this.contract.getUserSolanaLinks(userEVMAddress);\n        } catch (error) {\n            console.error(\"Error getting user links:\", error);\n            return [];\n        }\n    }\n    /**\n   * Pay a payment link using Solana Native SDK\n   */ async payLink(linkId, amountSOL) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        console.log(\"Starting payment process...\");\n        console.log(\"Link ID:\", linkId);\n        console.log(\"Amount SOL:\", amountSOL);\n        // First, get the payment link details to find the recipient\n        const linkData = await this.getPaymentLink(linkId);\n        console.log(\"Payment link data:\", linkData);\n        if (!linkData.isActive) {\n            throw new Error(\"Payment link is no longer active\");\n        }\n        // Convert SOL to lamports\n        const amountLamports = Math.floor(amountSOL * 1e9);\n        let transferSignature;\n        try {\n            var _hexString_match, _transactionStatus_, _transactionStatus_1;\n            // Step 1: Perform the actual SOL transfer first\n            console.log(\"Step 1: Performing SOL transfer...\");\n            console.log(\"From:\", this.solanaUser.publicKey.toBase58());\n            console.log(\"To recipient bytes32:\", linkData.solanaCreator);\n            console.log(\"Amount lamports:\", amountLamports);\n            // Convert recipient Solana address from bytes32 to PublicKey\n            // Remove '0x' prefix if present\n            const hexString = linkData.solanaCreator.startsWith(\"0x\") ? linkData.solanaCreator.slice(2) : linkData.solanaCreator;\n            // Convert hex string to byte array\n            const bytes = new Uint8Array(((_hexString_match = hexString.match(/.{2}/g)) === null || _hexString_match === void 0 ? void 0 : _hexString_match.map((byte)=>parseInt(byte, 16))) || []);\n            // For bytes32 from Solana addresses, we need to find the actual 32-byte public key\n            // The bytes32 should contain the 32-byte Solana public key, possibly with leading zeros\n            let recipientPubkey;\n            if (bytes.length === 32) {\n                // Direct conversion from 32 bytes\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(bytes);\n            } else if (bytes.length > 32) {\n                // Take the last 32 bytes if it's longer\n                const last32Bytes = bytes.slice(-32);\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(last32Bytes);\n            } else {\n                // Pad with leading zeros if shorter\n                const paddedBytes = new Uint8Array(32);\n                paddedBytes.set(bytes, 32 - bytes.length);\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(paddedBytes);\n            }\n            console.log(\"Recipient PublicKey:\", recipientPubkey.toBase58());\n            // Create the SOL transfer transaction\n            const { SystemProgram, Transaction } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"));\n            // Create transfer instruction\n            const transferIx = SystemProgram.transfer({\n                fromPubkey: this.solanaUser.publicKey,\n                toPubkey: recipientPubkey,\n                lamports: amountLamports\n            });\n            // Create transaction\n            const transferTx = new Transaction().add(transferIx);\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for SOL transfer...\");\n            const { blockhash, lastValidBlockHeight: transferBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh SOL transfer blockhash:\", blockhash);\n            console.log(\"Last valid block height:\", transferBlockHeight);\n            transferTx.recentBlockhash = blockhash;\n            transferTx.feePayer = this.solanaUser.publicKey;\n            // Sign and send the SOL transfer immediately\n            console.log(\"Signing and sending SOL transfer with fresh blockhash...\");\n            const signedTransferTx = await this.solanaUser.walletAdapter.signTransaction(transferTx);\n            transferSignature = await this.connection.sendRawTransaction(signedTransferTx.serialize(), {\n                skipPreflight: false,\n                preflightCommitment: \"confirmed\"\n            });\n            console.log(\"SOL transfer sent:\", transferSignature);\n            // Wait for transfer confirmation using the modern API\n            await this.connection.confirmTransaction({\n                signature: transferSignature,\n                ...await this.connection.getLatestBlockhash()\n            });\n            console.log(\"SOL transfer confirmed\");\n            // Step 2: Record the payment in the contract\n            console.log(\"Step 2: Recording payment in contract...\");\n            // Convert Solana PublicKey to bytes32\n            const payerSolanaBytes32 = (0,ethers__WEBPACK_IMPORTED_MODULE_7__.zeroPadValue)((0,ethers__WEBPACK_IMPORTED_MODULE_7__.hexlify)(this.solanaUser.publicKey.toBytes()), 32);\n            // Get current nonce\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Current nonce:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"paySolanaLink\", [\n                linkId,\n                amountLamports,\n                payerSolanaBytes32\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for contract call...\");\n            const { blockhash: contractBlockhash, lastValidBlockHeight: contractBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh contract call blockhash:\", contractBlockhash);\n            console.log(\"Last valid block height:\", contractBlockHeight);\n            scheduledTransaction.recentBlockhash = contractBlockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            // Sign with wallet adapter instead of keypair (like in tests)\n            // In tests: scheduledTransaction.sign({ publicKey: solanaUser.publicKey, secretKey: solanaUser.keypair.secretKey })\n            // In frontend: use wallet adapter signing\n            console.log(\"Signing contract call with fresh blockhash...\");\n            const signedTx = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            // Send transaction immediately\n            console.log(\"Sending contract call transaction immediately...\");\n            await this.connection.sendRawTransaction(signedTx.serialize(), {\n                skipPreflight: false,\n                preflightCommitment: \"confirmed\"\n            });\n            // Wait for transaction execution on Neon EVM\n            const transactionStatus = await this.proxyApi.waitTransactionTreeExecution(this.solanaUser.neonWallet, nonce, 60000);\n            if (transactionStatus.length === 0 || transactionStatus[0].status !== \"Success\") {\n                console.warn(\"Contract payment recording failed, but SOL transfer succeeded\");\n                console.log(\"Transfer signature:\", transferSignature);\n            // Don't throw error - the payment went through even if recording failed\n            }\n            console.log(\"Payment completed successfully!\");\n            console.log(\"SOL transfer:\", transferSignature);\n            console.log(\"Contract record:\", (_transactionStatus_ = transactionStatus[0]) === null || _transactionStatus_ === void 0 ? void 0 : _transactionStatus_.transactionHash);\n            return {\n                txHash: ((_transactionStatus_1 = transactionStatus[0]) === null || _transactionStatus_1 === void 0 ? void 0 : _transactionStatus_1.transactionHash) || \"contract-recording-failed\",\n                transferSignature\n            };\n        } catch (error) {\n            console.error(\"Error paying link:\", error);\n            if (transferSignature) {\n                console.log(\"Note: SOL transfer may have succeeded:\", transferSignature);\n            }\n            throw error;\n        }\n    }\n    /**\n   * Deactivate a payment link\n   */ async deactivateLink(linkId) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        try {\n            // Get current nonce\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Current nonce:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"deactivateSolanaLink\", [\n                linkId\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for deactivate transaction...\");\n            const { blockhash, lastValidBlockHeight: deactivateBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh deactivate blockhash:\", blockhash);\n            console.log(\"Last valid block height:\", deactivateBlockHeight);\n            scheduledTransaction.recentBlockhash = blockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            // Sign with wallet adapter instead of keypair (like in tests)\n            // In tests: scheduledTransaction.sign({ publicKey: solanaUser.publicKey, secretKey: solanaUser.keypair.secretKey })\n            // In frontend: use wallet adapter signing\n            console.log(\"Signing deactivate transaction with fresh blockhash...\");\n            const signedTx = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            // Send transaction immediately\n            console.log(\"Sending deactivate transaction immediately...\");\n            await this.connection.sendRawTransaction(signedTx.serialize(), {\n                skipPreflight: false,\n                preflightCommitment: \"confirmed\"\n            });\n            // Wait for transaction execution\n            const transactionStatus = await this.proxyApi.waitTransactionTreeExecution(this.solanaUser.neonWallet, nonce, 60000);\n            if (transactionStatus.length === 0 || transactionStatus[0].status !== \"Success\") {\n                throw new Error(\"Deactivation transaction failed to execute on Neon EVM\");\n            }\n            return {\n                txHash: transactionStatus[0].transactionHash\n            };\n        } catch (error) {\n            throw error;\n        }\n    }\n    /**\n   * Create a shareable URL for a payment link\n   */ createPaymentURL(linkId) {\n        return \"\".concat(window.location.origin, \"?pay=\").concat(linkId);\n    }\n    /**\n   * Extract link ID from URL\n   */ static extractLinkIdFromURL(url) {\n        try {\n            const urlObj = new URL(url);\n            return urlObj.searchParams.get(\"pay\");\n        } catch (e) {\n            return null;\n        }\n    }\n    /**\n   * Get the user's EVM address derived from Solana public key\n   */ getUserEVMAddress() {\n        var _this_solanaUser;\n        return ((_this_solanaUser = this.solanaUser) === null || _this_solanaUser === void 0 ? void 0 : _this_solanaUser.neonWallet) || null;\n    }\n    constructor(){\n        this.chainId = null;\n        this.contract = null;\n        this.connection = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Connection(SOLANA_RPC_URL, \"confirmed\");\n        this.proxyApi = new _neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__.NeonProxyRpcApi(NEON_PROXY_RPC_URL);\n    }\n}\n// Export singleton instance\nconst solanaNativeContract = new SolanaNativeContract();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3NvbGFuYS1uYXRpdmUtY29udHJhY3QudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFnRTtBQUMwQztBQUNwRDtBQUNWO0FBRTVDLHVDQUF1QztBQUN2QyxNQUFNUyxxQkFBcUJELDhDQUFXQTtBQUV0QyxNQUFNRSxtQkFBbUJDLDRDQUFnRCxJQUFJO0FBQzdFLE1BQU1HLG9CQUFvQkgsNEJBQW9DLElBQUk7QUFDbEUsTUFBTUsscUJBQXFCLEdBQXFCLE9BQWxCRixtQkFBa0I7QUFDaEQsTUFBTUcsaUJBQWlCO0FBYWhCLE1BQU1DO0lBWVg7O0dBRUMsR0FDRCxNQUFjQyxhQUE4QjtRQUMxQyxJQUFJO1lBQ0YsNkNBQTZDO1lBQzdDLE1BQU1DLFdBQVcsTUFBTUMsTUFBTUwsb0JBQW9CO2dCQUMvQ00sUUFBUTtnQkFDUkMsU0FBUztvQkFBRSxnQkFBZ0I7Z0JBQW1CO2dCQUM5Q0MsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO29CQUNuQkMsSUFBSTtvQkFDSkMsU0FBUztvQkFDVE4sUUFBUTtvQkFDUk8sUUFBUSxFQUFFO2dCQUNaO1lBQ0Y7WUFDQSxNQUFNQyxTQUFTLE1BQU1WLFNBQVNXLElBQUk7WUFDbEMsT0FBT0MsU0FBU0YsT0FBT0EsTUFBTSxFQUFFLElBQUkseUJBQXlCOztRQUM5RCxFQUFFLE9BQU9HLE9BQU87WUFDZEMsUUFBUUMsSUFBSSxDQUFDLDBDQUEwQ0Y7WUFDdkQsT0FBTyxVQUFVLHNCQUFzQjs7UUFDekM7SUFDRjtJQUVBOztHQUVDLEdBQ0QsTUFBY0csb0JBQXdDO1FBQ3BELElBQUk7Z0JBV0VDO1lBVkpILFFBQVFJLEdBQUcsQ0FBQztZQUVaLGlFQUFpRTtZQUNqRSxNQUFNLEVBQUVDLE9BQU8sRUFBRSxHQUFHLE1BQU0sMExBQU87WUFDakMsTUFBTUMsY0FBY0QsUUFBUUUsUUFBUTtZQUVwQyxtREFBbUQ7WUFDbkQsTUFBTUosYUFBYSxNQUFNLElBQUksQ0FBQ0ssUUFBUSxDQUFD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RjtJQUVBOztHQUVDLEdBQ0RDLG9CQUFtQztZQUMxQjtRQUFQLE9BQU8seUJBQUksQ0FBQ3ZLLFVBQVUsY0FBZix3REFBaUJlLFVBQVUsS0FBSTtJQUN4QztJQXAwQkF5SixhQUFjO2FBSE45SixVQUF5QjthQUN6QlMsV0FBbUM7UUFHekMsSUFBSSxDQUFDZ0MsVUFBVSxHQUFHLElBQUkvRix1REFBVUEsQ0FBQ2lCLGdCQUFnQjtRQUNqRCxJQUFJLENBQUN5QixRQUFRLEdBQUcsSUFBSXhDLGlFQUFlQSxDQUFDYztJQUN0QztBQWswQkY7QUFFQSw0QkFBNEI7QUFDckIsTUFBTXFNLHVCQUF1QixJQUFJbk0sdUJBQXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3V0aWxzL3NvbGFuYS1uYXRpdmUtY29udHJhY3QudHM/ZDRjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb25uZWN0aW9uLCBQdWJsaWNLZXksIEtleXBhaXIgfSBmcm9tICdAc29sYW5hL3dlYjMuanMnXG5pbXBvcnQgeyBOZW9uUHJveHlScGNBcGksIGNyZWF0ZUJhbGFuY2VBY2NvdW50SW5zdHJ1Y3Rpb24sIFNvbGFuYU5lb25BY2NvdW50IH0gZnJvbSAnQG5lb25ldm0vc29sYW5hLXNpZ24nXG5pbXBvcnQgeyBldGhlcnMsIGhleGxpZnksIHplcm9QYWRWYWx1ZSB9IGZyb20gJ2V0aGVycydcbmltcG9ydCBDb250cmFjdEFCSSBmcm9tICcuL2NvbnRyYWN0QUJJLmpzb24nXG5cbi8vIFVzZSB0aGUgYWN0dWFsIGRlcGxveWVkIGNvbnRyYWN0IEFCSVxuY29uc3QgU09MQU5BX1RJUENBUkRfQUJJID0gQ29udHJhY3RBQklcblxuY29uc3QgQ09OVFJBQ1RfQUREUkVTUyA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1RJUENBUkRfQ09OVFJBQ1RfQUREUkVTUyB8fCAnMHhDRkUwM2M3YzY3NDU2RDA5NEMwMTYyRjkwMzAzOTNGQzJjQ2M0MENiJ1xuY29uc3QgTkVPTl9DT1JFX1JQQ19VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19ORU9OX1JQQ19VUkwgfHwgJ2h0dHBzOi8vZGV2bmV0Lm5lb25ldm0ub3JnJ1xuY29uc3QgTkVPTl9QUk9YWV9SUENfVVJMID0gYCR7TkVPTl9DT1JFX1JQQ19VUkx9L3NvbGBcbmNvbnN0IFNPTEFOQV9SUENfVVJMID0gJ2h0dHBzOi8vYXBpLmRldm5ldC5zb2xhbmEuY29tJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFBheW1lbnRMaW5rIHtcbiAgZXZtQ3JlYXRvcjogc3RyaW5nXG4gIHNvbGFuYUNyZWF0b3I6IHN0cmluZ1xuICBhbW91bnQ6IGJpZ2ludFxuICBpc0ZsZXhpYmxlOiBib29sZWFuXG4gIGlzQWN0aXZlOiBib29sZWFuXG4gIHRvdGFsUmVjZWl2ZWQ6IGJpZ2ludFxuICBwYXltZW50Q291bnQ6IG51bWJlclxuICBkZXNjcmlwdGlvbjogc3RyaW5nXG59XG5cbmV4cG9ydCBjbGFzcyBTb2xhbmFOYXRpdmVDb250cmFjdCB7XG4gIHByaXZhdGUgY29ubmVjdGlvbjogQ29ubmVjdGlvblxuICBwcml2YXRlIHByb3h5QXBpOiBOZW9uUHJveHlScGNBcGlcbiAgcHJpdmF0ZSBzb2xhbmFVc2VyOiBhbnlcbiAgcHJpdmF0ZSBjaGFpbklkOiBudW1iZXIgfCBudWxsID0gbnVsbFxuICBwcml2YXRlIGNvbnRyYWN0OiBldGhlcnMuQ29udHJhY3QgfCBudWxsID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldyBDb25uZWN0aW9uKFNPTEFOQV9SUENfVVJMLCAnY29uZmlybWVkJylcbiAgICB0aGlzLnByb3h5QXBpID0gbmV3IE5lb25Qcm94eVJwY0FwaShORU9OX1BST1hZX1JQQ19VUkwpXG4gIH1cblxuICAvKipcbiAgICogR2V0IE5lb24gRVZNIGNoYWluIElEXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGdldENoYWluSWQoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICB0cnkge1xuICAgICAgLy8gVXNlIHRoZSBwcm94eSBBUEkgdG8gZ2V0IGNoYWluIGluZm9ybWF0aW9uXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKE5FT05fUFJPWFlfUlBDX1VSTCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBpZDogMSxcbiAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICBtZXRob2Q6ICdldGhfY2hhaW5JZCcsXG4gICAgICAgICAgcGFyYW1zOiBbXVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgcmV0dXJuIHBhcnNlSW50KHJlc3VsdC5yZXN1bHQsIDE2KSAvLyBDb252ZXJ0IGhleCB0byBkZWNpbWFsXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGdldCBjaGFpbiBJRCwgdXNpbmcgZGVmYXVsdDonLCBlcnJvcilcbiAgICAgIHJldHVybiAyNDUwMjI5MjcgLy8gTmVvbiBEZXZuZXQgZGVmYXVsdFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgTmVvbiBFVk0gcHJvZ3JhbSBhZGRyZXNzIHVzaW5nIGEgdGVtcG9yYXJ5IGluaXRpYWxpemF0aW9uXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGdldE5lb25Fdm1Qcm9ncmFtKCk6IFByb21pc2U8UHVibGljS2V5PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIHRvIGdldCBOZW9uIEVWTSBwcm9ncmFtIHZpYSB0ZW1wb3Jhcnkga2V5cGFpciBpbml0aWFsaXphdGlvbi4uLicpXG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBrZXlwYWlyIGp1c3QgdG8gZ2V0IHRoZSBwcm9ncmFtIGluZm9ybWF0aW9uXG4gICAgICBjb25zdCB7IEtleXBhaXIgfSA9IGF3YWl0IGltcG9ydCgnQHNvbGFuYS93ZWIzLmpzJylcbiAgICAgIGNvbnN0IHRlbXBLZXlwYWlyID0gS2V5cGFpci5nZW5lcmF0ZSgpXG4gICAgICBcbiAgICAgIC8vIFVzZSB0aGUgZXhpc3RpbmcgcHJveHlBcGkgdG8gZ2V0IHRoZSBpbmZvcm1hdGlvblxuICAgICAgY29uc3QgaW5pdFJlc3VsdCA9IGF3YWl0IHRoaXMucHJveHlBcGkuaW5pdCh0ZW1wS2V5cGFpcilcbiAgICAgIGNvbnNvbGUubG9nKCdUZW1wb3JhcnkgaW5pdCByZXN1bHQ6JywgaW5pdFJlc3VsdClcbiAgICAgIFxuICAgICAgaWYgKGluaXRSZXN1bHQuc29sYW5hVXNlcj8ubmVvbkV2bVByb2dyYW0pIHtcbiAgICAgICAgcmV0dXJuIGluaXRSZXN1bHQuc29sYW5hVXNlci5uZW9uRXZtUHJvZ3JhbVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBuZW9uRXZtUHJvZ3JhbSBpbiBpbml0IHJlc3VsdCcpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignVGVtcG9yYXJ5IGluaXQgZmFpbGVkLCB0cnlpbmcgZGlyZWN0IEFQSSBjYWxsOicsIGVycm9yKVxuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICAvLyBGYWxsYmFjayB0byBkaXJlY3QgQVBJIGNhbGxcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChORU9OX1BST1hZX1JQQ19VUkwsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBpZDogMSxcbiAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgbWV0aG9kOiAnbmVvbl9nZXRFdm1QYXJhbXMnLFxuICAgICAgICAgICAgcGFyYW1zOiBbXVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coJ0RpcmVjdCBBUEkgcmVzcG9uc2U6JywgcmVzdWx0KVxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgZGlmZmVyZW50IHBvc3NpYmxlIHJlc3BvbnNlIHN0cnVjdHVyZXNcbiAgICAgICAgbGV0IHByb2dyYW1BZGRyZXNzXG4gICAgICAgIGlmIChyZXN1bHQucmVzdWx0Py5uZW9uRXZtUHJvZ3JhbSkge1xuICAgICAgICAgIHByb2dyYW1BZGRyZXNzID0gcmVzdWx0LnJlc3VsdC5uZW9uRXZtUHJvZ3JhbVxuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5yZXN1bHQ/LnByb2dyYW1JZCkge1xuICAgICAgICAgIHByb2dyYW1BZGRyZXNzID0gcmVzdWx0LnJlc3VsdC5wcm9ncmFtSWRcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQucmVzdWx0ICYmIHR5cGVvZiByZXN1bHQucmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHByb2dyYW1BZGRyZXNzID0gcmVzdWx0LnJlc3VsdFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCByZXNwb25zZSBzdHJ1Y3R1cmUnKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZygnRXh0cmFjdGVkIHByb2dyYW0gYWRkcmVzczonLCBwcm9ncmFtQWRkcmVzcylcbiAgICAgICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkocHJvZ3JhbUFkZHJlc3MpXG4gICAgICB9IGNhdGNoIChhcGlFcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RpcmVjdCBBUEkgY2FsbCBhbHNvIGZhaWxlZCwgdXNpbmcgZGVmYXVsdDonLCBhcGlFcnJvcilcbiAgICAgICAgLy8gRGVmYXVsdCBOZW9uIEVWTSBwcm9ncmFtIGZvciBkZXZuZXRcbiAgICAgICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkoJ2VlTFNKZ1d6enhycUt2MVV4dFJWVkg4RlgzcUNRV1VzOVF1QWpKcEVUR1NtJylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB3aXRoIFNvbGFuYSB3YWxsZXQgdXNpbmcgdGhlIGV4YWN0IHNhbWUgcGF0dGVybiBhcyB0ZXN0c1xuICAgKi9cbiAgYXN5bmMgaW5pdFdpdGhTb2xhbmFXYWxsZXQod2FsbGV0QWRhcHRlcjogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF3YWxsZXRBZGFwdGVyLnB1YmxpY0tleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGNvbm5lY3RlZCcpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SnIFVzaW5nIGV4YWN0IHRlc3QgcGF0dGVybiB3aXRoIHdhbGxldCBhZGFwdGVyLi4uJylcbiAgICAgIGNvbnNvbGUubG9nKCdXYWxsZXQgcHVibGljIGtleTonLCB3YWxsZXRBZGFwdGVyLnB1YmxpY0tleS50b0Jhc2U1OCgpKVxuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSB0ZW1wb3Jhcnkga2V5cGFpciBmb3IgaW5pdGlhbGl6YXRpb24sIHRoZW4gb3ZlcnJpZGUgd2l0aCB3YWxsZXQncyBwdWJsaWMga2V5XG4gICAgICBjb25zdCB7IEtleXBhaXIgfSA9IGF3YWl0IGltcG9ydCgnQHNvbGFuYS93ZWIzLmpzJylcbiAgICAgIGNvbnN0IHRlbXBLZXlwYWlyID0gS2V5cGFpci5nZW5lcmF0ZSgpXG4gICAgICBcbiAgICAgIC8vIFVzZSB0aGUgZXhhY3Qgc2FtZSBpbml0aWFsaXphdGlvbiBwYXR0ZXJuIGFzIHRoZSB0ZXN0ICh3aXRoIHRlbXAga2V5cGFpcilcbiAgICAgIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgd2l0aCBwcm94eSBBUEkgKHNhbWUgYXMgdGVzdCBwYXR0ZXJuKS4uLicpXG4gICAgICBjb25zdCB7IGNoYWluSWQsIHNvbGFuYVVzZXI6IHRlbXBSZXN1bHQgfSA9IGF3YWl0IHRoaXMucHJveHlBcGkuaW5pdCh0ZW1wS2V5cGFpcilcbiAgICAgIFxuICAgICAgLy8gUmVjYWxjdWxhdGUgdGhlIEVWTSBhZGRyZXNzIHVzaW5nIHRoZSB3YWxsZXQncyBhY3R1YWwgcHVibGljIGtleVxuICAgICAgLy8gVGhlIEVWTSBhZGRyZXNzIHNob3VsZCBiZSBkZXJpdmVkIGZyb20gdGhlIHdhbGxldCdzIHB1YmxpYyBrZXksIG5vdCB0aGUgdGVtcCBrZXlwYWlyXG4gICAgICBjb25zb2xlLmxvZygnUmVjYWxjdWxhdGluZyBFVk0gYWRkcmVzcyBmb3Igd2FsbGV0IHB1YmxpYyBrZXkuLi4nKVxuICAgICAgY29uc3QgYWN0dWFsU29sYW5hTmVvbkFjY291bnQgPSBuZXcgU29sYW5hTmVvbkFjY291bnQoXG4gICAgICAgIHdhbGxldEFkYXB0ZXIucHVibGljS2V5LCAgICAgICAgLy8gVXNlIHdhbGxldCdzIGFjdHVhbCBwdWJsaWMga2V5XG4gICAgICAgIHRlbXBSZXN1bHQubmVvbkV2bVByb2dyYW0sICAgICAgLy8gS2VlcCB0aGUgc2FtZSBOZW9uIEVWTSBwcm9ncmFtXG4gICAgICAgIHRlbXBSZXN1bHQudG9rZW5NaW50LCAgICAgICAgICAgLy8gVXNlIHRoZSB0b2tlbiBtaW50IGZyb20gdGVtcCByZXN1bHRcbiAgICAgICAgY2hhaW5JZCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIHRoZSBzYW1lIGNoYWluIElEXG4gICAgICApXG4gICAgICBcbiAgICAgIC8vIE5vdyBjcmVhdGUgdGhlIHByb3BlciBzb2xhbmFVc2VyIG9iamVjdCB1c2luZyB3YWxsZXQncyBwdWJsaWMga2V5XG4gICAgICAvLyBidXQga2VlcGluZyBhbGwgdGhlIG90aGVyIGRlcml2ZWQgdmFsdWVzIGZyb20gdGhlIHRlbXAgaW5pdGlhbGl6YXRpb25cbiAgICAgIGNvbnN0IHdhbGxldFNvbGFuYVVzZXIgPSB7XG4gICAgICAgIC4uLnRlbXBSZXN1bHQsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29weSBhbGwgcHJveHkgQVBJIHJlc3VsdHNcbiAgICAgICAgcHVibGljS2V5OiB3YWxsZXRBZGFwdGVyLnB1YmxpY0tleSwgICAgICAvLyBPdmVycmlkZSB3aXRoIHdhbGxldCdzIGFjdHVhbCBwdWJsaWMga2V5XG4gICAgICAgIG5lb25XYWxsZXQ6IGFjdHVhbFNvbGFuYU5lb25BY2NvdW50Lm5lb25XYWxsZXQsICAgICAvLyBVc2UgcmVjYWxjdWxhdGVkIEVWTSBhZGRyZXNzXG4gICAgICAgIGJhbGFuY2VBZGRyZXNzOiBhY3R1YWxTb2xhbmFOZW9uQWNjb3VudC5iYWxhbmNlQWRkcmVzcywgLy8gVXNlIHJlY2FsY3VsYXRlZCBiYWxhbmNlIGFkZHJlc3NcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgd2FsbGV0QWRhcHRlcjogd2FsbGV0QWRhcHRlciAgICAgICAgICAgICAvLyBBZGQgd2FsbGV0IGFkYXB0ZXIgZm9yIHNpZ25pbmdcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU3RvcmUgdGhlIHJlc3VsdCBpbiB0aGUgc2FtZSBzdHJ1Y3R1cmUgYXMgdGVzdHNcbiAgICAgIHRoaXMuY2hhaW5JZCA9IGNoYWluSWRcbiAgICAgIHRoaXMuc29sYW5hVXNlciA9IHdhbGxldFNvbGFuYVVzZXJcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ+KchSBXYWxsZXQgaW5pdGlhbGl6ZWQgdXNpbmcgdGVzdCBwYXR0ZXJuIScpXG4gICAgICBjb25zb2xlLmxvZygn8J+TjSBEZXJpdmVkIEVWTSBhZGRyZXNzOicsIHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0KVxuICAgICAgY29uc29sZS5sb2coJ/CfkrAgQmFsYW5jZSBhZGRyZXNzOicsIHRoaXMuc29sYW5hVXNlci5iYWxhbmNlQWRkcmVzcy50b0Jhc2U1OCgpKVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnTmVvbiBTREsgaW5pdGlhbGl6ZWQgd2l0aCB3YWxsZXQgYWRhcHRlciAodXNpbmcgU29sYW5hTmVvbkFjY291bnQpJylcbiAgICAgIGNvbnNvbGUubG9nKCdDaGFpbiBJRDonLCB0aGlzLmNoYWluSWQpXG4gICAgICBjb25zb2xlLmxvZygnU29sYW5hIFVzZXIgUHVibGljIEtleTonLCB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LnRvQmFzZTU4KCkpXG4gICAgICBjb25zb2xlLmxvZygnU29sYW5hIFVzZXIgTmVvbiBXYWxsZXQ6JywgdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQpXG4gICAgICBjb25zb2xlLmxvZygnU29sYW5hIFVzZXIgQmFsYW5jZSBBZGRyZXNzOicsIHRoaXMuc29sYW5hVXNlci5iYWxhbmNlQWRkcmVzcy50b0Jhc2U1OCgpKVxuXG4gICAgICAvLyBDcmVhdGUgY29udHJhY3QgaW5zdGFuY2VcbiAgICAgIGNvbnN0IHJlYWRPbmx5UHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihORU9OX0NPUkVfUlBDX1VSTClcbiAgICAgIHRoaXMuY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KENPTlRSQUNUX0FERFJFU1MsIFNPTEFOQV9USVBDQVJEX0FCSSwgcmVhZE9ubHlQcm92aWRlcilcbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IHRoZSBkZXJpdmVkIEVWTSBhZGRyZXNzIGlzIHZhbGlkXG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBWZXJpZnlpbmcgZGVyaXZlZCBFVk0gYWRkcmVzcy4uLicpXG4gICAgICB0cnkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIEVWTSBhZGRyZXNzIGhhcyBiZWVuIHVzZWQgYmVmb3JlIChoYXMgdHJhbnNhY3Rpb24gaGlzdG9yeSlcbiAgICAgICAgY29uc3QgdHhDb3VudCA9IGF3YWl0IHJlYWRPbmx5UHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25Db3VudCh0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldClcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk4ogRVZNIGFkZHJlc3MgdHJhbnNhY3Rpb24gY291bnQ6JywgdHhDb3VudClcbiAgICAgICAgXG4gICAgICAgIGlmICh0eENvdW50ID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgVGhpcyBFVk0gYWRkcmVzcyBoYXMgdHJhbnNhY3Rpb24gaGlzdG9yeSAtIGl0IGV4aXN0cyBvbi1jaGFpbiEnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfihLnvuI8gVGhpcyBFVk0gYWRkcmVzcyBpcyBuZXcgKG5vIHRyYW5zYWN0aW9uIGhpc3RvcnkgeWV0KScpXG4gICAgICAgICAgY29uc29sZS5sb2coJ+KEue+4jyBUaGUgYWRkcmVzcyB3aWxsIGJlIHJlZ2lzdGVyZWQgb24tY2hhaW4gd2hlbiBmaXJzdCB0cmFuc2FjdGlvbiBpcyBtYWRlJylcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAodmVyaWZ5RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KaoO+4jyBDb3VsZCBub3QgdmVyaWZ5IEVWTSBhZGRyZXNzOicsIHZlcmlmeUVycm9yKVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBWZXJpZnkgY29udHJhY3QgaXMgZGVwbG95ZWQgYXQgdGhpcyBhZGRyZXNzXG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZygnVmVyaWZ5aW5nIGNvbnRyYWN0IGF0IGFkZHJlc3M6JywgQ09OVFJBQ1RfQUREUkVTUylcbiAgICAgICAgY29uc3QgY29kZSA9IGF3YWl0IHJlYWRPbmx5UHJvdmlkZXIuZ2V0Q29kZShDT05UUkFDVF9BRERSRVNTKVxuICAgICAgICBjb25zb2xlLmxvZygnQ29udHJhY3QgY29kZSBsZW5ndGg6JywgY29kZS5sZW5ndGgpXG4gICAgICAgIGlmIChjb2RlID09PSAnMHgnKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gTm8gY29udHJhY3QgY29kZSBmb3VuZCBhdCBhZGRyZXNzOicsIENPTlRSQUNUX0FERFJFU1MpXG4gICAgICAgICAgY29uc29sZS5sb2coJ1RoaXMgbWlnaHQgbWVhbiB0aGUgY29udHJhY3QgaXMgbm90IGRlcGxveWVkIG9yIGFkZHJlc3MgaXMgaW5jb3JyZWN0JylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIENvbnRyYWN0IGZvdW5kIGF0IGFkZHJlc3MnKVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgQ29udHJhY3QgZm91bmQgYW5kIHJlYWR5IGZvciB0cmFuc2FjdGlvbnMnKVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoICh2ZXJpZnlFcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byB2ZXJpZnkgY29udHJhY3Q6JywgdmVyaWZ5RXJyb3IpXG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgU29sYW5hIE5hdGl2ZSBTREs6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBwYXltZW50IGxpbmsgdXNpbmcgU29sYW5hIE5hdGl2ZSBTREtcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVBheW1lbnRMaW5rKFxuICAgIHN1Z2dlc3RlZEFtb3VudFNPTDogbnVtYmVyLFxuICAgIGlzRmxleGlibGU6IGJvb2xlYW4sXG4gICAgZGVzY3JpcHRpb246IHN0cmluZ1xuICApOiBQcm9taXNlPHsgbGlua0lkOiBzdHJpbmc7IHR4SGFzaDogc3RyaW5nIH0+IHtcbiAgICBpZiAoIXRoaXMuc29sYW5hVXNlciB8fCAhdGhpcy5jb250cmFjdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgY29ubmVjdCB3YWxsZXQgZmlyc3QnKVxuICAgIH1cblxuICAgIC8vIENvbnZlcnQgU09MIHRvIGxhbXBvcnRzICgxIFNPTCA9IDFlOSBsYW1wb3J0cylcbiAgICBjb25zdCBhbW91bnRMYW1wb3J0cyA9IE1hdGguZmxvb3Ioc3VnZ2VzdGVkQW1vdW50U09MICogMWU5KVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBjdXJyZW50IG5vbmNlIChleGFjdGx5IGxpa2Ugd29ya2luZyBleGFtcGxlcylcbiAgICAgIGNvbnN0IG5vbmNlID0gTnVtYmVyKGF3YWl0IHRoaXMucHJveHlBcGkuZ2V0VHJhbnNhY3Rpb25Db3VudCh0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCkpXG4gICAgICBjb25zb2xlLmxvZygnQ3VycmVudCBub25jZTonLCBub25jZSlcblxuICAgICAgLy8gUHJlcGFyZSBjb250cmFjdCBjYWxsIGRhdGFcbiAgICAgIGNvbnN0IGlmYWNlID0gbmV3IGV0aGVycy5JbnRlcmZhY2UoU09MQU5BX1RJUENBUkRfQUJJKVxuICAgICAgY29uc3QgZGF0YSA9IGlmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YSgnY3JlYXRlU29sYW5hUGF5bWVudExpbmsnLCBbXG4gICAgICAgIGFtb3VudExhbXBvcnRzLFxuICAgICAgICBpc0ZsZXhpYmxlLFxuICAgICAgICBkZXNjcmlwdGlvblxuICAgICAgXSlcblxuICAgICAgLy8gQ3JlYXRlIHRyYW5zYWN0aW9uIGRhdGFcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uRGF0YSA9IHtcbiAgICAgICAgZnJvbTogdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsXG4gICAgICAgIHRvOiBDT05UUkFDVF9BRERSRVNTLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9XG5cbiAgICAgIC8vIEVzdGltYXRlIGdhc1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25HYXMgPSBhd2FpdCB0aGlzLnByb3h5QXBpLmVzdGltYXRlU2NoZWR1bGVkVHJhbnNhY3Rpb25HYXMoe1xuICAgICAgICBzb2xhbmFQYXllcjogdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleSxcbiAgICAgICAgdHJhbnNhY3Rpb25zOiBbdHJhbnNhY3Rpb25EYXRhXSxcbiAgICAgIH0pXG5cbiAgICAgIC8vIENyZWF0ZSBzY2hlZHVsZWQgdHJhbnNhY3Rpb25cbiAgICAgIGxldCB7IHNjaGVkdWxlZFRyYW5zYWN0aW9uIH0gPSBhd2FpdCB0aGlzLnByb3h5QXBpLmNyZWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgdHJhbnNhY3Rpb25HYXMsXG4gICAgICAgIHRyYW5zYWN0aW9uRGF0YSxcbiAgICAgICAgbm9uY2VcbiAgICAgIH0pXG5cbiAgICAgIC8vIENoZWNrIGlmIGJhbGFuY2UgYWNjb3VudCBleGlzdHMsIGlmIG5vdCBjcmVhdGUgaXRcbiAgICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZ2V0QWNjb3VudEluZm8odGhpcy5zb2xhbmFVc2VyLmJhbGFuY2VBZGRyZXNzKVxuICAgICAgaWYgKGFjY291bnQgPT09IG51bGwpIHtcbiAgICAgICAgc2NoZWR1bGVkVHJhbnNhY3Rpb24uaW5zdHJ1Y3Rpb25zLnVuc2hpZnQoXG4gICAgICAgICAgY3JlYXRlQmFsYW5jZUFjY291bnRJbnN0cnVjdGlvbihcbiAgICAgICAgICAgIHRoaXMuc29sYW5hVXNlci5uZW9uRXZtUHJvZ3JhbSxcbiAgICAgICAgICAgIHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXksXG4gICAgICAgICAgICB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCxcbiAgICAgICAgICAgIHRoaXMuY2hhaW5JZCFcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gU2lnbiBhbmQgc2VuZCB0cmFuc2FjdGlvbiAoZXhhY3RseSBsaWtlIHdvcmtpbmcgZXhhbXBsZXMpXG4gICAgICBjb25zdCB7IGJsb2NraGFzaCB9ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgpXG4gICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBibG9ja2hhc2hcbiAgICAgIHNjaGVkdWxlZFRyYW5zYWN0aW9uLmZlZVBheWVyID0gdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnU2lnbmluZyB3aXRoIHdhbGxldCBhZGFwdGVyLi4uJylcbiAgICAgIFxuICAgICAgLy8gU2lnbiB0cmFuc2FjdGlvbiB1c2luZyB3YWxsZXQgYWRhcHRlciBpbnN0ZWFkIG9mIGtleXBhaXIgKGxpa2UgaW4gdGVzdHMpXG4gICAgICAvLyBJbiB0ZXN0czogc2NoZWR1bGVkVHJhbnNhY3Rpb24uc2lnbih7IHB1YmxpY0tleTogc29sYW5hVXNlci5wdWJsaWNLZXksIHNlY3JldEtleTogc29sYW5hVXNlci5rZXlwYWlyLnNlY3JldEtleSB9KVxuICAgICAgLy8gSW4gZnJvbnRlbmQ6IHVzZSB3YWxsZXQgYWRhcHRlciBzaWduaW5nXG4gICAgICBjb25zdCBzaWduZWRUeCA9IGF3YWl0IHRoaXMuc29sYW5hVXNlci53YWxsZXRBZGFwdGVyLnNpZ25UcmFuc2FjdGlvbihzY2hlZHVsZWRUcmFuc2FjdGlvbilcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1N1Ym1pdHRpbmcgdHJhbnNhY3Rpb24uLi4nKVxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihzaWduZWRUeC5zZXJpYWxpemUoKSlcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ+KchSBUcmFuc2FjdGlvbiBzdWJtaXR0ZWQhJylcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SXIFNpZ25hdHVyZTonLCBzaWduYXR1cmUpXG5cbiAgICAgIC8vIFdhaXQgYSBiaXQgZm9yIHByb2Nlc3NpbmcgKGxpa2Ugd29ya2luZyBleGFtcGxlcylcbiAgICAgIGNvbnNvbGUubG9nKCdXYWl0aW5nIGZvciBjb25maXJtYXRpb24uLi4nKVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMDApKVxuXG4gICAgICAvLyBXYWl0IGZvciB0cmFuc2FjdGlvbiBleGVjdXRpb24gb24gTmVvbiBFVk1cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uU3RhdHVzID0gYXdhaXQgdGhpcy5wcm94eUFwaS53YWl0VHJhbnNhY3Rpb25UcmVlRXhlY3V0aW9uKFxuICAgICAgICB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCwgXG4gICAgICAgIG5vbmNlLCBcbiAgICAgICAgNjAwMDAgLy8gNjAgc2Vjb25kIHRpbWVvdXRcbiAgICAgIClcblxuICAgICAgY29uc29sZS5sb2coJ1RyYW5zYWN0aW9uIHN0YXR1czonLCB0cmFuc2FjdGlvblN0YXR1cylcblxuICAgICAgaWYgKHRyYW5zYWN0aW9uU3RhdHVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHRyYW5zYWN0aW9uIHN0YXR1cyByZXR1cm5lZCAtIHRyYW5zYWN0aW9uIG1heSBub3QgaGF2ZSBiZWVuIHByb2Nlc3NlZCcpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHR4U3RhdHVzID0gdHJhbnNhY3Rpb25TdGF0dXNbMF1cbiAgICAgIGNvbnNvbGUubG9nKCdUcmFuc2FjdGlvbiBleGVjdXRpb24gc3RhdHVzOicsIHR4U3RhdHVzLnN0YXR1cylcbiAgICAgIFxuICAgICAgaWYgKHR4U3RhdHVzLnN0YXR1cyA9PT0gJ05vdFN0YXJ0ZWQnKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIFRyYW5zYWN0aW9uIHdhcyBzY2hlZHVsZWQgYnV0IG5vdCB5ZXQgZXhlY3V0ZWQgYnkgTmVvbiBvcGVyYXRvcnMnKVxuICAgICAgICBjb25zb2xlLmxvZygnVGhpcyBpcyBleHBlY3RlZCAtIE5lb24gd2lsbCBwcm9jZXNzIGl0IGV2ZW50dWFsbHknKVxuICAgICAgICBjb25zb2xlLmxvZygnVHJhbnNhY3Rpb24gaGFzaDonLCB0eFN0YXR1cy50cmFuc2FjdGlvbkhhc2gpXG4gICAgICAgIFxuICAgICAgICAvLyBTaW5jZSB3ZSBoYXZlIGEgdHJhbnNhY3Rpb24gaGFzaCwgcHJvY2VlZCB3aXRoIHVzaW5nIGl0IGFzIHRoZSBwYXltZW50IGxpbmsgSURcbiAgICAgICAgLy8gVGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IE5lb24gb3BlcmF0b3JzIGV2ZW50dWFsbHlcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBVc2luZyB0cmFuc2FjdGlvbiBoYXNoIGFzIHBheW1lbnQgbGluayBJRCAtIE5lb24gd2lsbCBwcm9jZXNzIGl0IHdoZW4gcmVhZHknKVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsaW5rSWQ6IHR4U3RhdHVzLnRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICB0eEhhc2g6IHR4U3RhdHVzLnRyYW5zYWN0aW9uSGFzaFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgfSBlbHNlIGlmICh0eFN0YXR1cy5zdGF0dXMgPT09ICdGYWlsZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gZXhlY3V0aW9uIGZhaWxlZC4gSGFzaDogJHt0eFN0YXR1cy50cmFuc2FjdGlvbkhhc2h9YClcbiAgICAgIH0gZWxzZSBpZiAodHhTdGF0dXMuc3RhdHVzICE9PSAnU3VjY2VzcycpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdUcmFuc2FjdGlvbiBmaW5pc2hlZCB3aXRoIHVuZXhwZWN0ZWQgc3RhdHVzOicsIHR4U3RhdHVzLnN0YXR1cylcbiAgICAgICAgLy8gU3RpbGwgdHJ5IHRvIHJldHVybiB0aGUgdHJhbnNhY3Rpb24gaGFzaCBpbiBjYXNlIGl0J3MgdXNhYmxlXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGlua0lkOiB0eFN0YXR1cy50cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgdHhIYXNoOiB0eFN0YXR1cy50cmFuc2FjdGlvbkhhc2hcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB0eEhhc2ggPSB0cmFuc2FjdGlvblN0YXR1c1swXS50cmFuc2FjdGlvbkhhc2hcbiAgICAgIGNvbnNvbGUubG9nKCdUcmFuc2FjdGlvbiBoYXNoOicsIHR4SGFzaClcblxuICAgICAgLy8gR2V0IHRoZSBsaW5rIElEIGZyb20gdHJhbnNhY3Rpb24gcmVjZWlwdFxuICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMucHJveHlBcGkuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaClcbiAgICAgIGNvbnNvbGUubG9nKCdGdWxsIHRyYW5zYWN0aW9uIHJlY2VpcHQ6JywgSlNPTi5zdHJpbmdpZnkocmVjZWlwdCwgbnVsbCwgMikpXG4gICAgICBcbiAgICAgIGxldCBsaW5rSWQgPSAnJ1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0aGUgdHJhbnNhY3Rpb24gd2FzIHN1Y2Nlc3NmdWxcbiAgICAgIGlmIChyZWNlaXB0LnJlc3VsdD8uc3RhdHVzICE9PSAnMHgxJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIGZhaWxlZCAtIHN0YXR1czogJyArIHJlY2VpcHQucmVzdWx0Py5zdGF0dXMpXG4gICAgICB9XG5cbiAgICAgIC8vIEVuaGFuY2VkIGRlYnVnZ2luZyBvZiB0aGUgcmVjZWlwdCBzdHJ1Y3R1cmVcbiAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXB0IHN0YXR1czonLCByZWNlaXB0LnJlc3VsdD8uc3RhdHVzKVxuICAgICAgY29uc29sZS5sb2coJ1JlY2VpcHQgbG9ncyBhcnJheTonLCByZWNlaXB0LnJlc3VsdD8ubG9ncylcbiAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXB0IGxvZ3MgbGVuZ3RoOicsIHJlY2VpcHQucmVzdWx0Py5sb2dzPy5sZW5ndGgpXG4gICAgICBjb25zb2xlLmxvZygnUmVjZWlwdCBsb2dzQmxvb206JywgcmVjZWlwdC5yZXN1bHQ/LmxvZ3NCbG9vbSlcbiAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXB0IGNvbnRyYWN0QWRkcmVzczonLCByZWNlaXB0LnJlc3VsdD8uY29udHJhY3RBZGRyZXNzKVxuICAgICAgY29uc29sZS5sb2coJ1JlY2VpcHQgZ2FzVXNlZDonLCByZWNlaXB0LnJlc3VsdD8uZ2FzVXNlZClcbiAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXB0IGVmZmVjdGl2ZUdhc1ByaWNlOicsIHJlY2VpcHQucmVzdWx0Py5lZmZlY3RpdmVHYXNQcmljZSlcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhIGRpZmZlcmVudCBsb2NhdGlvbiBmb3IgbG9nc1xuICAgICAgY29uc29sZS5sb2coJ1JhdyB0cmFuc2FjdGlvbiBkYXRhOicsIHJlY2VpcHQucmVzdWx0Py5uZW9uUmF3VHJhbnNhY3Rpb24pXG4gICAgICBcbiAgICAgIC8vIE5vdGU6IGdldFRyYW5zYWN0aW9uIG1ldGhvZCBub3QgYXZhaWxhYmxlIG9uIE5lb25Qcm94eVJwY0FwaVxuICAgICAgLy8gVHJhbnNhY3Rpb24gZGV0YWlscyBhcmUgYWxyZWFkeSBpbiB0aGUgcmVjZWlwdFxuXG4gICAgICAvLyBFeHRyYWN0IGFsbCBuZW9uTG9ncyBmcm9tIHNvbGFuYVRyYW5zYWN0aW9uc1xuICAgICAgY29uc3QgYWxsTmVvbkxvZ3M6IGFueVtdID0gW11cbiAgICAgIGlmIChyZWNlaXB0LnJlc3VsdD8uc29sYW5hVHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc29sVHggb2YgcmVjZWlwdC5yZXN1bHQuc29sYW5hVHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgaWYgKHNvbFR4LnNvbGFuYUluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbnN0cnVjdGlvbiBvZiBzb2xUeC5zb2xhbmFJbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLm5lb25Mb2dzICYmIGluc3RydWN0aW9uLm5lb25Mb2dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBhbGxOZW9uTG9ncy5wdXNoKC4uLmluc3RydWN0aW9uLm5lb25Mb2dzKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCcsIGFsbE5lb25Mb2dzLmxlbmd0aCwgJ25lb25Mb2dzIHRvIHBhcnNlJylcblxuICAgICAgLy8gVHJ5IHRvIHBhcnNlIGxvZ3MgZm9yIHRoZSBTb2xhbmFMaW5rQ3JlYXRlZCBldmVudFxuICAgICAgaWYgKGFsbE5lb25Mb2dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChjb25zdCBsb2cgb2YgYWxsTmVvbkxvZ3MpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1RyeWluZyB0byBwYXJzZSBuZW9uTG9nOicsIGxvZylcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBsb2cgaXMgZnJvbSBvdXIgY29udHJhY3RcbiAgICAgICAgICAgIGlmIChsb2cuYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBDT05UUkFDVF9BRERSRVNTLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0xvZyBpcyBmcm9tIG91ciBjb250cmFjdCwgcGFyc2luZy4uLicpXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBsb2cgdG8gdGhlIGZvcm1hdCBleHBlY3RlZCBieSBldGhlcnNcbiAgICAgICAgICAgICAgY29uc3QgZXRoZXJzTG9nID0ge1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGxvZy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgIGRhdGE6IGxvZy5kYXRhLFxuICAgICAgICAgICAgICAgIHRvcGljczogbG9nLnRvcGljc1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBjb25zdCBwYXJzZWRMb2cgPSBpZmFjZS5wYXJzZUxvZyhldGhlcnNMb2cpXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQYXJzZWQgbG9nOicsIHBhcnNlZExvZylcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmIChwYXJzZWRMb2c/Lm5hbWUgPT09ICdTb2xhbmFMaW5rQ3JlYXRlZCcpIHtcbiAgICAgICAgICAgICAgICBsaW5rSWQgPSBwYXJzZWRMb2cuYXJncy5saW5rSWRcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIEZvdW5kIGxpbmsgSUQgZnJvbSBTb2xhbmFMaW5rQ3JlYXRlZCBldmVudDonLCBsaW5rSWQpXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0xvZyBmcm9tIGRpZmZlcmVudCBjb250cmFjdDonLCBsb2cuYWRkcmVzcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmFpbGVkIHRvIHBhcnNlIG5lb25Mb2c6JywgZSlcbiAgICAgICAgICAgIC8vIFNraXAgbG9ncyB0aGF0IGNhbid0IGJlIHBhcnNlZFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdObyBuZW9uTG9ncyBmb3VuZCBpbiB0cmFuc2FjdGlvbiByZWNlaXB0IScpXG4gICAgICAgIGNvbnNvbGUubG9nKCdUaGlzIG1pZ2h0IGluZGljYXRlOicpXG4gICAgICAgIGNvbnNvbGUubG9nKCcxLiBUaGUgY29udHJhY3QgY2FsbCBmYWlsZWQgc2lsZW50bHknKVxuICAgICAgICBjb25zb2xlLmxvZygnMi4gVGhlIGNvbnRyYWN0IGlzIG5vdCBhdCB0aGUgZXhwZWN0ZWQgYWRkcmVzcycpXG4gICAgICAgIGNvbnNvbGUubG9nKCczLiBUaGUgY29udHJhY3QgZnVuY3Rpb24gY2FsbCByZXZlcnRlZCcpXG4gICAgICAgIGNvbnNvbGUubG9nKCc0LiBFdmVudHMgYXJlIG5vdCBiZWluZyBlbWl0dGVkIHByb3Blcmx5JylcbiAgICAgICAgXG4gICAgICAgIC8vIFRyeSBjYWxsaW5nIHRoZSBjb250cmFjdCByZWFkIG1ldGhvZCB0byBzZWUgaWYgZGF0YSB3YXMgYWN0dWFsbHkgc3RvcmVkXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0F0dGVtcHRpbmcgdG8gcmVhZCBwYXltZW50IGxpbmsgdXNpbmcgdHJhbnNhY3Rpb24gaGFzaCBhcyBJRC4uLicpXG4gICAgICAgICAgY29uc3QgdGVzdERhdGEgPSBhd2FpdCB0aGlzLmNvbnRyYWN0IS5nZXRTb2xhbmFQYXltZW50TGluayh0eEhhc2gpXG4gICAgICAgICAgY29uc29sZS5sb2coJ0NvbnRyYWN0IHJlYWQgcmVzdWx0OicsIHRlc3REYXRhKVxuICAgICAgICB9IGNhdGNoIChyZWFkRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ29udHJhY3QgcmVhZCBmYWlsZWQ6JywgcmVhZEVycm9yKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlIGNvdWxkbid0IGV4dHJhY3QgZnJvbSBsb2dzLCBpbnZlc3RpZ2F0ZSBmdXJ0aGVyXG4gICAgICBpZiAoIWxpbmtJZCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdDb3VsZCBub3QgZXh0cmFjdCBsaW5rIElEIGZyb20gdHJhbnNhY3Rpb24gZXZlbnRzIScpXG4gICAgICAgIGNvbnNvbGUubG9nKCdUaGlzIHN1Z2dlc3RzIHRoZSBjb250cmFjdCBjYWxsIG1heSBoYXZlIGZhaWxlZCBzaWxlbnRseScpXG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgdHJhbnNhY3Rpb24gYWN0dWFsbHkgcmV2ZXJ0ZWRcbiAgICAgICAgY29uc29sZS5sb2coJ0NoZWNraW5nIGZvciByZXZlcnQgZGF0YS4uLicpXG4gICAgICAgIGlmIChyZWNlaXB0LnJlc3VsdD8ubmVvblJldmVydERhdGEpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnUmV2ZXJ0IGRhdGEgZm91bmQ6JywgcmVjZWlwdC5yZXN1bHQubmVvblJldmVydERhdGEpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBkZWNvZGUgdGhlIHJldmVydCByZWFzb25cbiAgICAgICAgICAgIGNvbnN0IHJldmVydFJlYXNvbiA9IGV0aGVycy50b1V0ZjhTdHJpbmcocmVjZWlwdC5yZXN1bHQubmVvblJldmVydERhdGEpXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUmV2ZXJ0IHJlYXNvbjonLCByZXZlcnRSZWFzb24pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnRyYWN0IGNhbGwgcmV2ZXJ0ZWQ6ICR7cmV2ZXJ0UmVhc29ufWApXG4gICAgICAgICAgfSBjYXRjaCAoZGVjb2RlRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb3VsZCBub3QgZGVjb2RlIHJldmVydCByZWFzb246JywgZGVjb2RlRXJyb3IpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRyYWN0IGNhbGwgcmV2ZXJ0ZWQgd2l0aCB1bmtub3duIHJlYXNvbicpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBMZXQncyB0cnkgdG8gdW5kZXJzdGFuZCB3aHkgdGhlIGV2ZW50IHdhc24ndCBlbWl0dGVkXG4gICAgICAgIGNvbnNvbGUubG9nKCdBbmFseXppbmcgZnVuY3Rpb24gY2FsbC4uLicpXG4gICAgICAgIGNvbnNvbGUubG9nKCdDb250cmFjdCBhZGRyZXNzOicsIENPTlRSQUNUX0FERFJFU1MpXG4gICAgICAgIGNvbnNvbGUubG9nKCdGcm9tIGFkZHJlc3M6JywgdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQpXG4gICAgICAgIGNvbnNvbGUubG9nKCdGdW5jdGlvbiBkYXRhIGluIHJhdyB0eDonLCByZWNlaXB0LnJlc3VsdD8ubmVvblJhd1RyYW5zYWN0aW9uKVxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgdXNlciBpcyByZWdpc3RlcmVkXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgaXNSZWdpc3RlcmVkID0gYXdhaXQgdGhpcy5jb250cmFjdCEuaXNTb2xhbmFVc2VyKHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0KVxuICAgICAgICAgIGNvbnNvbGUubG9nKCdJcyB1c2VyIHJlZ2lzdGVyZWQgYXMgU29sYW5hIHVzZXI6JywgaXNSZWdpc3RlcmVkKVxuICAgICAgICAgIFxuICAgICAgICAgIGlmICghaXNSZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZXIgaXMgbm90IHJlZ2lzdGVyZWQgYXMgYSBTb2xhbmEgdXNlciB3aXRoIHRoZSBjb250cmFjdC4gVGhpcyBpcyByZXF1aXJlZCB0byBjcmVhdGUgcGF5bWVudCBsaW5rcy4nKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAocmVnaXN0cmF0aW9uRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY2hlY2sgdXNlciByZWdpc3RyYXRpb246JywgcmVnaXN0cmF0aW9uRXJyb3IpXG4gICAgICAgICAgdGhyb3cgcmVnaXN0cmF0aW9uRXJyb3JcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIHNvbWV0aGluZyBlbHNlIHdlbnQgd3JvbmdcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXltZW50IGxpbmsgY3JlYXRpb24gZmFpbGVkOiBDb250cmFjdCBjYWxsIGV4ZWN1dGVkIGJ1dCBubyBldmVudCB3YXMgZW1pdHRlZC4gVGhlIHRyYW5zYWN0aW9uIG1heSBoYXZlIGZhaWxlZCBzaWxlbnRseS4nKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5rSWQsXG4gICAgICAgIHR4SGFzaFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHBheW1lbnQgbGluazonLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgcmVhZC1vbmx5IGNvbnRyYWN0IGFjY2VzcyAod2l0aG91dCB3YWxsZXQpXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGluaXRSZWFkT25seUNvbnRyYWN0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5jb250cmFjdCkge1xuICAgICAgLy8gQ3JlYXRlIGEgc2ltcGxlIEpTT04gUlBDIHByb3ZpZGVyIGZvciByZWFkIG9wZXJhdGlvbnNcbiAgICAgIGNvbnN0IHJlYWRPbmx5UHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihORU9OX0NPUkVfUlBDX1VSTClcbiAgICAgIHRoaXMuY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KENPTlRSQUNUX0FERFJFU1MsIFNPTEFOQV9USVBDQVJEX0FCSSwgcmVhZE9ubHlQcm92aWRlcilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHBheW1lbnQgbGluayBkZXRhaWxzXG4gICAqL1xuICBhc3luYyBnZXRQYXltZW50TGluayhsaW5rSWQ6IHN0cmluZyk6IFByb21pc2U8UGF5bWVudExpbms+IHtcbiAgICAvLyBJbml0aWFsaXplIGNvbnRyYWN0IGlmIG5vdCBhbHJlYWR5IGRvbmVcbiAgICBpZiAoIXRoaXMuY29udHJhY3QpIHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdFJlYWRPbmx5Q29udHJhY3QoKVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIHBheW1lbnQgbGluayB3aXRoIElEOicsIGxpbmtJZClcbiAgICBjb25zb2xlLmxvZygnQ29udHJhY3QgYWRkcmVzczonLCBDT05UUkFDVF9BRERSRVNTKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY29udHJhY3QhLmdldFNvbGFuYVBheW1lbnRMaW5rKGxpbmtJZClcbiAgICAgIGNvbnNvbGUubG9nKCdSYXcgY29udHJhY3QgcmVzdWx0OicsIHJlc3VsdClcbiAgICAgIFxuICAgICAgY29uc3QgcGF5bWVudExpbmsgPSB7XG4gICAgICAgIGV2bUNyZWF0b3I6IHJlc3VsdC5ldm1DcmVhdG9yLFxuICAgICAgICBzb2xhbmFDcmVhdG9yOiByZXN1bHQuc29sYW5hQ3JlYXRvcixcbiAgICAgICAgYW1vdW50OiByZXN1bHQuYW1vdW50LFxuICAgICAgICBpc0ZsZXhpYmxlOiByZXN1bHQuaXNGbGV4aWJsZSxcbiAgICAgICAgaXNBY3RpdmU6IHJlc3VsdC5pc0FjdGl2ZSxcbiAgICAgICAgdG90YWxSZWNlaXZlZDogcmVzdWx0LnRvdGFsUmVjZWl2ZWQsXG4gICAgICAgIHBheW1lbnRDb3VudDogTnVtYmVyKHJlc3VsdC5wYXltZW50Q291bnQpLFxuICAgICAgICBkZXNjcmlwdGlvbjogcmVzdWx0LmRlc2NyaXB0aW9uXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgbG9va3MgbGlrZSBhbiBlbXB0eS9ub24tZXhpc3RlbnQgbGluayAodHJhbnNhY3Rpb24gbm90IHByb2Nlc3NlZCB5ZXQpXG4gICAgICBpZiAocmVzdWx0LmV2bUNyZWF0b3IgPT09ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnICYmIFxuICAgICAgICAgIHJlc3VsdC5hbW91bnQgPT09IEJpZ0ludCgwKSAmJiBcbiAgICAgICAgICAhcmVzdWx0LmlzQWN0aXZlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignUGF5bWVudCBsaW5rIGFwcGVhcnMgdG8gYmUgZW1wdHkvbm9uLWV4aXN0ZW50JylcbiAgICAgICAgXG4gICAgICAgIC8vIElmIHRoaXMgbG9va3MgbGlrZSBhIHRyYW5zYWN0aW9uIGhhc2ggKDY2IGNoYXJzLCBzdGFydHMgd2l0aCAweCksIHByb3ZpZGUgaGVscGZ1bCBpbmZvXG4gICAgICAgIGlmIChsaW5rSWQubGVuZ3RoID09PSA2NiAmJiBsaW5rSWQuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5KhIFRoaXMgYXBwZWFycyB0byBiZSBhIHRyYW5zYWN0aW9uIGhhc2ggLSB0aGUgcGF5bWVudCBsaW5rIG1heSBzdGlsbCBiZSBwcm9jZXNzaW5nJylcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+SoSBOZW9uIG9wZXJhdG9ycyB3aWxsIGV2ZW50dWFsbHkgcHJvY2VzcyB0aGlzIHRyYW5zYWN0aW9uIGFuZCBjcmVhdGUgdGhlIHBheW1lbnQgbGluaycpXG4gICAgICAgICAgY29uc29sZS5sb2coJ/CfkqEgWW91IGNhbiBib29rbWFyayB0aGlzIGxpbmsgYW5kIHRyeSBhZ2FpbiBpbiBhIGZldyBtaW51dGVzJylcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGb3Igbm93LCBkb24ndCB0aHJvdyBhbiBlcnJvciAtIGxldCB0aGUgVUkgaGFuZGxlIHRoZSBlbXB0eSBkYXRhIGdyYWNlZnVsbHlcbiAgICAgICAgICBjb25zb2xlLmxvZygnUmV0dXJuaW5nIGVtcHR5IHBheW1lbnQgbGluayBkYXRhIC0gdHJhbnNhY3Rpb24gbWF5IHN0aWxsIGJlIHByb2Nlc3NpbmcnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBwYXltZW50TGlua1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDb250cmFjdCBjYWxsIGVycm9yOicsIGVycm9yKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXltZW50IGxpbmsgbm90IGZvdW5kIG9yIGNvbnRyYWN0IGVycm9yJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHVzZXIncyBwYXltZW50IGxpbmtzXG4gICAqL1xuICBhc3luYyBnZXRVc2VyTGlua3ModXNlckVWTUFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICAvLyBJbml0aWFsaXplIGNvbnRyYWN0IGlmIG5vdCBhbHJlYWR5IGRvbmVcbiAgICBpZiAoIXRoaXMuY29udHJhY3QpIHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdFJlYWRPbmx5Q29udHJhY3QoKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb250cmFjdCEuZ2V0VXNlclNvbGFuYUxpbmtzKHVzZXJFVk1BZGRyZXNzKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHVzZXIgbGlua3M6JywgZXJyb3IpXG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGF5IGEgcGF5bWVudCBsaW5rIHVzaW5nIFNvbGFuYSBOYXRpdmUgU0RLXG4gICAqL1xuICBhc3luYyBwYXlMaW5rKFxuICAgIGxpbmtJZDogc3RyaW5nLFxuICAgIGFtb3VudFNPTDogbnVtYmVyXG4gICk6IFByb21pc2U8eyB0eEhhc2g6IHN0cmluZzsgdHJhbnNmZXJTaWduYXR1cmU/OiBzdHJpbmcgfT4ge1xuICAgIGlmICghdGhpcy5zb2xhbmFVc2VyIHx8ICF0aGlzLmNvbnRyYWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBjb25uZWN0IHdhbGxldCBmaXJzdCcpXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIHBheW1lbnQgcHJvY2Vzcy4uLicpXG4gICAgY29uc29sZS5sb2coJ0xpbmsgSUQ6JywgbGlua0lkKVxuICAgIGNvbnNvbGUubG9nKCdBbW91bnQgU09MOicsIGFtb3VudFNPTClcblxuICAgIC8vIEZpcnN0LCBnZXQgdGhlIHBheW1lbnQgbGluayBkZXRhaWxzIHRvIGZpbmQgdGhlIHJlY2lwaWVudFxuICAgIGNvbnN0IGxpbmtEYXRhID0gYXdhaXQgdGhpcy5nZXRQYXltZW50TGluayhsaW5rSWQpXG4gICAgY29uc29sZS5sb2coJ1BheW1lbnQgbGluayBkYXRhOicsIGxpbmtEYXRhKVxuXG4gICAgaWYgKCFsaW5rRGF0YS5pc0FjdGl2ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXltZW50IGxpbmsgaXMgbm8gbG9uZ2VyIGFjdGl2ZScpXG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBTT0wgdG8gbGFtcG9ydHNcbiAgICBjb25zdCBhbW91bnRMYW1wb3J0cyA9IE1hdGguZmxvb3IoYW1vdW50U09MICogMWU5KVxuICAgIFxuICAgIGxldCB0cmFuc2ZlclNpZ25hdHVyZTogc3RyaW5nIHwgdW5kZWZpbmVkXG5cbiAgICB0cnkge1xuICAgICAgLy8gU3RlcCAxOiBQZXJmb3JtIHRoZSBhY3R1YWwgU09MIHRyYW5zZmVyIGZpcnN0XG4gICAgICBjb25zb2xlLmxvZygnU3RlcCAxOiBQZXJmb3JtaW5nIFNPTCB0cmFuc2Zlci4uLicpXG4gICAgICBjb25zb2xlLmxvZygnRnJvbTonLCB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LnRvQmFzZTU4KCkpXG4gICAgICBjb25zb2xlLmxvZygnVG8gcmVjaXBpZW50IGJ5dGVzMzI6JywgbGlua0RhdGEuc29sYW5hQ3JlYXRvcilcbiAgICAgIGNvbnNvbGUubG9nKCdBbW91bnQgbGFtcG9ydHM6JywgYW1vdW50TGFtcG9ydHMpXG5cbiAgICAgIC8vIENvbnZlcnQgcmVjaXBpZW50IFNvbGFuYSBhZGRyZXNzIGZyb20gYnl0ZXMzMiB0byBQdWJsaWNLZXlcbiAgICAgIC8vIFJlbW92ZSAnMHgnIHByZWZpeCBpZiBwcmVzZW50XG4gICAgICBjb25zdCBoZXhTdHJpbmcgPSBsaW5rRGF0YS5zb2xhbmFDcmVhdG9yLnN0YXJ0c1dpdGgoJzB4JykgXG4gICAgICAgID8gbGlua0RhdGEuc29sYW5hQ3JlYXRvci5zbGljZSgyKSBcbiAgICAgICAgOiBsaW5rRGF0YS5zb2xhbmFDcmVhdG9yXG4gICAgICBcbiAgICAgIC8vIENvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG4gICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGhleFN0cmluZy5tYXRjaCgvLnsyfS9nKT8ubWFwKGJ5dGUgPT4gcGFyc2VJbnQoYnl0ZSwgMTYpKSB8fCBbXSlcbiAgICAgIFxuICAgICAgLy8gRm9yIGJ5dGVzMzIgZnJvbSBTb2xhbmEgYWRkcmVzc2VzLCB3ZSBuZWVkIHRvIGZpbmQgdGhlIGFjdHVhbCAzMi1ieXRlIHB1YmxpYyBrZXlcbiAgICAgIC8vIFRoZSBieXRlczMyIHNob3VsZCBjb250YWluIHRoZSAzMi1ieXRlIFNvbGFuYSBwdWJsaWMga2V5LCBwb3NzaWJseSB3aXRoIGxlYWRpbmcgemVyb3NcbiAgICAgIGxldCByZWNpcGllbnRQdWJrZXlcbiAgICAgIFxuICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMzIpIHtcbiAgICAgICAgLy8gRGlyZWN0IGNvbnZlcnNpb24gZnJvbSAzMiBieXRlc1xuICAgICAgICByZWNpcGllbnRQdWJrZXkgPSBuZXcgKGF3YWl0IGltcG9ydCgnQHNvbGFuYS93ZWIzLmpzJykpLlB1YmxpY0tleShieXRlcylcbiAgICAgIH0gZWxzZSBpZiAoYnl0ZXMubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgLy8gVGFrZSB0aGUgbGFzdCAzMiBieXRlcyBpZiBpdCdzIGxvbmdlclxuICAgICAgICBjb25zdCBsYXN0MzJCeXRlcyA9IGJ5dGVzLnNsaWNlKC0zMilcbiAgICAgICAgcmVjaXBpZW50UHVia2V5ID0gbmV3IChhd2FpdCBpbXBvcnQoJ0Bzb2xhbmEvd2ViMy5qcycpKS5QdWJsaWNLZXkobGFzdDMyQnl0ZXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBQYWQgd2l0aCBsZWFkaW5nIHplcm9zIGlmIHNob3J0ZXJcbiAgICAgICAgY29uc3QgcGFkZGVkQnl0ZXMgPSBuZXcgVWludDhBcnJheSgzMilcbiAgICAgICAgcGFkZGVkQnl0ZXMuc2V0KGJ5dGVzLCAzMiAtIGJ5dGVzLmxlbmd0aClcbiAgICAgICAgcmVjaXBpZW50UHVia2V5ID0gbmV3IChhd2FpdCBpbXBvcnQoJ0Bzb2xhbmEvd2ViMy5qcycpKS5QdWJsaWNLZXkocGFkZGVkQnl0ZXMpXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdSZWNpcGllbnQgUHVibGljS2V5OicsIHJlY2lwaWVudFB1YmtleS50b0Jhc2U1OCgpKVxuXG4gICAgICAvLyBDcmVhdGUgdGhlIFNPTCB0cmFuc2ZlciB0cmFuc2FjdGlvblxuICAgICAgY29uc3QgeyBTeXN0ZW1Qcm9ncmFtLCBUcmFuc2FjdGlvbiB9ID0gYXdhaXQgaW1wb3J0KCdAc29sYW5hL3dlYjMuanMnKVxuXG4gICAgICAvLyBDcmVhdGUgdHJhbnNmZXIgaW5zdHJ1Y3Rpb25cbiAgICAgIGNvbnN0IHRyYW5zZmVySXggPSBTeXN0ZW1Qcm9ncmFtLnRyYW5zZmVyKHtcbiAgICAgICAgZnJvbVB1YmtleTogdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleSxcbiAgICAgICAgdG9QdWJrZXk6IHJlY2lwaWVudFB1YmtleSxcbiAgICAgICAgbGFtcG9ydHM6IGFtb3VudExhbXBvcnRzXG4gICAgICB9KVxuXG4gICAgICAvLyBDcmVhdGUgdHJhbnNhY3Rpb25cbiAgICAgIGNvbnN0IHRyYW5zZmVyVHggPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQodHJhbnNmZXJJeClcbiAgICAgIFxuICAgICAgLy8gR2V0IGZyZXNoIHJlY2VudCBibG9ja2hhc2ggcmlnaHQgYmVmb3JlIHNpZ25pbmdcbiAgICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIGZyZXNoIGJsb2NraGFzaCBmb3IgU09MIHRyYW5zZmVyLi4uJylcbiAgICAgIGNvbnN0IHsgYmxvY2toYXNoLCBsYXN0VmFsaWRCbG9ja0hlaWdodDogdHJhbnNmZXJCbG9ja0hlaWdodCB9ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgnY29uZmlybWVkJylcbiAgICAgIGNvbnNvbGUubG9nKCdGcmVzaCBTT0wgdHJhbnNmZXIgYmxvY2toYXNoOicsIGJsb2NraGFzaClcbiAgICAgIGNvbnNvbGUubG9nKCdMYXN0IHZhbGlkIGJsb2NrIGhlaWdodDonLCB0cmFuc2ZlckJsb2NrSGVpZ2h0KVxuICAgICAgXG4gICAgICB0cmFuc2ZlclR4LnJlY2VudEJsb2NraGFzaCA9IGJsb2NraGFzaFxuICAgICAgdHJhbnNmZXJUeC5mZWVQYXllciA9IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXlcblxuICAgICAgLy8gU2lnbiBhbmQgc2VuZCB0aGUgU09MIHRyYW5zZmVyIGltbWVkaWF0ZWx5XG4gICAgICBjb25zb2xlLmxvZygnU2lnbmluZyBhbmQgc2VuZGluZyBTT0wgdHJhbnNmZXIgd2l0aCBmcmVzaCBibG9ja2hhc2guLi4nKVxuICAgICAgY29uc3Qgc2lnbmVkVHJhbnNmZXJUeCA9IGF3YWl0IHRoaXMuc29sYW5hVXNlci53YWxsZXRBZGFwdGVyLnNpZ25UcmFuc2FjdGlvbih0cmFuc2ZlclR4KVxuICAgICAgdHJhbnNmZXJTaWduYXR1cmUgPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uc2VuZFJhd1RyYW5zYWN0aW9uKHNpZ25lZFRyYW5zZmVyVHguc2VyaWFsaXplKCksIHtcbiAgICAgICAgc2tpcFByZWZsaWdodDogZmFsc2UsXG4gICAgICAgIHByZWZsaWdodENvbW1pdG1lbnQ6ICdjb25maXJtZWQnXG4gICAgICB9KVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnU09MIHRyYW5zZmVyIHNlbnQ6JywgdHJhbnNmZXJTaWduYXR1cmUpXG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIHRyYW5zZmVyIGNvbmZpcm1hdGlvbiB1c2luZyB0aGUgbW9kZXJuIEFQSVxuICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XG4gICAgICAgIHNpZ25hdHVyZTogdHJhbnNmZXJTaWduYXR1cmUsXG4gICAgICAgIC4uLihhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCkpXG4gICAgICB9KVxuICAgICAgY29uc29sZS5sb2coJ1NPTCB0cmFuc2ZlciBjb25maXJtZWQnKVxuXG4gICAgICAvLyBTdGVwIDI6IFJlY29yZCB0aGUgcGF5bWVudCBpbiB0aGUgY29udHJhY3RcbiAgICAgIGNvbnNvbGUubG9nKCdTdGVwIDI6IFJlY29yZGluZyBwYXltZW50IGluIGNvbnRyYWN0Li4uJylcbiAgICAgIFxuICAgICAgLy8gQ29udmVydCBTb2xhbmEgUHVibGljS2V5IHRvIGJ5dGVzMzJcbiAgICAgIGNvbnN0IHBheWVyU29sYW5hQnl0ZXMzMiA9IHplcm9QYWRWYWx1ZShoZXhsaWZ5KHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXkudG9CeXRlcygpKSwgMzIpXG5cbiAgICAgIC8vIEdldCBjdXJyZW50IG5vbmNlXG4gICAgICBjb25zdCBub25jZSA9IE51bWJlcihhd2FpdCB0aGlzLnByb3h5QXBpLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQpKVxuICAgICAgY29uc29sZS5sb2coJ0N1cnJlbnQgbm9uY2U6Jywgbm9uY2UpXG5cbiAgICAgIC8vIFByZXBhcmUgY29udHJhY3QgY2FsbCBkYXRhXG4gICAgICBjb25zdCBpZmFjZSA9IG5ldyBldGhlcnMuSW50ZXJmYWNlKFNPTEFOQV9USVBDQVJEX0FCSSlcbiAgICAgIGNvbnN0IGRhdGEgPSBpZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoJ3BheVNvbGFuYUxpbmsnLCBbXG4gICAgICAgIGxpbmtJZCxcbiAgICAgICAgYW1vdW50TGFtcG9ydHMsXG4gICAgICAgIHBheWVyU29sYW5hQnl0ZXMzMlxuICAgICAgXSlcblxuICAgICAgLy8gQ3JlYXRlIHRyYW5zYWN0aW9uIGRhdGFcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uRGF0YSA9IHtcbiAgICAgICAgZnJvbTogdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsXG4gICAgICAgIHRvOiBDT05UUkFDVF9BRERSRVNTLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9XG5cbiAgICAgIC8vIEVzdGltYXRlIGdhc1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25HYXMgPSBhd2FpdCB0aGlzLnByb3h5QXBpLmVzdGltYXRlU2NoZWR1bGVkVHJhbnNhY3Rpb25HYXMoe1xuICAgICAgICBzb2xhbmFQYXllcjogdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleSxcbiAgICAgICAgdHJhbnNhY3Rpb25zOiBbdHJhbnNhY3Rpb25EYXRhXSxcbiAgICAgIH0pXG5cbiAgICAgIC8vIENyZWF0ZSBzY2hlZHVsZWQgdHJhbnNhY3Rpb25cbiAgICAgIGxldCB7IHNjaGVkdWxlZFRyYW5zYWN0aW9uIH0gPSBhd2FpdCB0aGlzLnByb3h5QXBpLmNyZWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgdHJhbnNhY3Rpb25HYXMsXG4gICAgICAgIHRyYW5zYWN0aW9uRGF0YSxcbiAgICAgICAgbm9uY2VcbiAgICAgIH0pXG5cbiAgICAgIC8vIEdldCBmcmVzaCByZWNlbnQgYmxvY2toYXNoIHJpZ2h0IGJlZm9yZSBzaWduaW5nXG4gICAgICBjb25zb2xlLmxvZygnR2V0dGluZyBmcmVzaCBibG9ja2hhc2ggZm9yIGNvbnRyYWN0IGNhbGwuLi4nKVxuICAgICAgY29uc3QgeyBibG9ja2hhc2g6IGNvbnRyYWN0QmxvY2toYXNoLCBsYXN0VmFsaWRCbG9ja0hlaWdodDogY29udHJhY3RCbG9ja0hlaWdodCB9ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgnY29uZmlybWVkJylcbiAgICAgIGNvbnNvbGUubG9nKCdGcmVzaCBjb250cmFjdCBjYWxsIGJsb2NraGFzaDonLCBjb250cmFjdEJsb2NraGFzaClcbiAgICAgIGNvbnNvbGUubG9nKCdMYXN0IHZhbGlkIGJsb2NrIGhlaWdodDonLCBjb250cmFjdEJsb2NrSGVpZ2h0KVxuICAgICAgXG4gICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBjb250cmFjdEJsb2NraGFzaFxuICAgICAgc2NoZWR1bGVkVHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5XG5cbiAgICAgIC8vIFNpZ24gd2l0aCB3YWxsZXQgYWRhcHRlciBpbnN0ZWFkIG9mIGtleXBhaXIgKGxpa2UgaW4gdGVzdHMpXG4gICAgICAvLyBJbiB0ZXN0czogc2NoZWR1bGVkVHJhbnNhY3Rpb24uc2lnbih7IHB1YmxpY0tleTogc29sYW5hVXNlci5wdWJsaWNLZXksIHNlY3JldEtleTogc29sYW5hVXNlci5rZXlwYWlyLnNlY3JldEtleSB9KVxuICAgICAgLy8gSW4gZnJvbnRlbmQ6IHVzZSB3YWxsZXQgYWRhcHRlciBzaWduaW5nXG4gICAgICBjb25zb2xlLmxvZygnU2lnbmluZyBjb250cmFjdCBjYWxsIHdpdGggZnJlc2ggYmxvY2toYXNoLi4uJylcbiAgICAgIGNvbnN0IHNpZ25lZFR4ID0gYXdhaXQgdGhpcy5zb2xhbmFVc2VyLndhbGxldEFkYXB0ZXIuc2lnblRyYW5zYWN0aW9uKHNjaGVkdWxlZFRyYW5zYWN0aW9uKVxuICAgICAgXG4gICAgICAvLyBTZW5kIHRyYW5zYWN0aW9uIGltbWVkaWF0ZWx5XG4gICAgICBjb25zb2xlLmxvZygnU2VuZGluZyBjb250cmFjdCBjYWxsIHRyYW5zYWN0aW9uIGltbWVkaWF0ZWx5Li4uJylcbiAgICAgIGF3YWl0IHRoaXMuY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24oc2lnbmVkVHguc2VyaWFsaXplKCksIHtcbiAgICAgICAgc2tpcFByZWZsaWdodDogZmFsc2UsXG4gICAgICAgIHByZWZsaWdodENvbW1pdG1lbnQ6ICdjb25maXJtZWQnXG4gICAgICB9KVxuXG4gICAgICAvLyBXYWl0IGZvciB0cmFuc2FjdGlvbiBleGVjdXRpb24gb24gTmVvbiBFVk1cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uU3RhdHVzID0gYXdhaXQgdGhpcy5wcm94eUFwaS53YWl0VHJhbnNhY3Rpb25UcmVlRXhlY3V0aW9uKFxuICAgICAgICB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCwgXG4gICAgICAgIG5vbmNlLCBcbiAgICAgICAgNjAwMDBcbiAgICAgIClcblxuICAgICAgaWYgKHRyYW5zYWN0aW9uU3RhdHVzLmxlbmd0aCA9PT0gMCB8fCB0cmFuc2FjdGlvblN0YXR1c1swXS5zdGF0dXMgIT09ICdTdWNjZXNzJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0NvbnRyYWN0IHBheW1lbnQgcmVjb3JkaW5nIGZhaWxlZCwgYnV0IFNPTCB0cmFuc2ZlciBzdWNjZWVkZWQnKVxuICAgICAgICBjb25zb2xlLmxvZygnVHJhbnNmZXIgc2lnbmF0dXJlOicsIHRyYW5zZmVyU2lnbmF0dXJlKVxuICAgICAgICAvLyBEb24ndCB0aHJvdyBlcnJvciAtIHRoZSBwYXltZW50IHdlbnQgdGhyb3VnaCBldmVuIGlmIHJlY29yZGluZyBmYWlsZWRcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ1BheW1lbnQgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSEnKVxuICAgICAgY29uc29sZS5sb2coJ1NPTCB0cmFuc2ZlcjonLCB0cmFuc2ZlclNpZ25hdHVyZSlcbiAgICAgIGNvbnNvbGUubG9nKCdDb250cmFjdCByZWNvcmQ6JywgdHJhbnNhY3Rpb25TdGF0dXNbMF0/LnRyYW5zYWN0aW9uSGFzaClcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHhIYXNoOiB0cmFuc2FjdGlvblN0YXR1c1swXT8udHJhbnNhY3Rpb25IYXNoIHx8ICdjb250cmFjdC1yZWNvcmRpbmctZmFpbGVkJyxcbiAgICAgICAgdHJhbnNmZXJTaWduYXR1cmVcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXlpbmcgbGluazonLCBlcnJvcilcbiAgICAgIGlmICh0cmFuc2ZlclNpZ25hdHVyZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnTm90ZTogU09MIHRyYW5zZmVyIG1heSBoYXZlIHN1Y2NlZWRlZDonLCB0cmFuc2ZlclNpZ25hdHVyZSlcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlYWN0aXZhdGUgYSBwYXltZW50IGxpbmtcbiAgICovXG4gIGFzeW5jIGRlYWN0aXZhdGVMaW5rKGxpbmtJZDogc3RyaW5nKTogUHJvbWlzZTx7IHR4SGFzaDogc3RyaW5nIH0+IHtcbiAgICBpZiAoIXRoaXMuc29sYW5hVXNlciB8fCAhdGhpcy5jb250cmFjdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgY29ubmVjdCB3YWxsZXQgZmlyc3QnKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgY3VycmVudCBub25jZVxuICAgICAgY29uc3Qgbm9uY2UgPSBOdW1iZXIoYXdhaXQgdGhpcy5wcm94eUFwaS5nZXRUcmFuc2FjdGlvbkNvdW50KHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0KSlcbiAgICAgIGNvbnNvbGUubG9nKCdDdXJyZW50IG5vbmNlOicsIG5vbmNlKVxuXG4gICAgICAvLyBQcmVwYXJlIGNvbnRyYWN0IGNhbGwgZGF0YVxuICAgICAgY29uc3QgaWZhY2UgPSBuZXcgZXRoZXJzLkludGVyZmFjZShTT0xBTkFfVElQQ0FSRF9BQkkpXG4gICAgICBjb25zdCBkYXRhID0gaWZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKCdkZWFjdGl2YXRlU29sYW5hTGluaycsIFtsaW5rSWRdKVxuXG4gICAgICAvLyBDcmVhdGUgdHJhbnNhY3Rpb24gZGF0YVxuICAgICAgY29uc3QgdHJhbnNhY3Rpb25EYXRhID0ge1xuICAgICAgICBmcm9tOiB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCxcbiAgICAgICAgdG86IENPTlRSQUNUX0FERFJFU1MsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH1cblxuICAgICAgLy8gRXN0aW1hdGUgZ2FzXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkdhcyA9IGF3YWl0IHRoaXMucHJveHlBcGkuZXN0aW1hdGVTY2hlZHVsZWRUcmFuc2FjdGlvbkdhcyh7XG4gICAgICAgIHNvbGFuYVBheWVyOiB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LFxuICAgICAgICB0cmFuc2FjdGlvbnM6IFt0cmFuc2FjdGlvbkRhdGFdLFxuICAgICAgfSlcblxuICAgICAgLy8gQ3JlYXRlIHNjaGVkdWxlZCB0cmFuc2FjdGlvblxuICAgICAgbGV0IHsgc2NoZWR1bGVkVHJhbnNhY3Rpb24gfSA9IGF3YWl0IHRoaXMucHJveHlBcGkuY3JlYXRlU2NoZWR1bGVkVHJhbnNhY3Rpb24oe1xuICAgICAgICB0cmFuc2FjdGlvbkdhcyxcbiAgICAgICAgdHJhbnNhY3Rpb25EYXRhLFxuICAgICAgICBub25jZVxuICAgICAgfSlcblxuICAgICAgLy8gR2V0IGZyZXNoIHJlY2VudCBibG9ja2hhc2ggcmlnaHQgYmVmb3JlIHNpZ25pbmdcbiAgICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIGZyZXNoIGJsb2NraGFzaCBmb3IgZGVhY3RpdmF0ZSB0cmFuc2FjdGlvbi4uLicpXG4gICAgICBjb25zdCB7IGJsb2NraGFzaCwgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IGRlYWN0aXZhdGVCbG9ja0hlaWdodCB9ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgnY29uZmlybWVkJylcbiAgICAgIGNvbnNvbGUubG9nKCdGcmVzaCBkZWFjdGl2YXRlIGJsb2NraGFzaDonLCBibG9ja2hhc2gpXG4gICAgICBjb25zb2xlLmxvZygnTGFzdCB2YWxpZCBibG9jayBoZWlnaHQ6JywgZGVhY3RpdmF0ZUJsb2NrSGVpZ2h0KVxuICAgICAgXG4gICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBibG9ja2hhc2hcbiAgICAgIHNjaGVkdWxlZFRyYW5zYWN0aW9uLmZlZVBheWVyID0gdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleVxuXG4gICAgICAvLyBTaWduIHdpdGggd2FsbGV0IGFkYXB0ZXIgaW5zdGVhZCBvZiBrZXlwYWlyIChsaWtlIGluIHRlc3RzKVxuICAgICAgLy8gSW4gdGVzdHM6IHNjaGVkdWxlZFRyYW5zYWN0aW9uLnNpZ24oeyBwdWJsaWNLZXk6IHNvbGFuYVVzZXIucHVibGljS2V5LCBzZWNyZXRLZXk6IHNvbGFuYVVzZXIua2V5cGFpci5zZWNyZXRLZXkgfSlcbiAgICAgIC8vIEluIGZyb250ZW5kOiB1c2Ugd2FsbGV0IGFkYXB0ZXIgc2lnbmluZ1xuICAgICAgY29uc29sZS5sb2coJ1NpZ25pbmcgZGVhY3RpdmF0ZSB0cmFuc2FjdGlvbiB3aXRoIGZyZXNoIGJsb2NraGFzaC4uLicpXG4gICAgICBjb25zdCBzaWduZWRUeCA9IGF3YWl0IHRoaXMuc29sYW5hVXNlci53YWxsZXRBZGFwdGVyLnNpZ25UcmFuc2FjdGlvbihzY2hlZHVsZWRUcmFuc2FjdGlvbilcbiAgICAgIFxuICAgICAgLy8gU2VuZCB0cmFuc2FjdGlvbiBpbW1lZGlhdGVseVxuICAgICAgY29uc29sZS5sb2coJ1NlbmRpbmcgZGVhY3RpdmF0ZSB0cmFuc2FjdGlvbiBpbW1lZGlhdGVseS4uLicpXG4gICAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uc2VuZFJhd1RyYW5zYWN0aW9uKHNpZ25lZFR4LnNlcmlhbGl6ZSgpLCB7XG4gICAgICAgIHNraXBQcmVmbGlnaHQ6IGZhbHNlLFxuICAgICAgICBwcmVmbGlnaHRDb21taXRtZW50OiAnY29uZmlybWVkJ1xuICAgICAgfSlcblxuICAgICAgLy8gV2FpdCBmb3IgdHJhbnNhY3Rpb24gZXhlY3V0aW9uXG4gICAgICBjb25zdCB0cmFuc2FjdGlvblN0YXR1cyA9IGF3YWl0IHRoaXMucHJveHlBcGkud2FpdFRyYW5zYWN0aW9uVHJlZUV4ZWN1dGlvbihcbiAgICAgICAgdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsIFxuICAgICAgICBub25jZSwgXG4gICAgICAgIDYwMDAwXG4gICAgICApXG5cbiAgICAgIGlmICh0cmFuc2FjdGlvblN0YXR1cy5sZW5ndGggPT09IDAgfHwgdHJhbnNhY3Rpb25TdGF0dXNbMF0uc3RhdHVzICE9PSAnU3VjY2VzcycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWFjdGl2YXRpb24gdHJhbnNhY3Rpb24gZmFpbGVkIHRvIGV4ZWN1dGUgb24gTmVvbiBFVk0nKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eEhhc2g6IHRyYW5zYWN0aW9uU3RhdHVzWzBdLnRyYW5zYWN0aW9uSGFzaFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNoYXJlYWJsZSBVUkwgZm9yIGEgcGF5bWVudCBsaW5rXG4gICAqL1xuICBjcmVhdGVQYXltZW50VVJMKGxpbmtJZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn0/cGF5PSR7bGlua0lkfWBcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IGxpbmsgSUQgZnJvbSBVUkxcbiAgICovXG4gIHN0YXRpYyBleHRyYWN0TGlua0lkRnJvbVVSTCh1cmw6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1cmxPYmogPSBuZXcgVVJMKHVybClcbiAgICAgIHJldHVybiB1cmxPYmouc2VhcmNoUGFyYW1zLmdldCgncGF5JylcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdXNlcidzIEVWTSBhZGRyZXNzIGRlcml2ZWQgZnJvbSBTb2xhbmEgcHVibGljIGtleVxuICAgKi9cbiAgZ2V0VXNlckVWTUFkZHJlc3MoKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuc29sYW5hVXNlcj8ubmVvbldhbGxldCB8fCBudWxsXG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IHNvbGFuYU5hdGl2ZUNvbnRyYWN0ID0gbmV3IFNvbGFuYU5hdGl2ZUNvbnRyYWN0KCkiXSwibmFtZXMiOlsiQ29ubmVjdGlvbiIsIlB1YmxpY0tleSIsIk5lb25Qcm94eVJwY0FwaSIsImNyZWF0ZUJhbGFuY2VBY2NvdW50SW5zdHJ1Y3Rpb24iLCJTb2xhbmFOZW9uQWNjb3VudCIsImV0aGVycyIsImhleGxpZnkiLCJ6ZXJvUGFkVmFsdWUiLCJDb250cmFjdEFCSSIsIlNPTEFOQV9USVBDQVJEX0FCSSIsIkNPTlRSQUNUX0FERFJFU1MiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfVElQQ0FSRF9DT05UUkFDVF9BRERSRVNTIiwiTkVPTl9DT1JFX1JQQ19VUkwiLCJORVhUX1BVQkxJQ19ORU9OX1JQQ19VUkwiLCJORU9OX1BST1hZX1JQQ19VUkwiLCJTT0xBTkFfUlBDX1VSTCIsIlNvbGFuYU5hdGl2ZUNvbnRyYWN0IiwiZ2V0Q2hhaW5JZCIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJpZCIsImpzb25ycGMiLCJwYXJhbXMiLCJyZXN1bHQiLCJqc29uIiwicGFyc2VJbnQiLCJlcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwiZ2V0TmVvbkV2bVByb2dyYW0iLCJpbml0UmVzdWx0IiwibG9nIiwiS2V5cGFpciIsInRlbXBLZXlwYWlyIiwiZ2VuZXJhdGUiLCJwcm94eUFwaSIsImluaXQiLCJzb2xhbmFVc2VyIiwibmVvbkV2bVByb2dyYW0iLCJFcnJvciIsInByb2dyYW1BZGRyZXNzIiwicHJvZ3JhbUlkIiwiYXBpRXJyb3IiLCJpbml0V2l0aFNvbGFuYVdhbGxldCIsIndhbGxldEFkYXB0ZXIiLCJwdWJsaWNLZXkiLCJ0b0Jhc2U1OCIsImNoYWluSWQiLCJ0ZW1wUmVzdWx0IiwiYWN0dWFsU29sYW5hTmVvbkFjY291bnQiLCJ0b2tlbk1pbnQiLCJ3YWxsZXRTb2xhbmFVc2VyIiwibmVvbldhbGxldCIsImJhbGFuY2VBZGRyZXNzIiwicmVhZE9ubHlQcm92aWRlciIsIkpzb25ScGNQcm92aWRlciIsImNvbnRyYWN0IiwiQ29udHJhY3QiLCJ0eENvdW50IiwiZ2V0VHJhbnNhY3Rpb25Db3VudCIsInZlcmlmeUVycm9yIiwiY29kZSIsImdldENvZGUiLCJsZW5ndGgiLCJjcmVhdGVQYXltZW50TGluayIsInN1Z2dlc3RlZEFtb3VudFNPTCIsImlzRmxleGlibGUiLCJkZXNjcmlwdGlvbiIsImFtb3VudExhbXBvcnRzIiwiTWF0aCIsImZsb29yIiwicmVjZWlwdCIsIm5vbmNlIiwiTnVtYmVyIiwiaWZhY2UiLCJJbnRlcmZhY2UiLCJkYXRhIiwiZW5jb2RlRnVuY3Rpb25EYXRhIiwidHJhbnNhY3Rpb25EYXRhIiwiZnJvbSIsInRvIiwidHJhbnNhY3Rpb25HYXMiLCJlc3RpbWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uR2FzIiwic29sYW5hUGF5ZXIiLCJ0cmFuc2FjdGlvbnMiLCJzY2hlZHVsZWRUcmFuc2FjdGlvbiIsImNyZWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uIiwiYWNjb3VudCIsImNvbm5lY3Rpb24iLCJnZXRBY2NvdW50SW5mbyIsImluc3RydWN0aW9ucyIsInVuc2hpZnQiLCJibG9ja2hhc2giLCJnZXRMYXRlc3RCbG9ja2hhc2giLCJyZWNlbnRCbG9ja2hhc2giLCJmZWVQYXllciIsInNpZ25lZFR4Iiwic2lnblRyYW5zYWN0aW9uIiwic2lnbmF0dXJlIiwic2VuZFJhd1RyYW5zYWN0aW9uIiwic2VyaWFsaXplIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwidHJhbnNhY3Rpb25TdGF0dXMiLCJ3YWl0VHJhbnNhY3Rpb25UcmVlRXhlY3V0aW9uIiwidHhTdGF0dXMiLCJzdGF0dXMiLCJ0cmFuc2FjdGlvbkhhc2giLCJsaW5rSWQiLCJ0eEhhc2giLCJnZXRUcmFuc2FjdGlvblJlY2VpcHQiLCJsb2dzIiwibG9nc0Jsb29tIiwiY29udHJhY3RBZGRyZXNzIiwiZ2FzVXNlZCIsImVmZmVjdGl2ZUdhc1ByaWNlIiwibmVvblJhd1RyYW5zYWN0aW9uIiwiYWxsTmVvbkxvZ3MiLCJzb2xhbmFUcmFuc2FjdGlvbnMiLCJzb2xUeCIsInNvbGFuYUluc3RydWN0aW9ucyIsImluc3RydWN0aW9uIiwibmVvbkxvZ3MiLCJwdXNoIiwiYWRkcmVzcyIsInRvTG93ZXJDYXNlIiwiZXRoZXJzTG9nIiwidG9waWNzIiwicGFyc2VkTG9nIiwicGFyc2VMb2ciLCJuYW1lIiwiYXJncyIsImUiLCJ0ZXN0RGF0YSIsImdldFNvbGFuYVBheW1lbnRMaW5rIiwicmVhZEVycm9yIiwibmVvblJldmVydERhdGEiLCJyZXZlcnRSZWFzb24iLCJ0b1V0ZjhTdHJpbmciLCJkZWNvZGVFcnJvciIsImlzUmVnaXN0ZXJlZCIsImlzU29sYW5hVXNlciIsInJlZ2lzdHJhdGlvbkVycm9yIiwiaW5pdFJlYWRPbmx5Q29udHJhY3QiLCJnZXRQYXltZW50TGluayIsInBheW1lbnRMaW5rIiwiZXZtQ3JlYXRvciIsInNvbGFuYUNyZWF0b3IiLCJhbW91bnQiLCJpc0FjdGl2ZSIsInRvdGFsUmVjZWl2ZWQiLCJwYXltZW50Q291bnQiLCJCaWdJbnQiLCJzdGFydHNXaXRoIiwiZ2V0VXNlckxpbmtzIiwidXNlckVWTUFkZHJlc3MiLCJnZXRVc2VyU29sYW5hTGlua3MiLCJwYXlMaW5rIiwiYW1vdW50U09MIiwibGlua0RhdGEiLCJ0cmFuc2ZlclNpZ25hdHVyZSIsImhleFN0cmluZyIsInNsaWNlIiwiYnl0ZXMiLCJVaW50OEFycmF5IiwibWF0Y2giLCJtYXAiLCJieXRlIiwicmVjaXBpZW50UHVia2V5IiwibGFzdDMyQnl0ZXMiLCJwYWRkZWRCeXRlcyIsInNldCIsIlN5c3RlbVByb2dyYW0iLCJUcmFuc2FjdGlvbiIsInRyYW5zZmVySXgiLCJ0cmFuc2ZlciIsImZyb21QdWJrZXkiLCJ0b1B1YmtleSIsImxhbXBvcnRzIiwidHJhbnNmZXJUeCIsImFkZCIsImxhc3RWYWxpZEJsb2NrSGVpZ2h0IiwidHJhbnNmZXJCbG9ja0hlaWdodCIsInNpZ25lZFRyYW5zZmVyVHgiLCJza2lwUHJlZmxpZ2h0IiwicHJlZmxpZ2h0Q29tbWl0bWVudCIsImNvbmZpcm1UcmFuc2FjdGlvbiIsInBheWVyU29sYW5hQnl0ZXMzMiIsInRvQnl0ZXMiLCJjb250cmFjdEJsb2NraGFzaCIsImNvbnRyYWN0QmxvY2tIZWlnaHQiLCJkZWFjdGl2YXRlTGluayIsImRlYWN0aXZhdGVCbG9ja0hlaWdodCIsImNyZWF0ZVBheW1lbnRVUkwiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIm9yaWdpbiIsImV4dHJhY3RMaW5rSWRGcm9tVVJMIiwidXJsIiwidXJsT2JqIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwiZ2V0IiwiZ2V0VXNlckVWTUFkZHJlc3MiLCJjb25zdHJ1Y3RvciIsInNvbGFuYU5hdGl2ZUNvbnRyYWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/solana-native-contract.ts\n"));

/***/ })

});