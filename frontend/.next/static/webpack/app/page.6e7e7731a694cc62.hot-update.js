"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/solana-native-contract.ts":
/*!*****************************************!*\
  !*** ./utils/solana-native-contract.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaNativeContract: function() { return /* binding */ SolanaNativeContract; },\n/* harmony export */   solanaNativeContract: function() { return /* binding */ solanaNativeContract; }\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var _neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @neonevm/solana-sign */ \"(app-pages-browser)/./node_modules/@neonevm/solana-sign/dist/esm/index.mjs\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/units.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/utf8.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _contractABI_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contractABI.json */ \"(app-pages-browser)/./utils/contractABI.json\");\n\n\n\n\n// Use the actual deployed contract ABI\nconst SOLANA_TIPCARD_ABI = _contractABI_json__WEBPACK_IMPORTED_MODULE_2__;\nconst CONTRACT_ADDRESS = \"0xCFE03c7c67456D094C0162F9030393FC2cCc40Cb\" || 0;\nconst NEON_CORE_RPC_URL = \"https://devnet.neonevm.org\" || 0;\nconst NEON_PROXY_RPC_URL = \"\".concat(NEON_CORE_RPC_URL, \"/sol\");\nconst SOLANA_RPC_URL = \"https://api.devnet.solana.com\";\nclass SolanaNativeContract {\n    /**\n   * Initialize with Solana wallet using the recommended SolanaNeonAccount approach\n   */ async initWithSolanaWallet(walletAdapter) {\n        if (!walletAdapter.publicKey) {\n            throw new Error(\"Wallet not connected\");\n        }\n        try {\n            var _this_solanaUser_balanceAddress, _this_solanaUser_balanceAddress1;\n            console.log(\"\\uD83D\\uDD27 Using recommended SolanaNeonAccount approach...\");\n            console.log(\"Wallet public key:\", walletAdapter.publicKey.toBase58());\n            // Use proxyApi.init with just the public key (like demo)\n            const { provider, chainId, solanaUser, tokenMintAddress, programAddress } = await this.proxyApi.init(walletAdapter.publicKey);\n            console.log(\"- Chain ID:\", chainId);\n            console.log(\"- Neon EVM Program:\", programAddress.toBase58());\n            // Store the result with wallet adapter for signing\n            this.chainId = chainId;\n            this.solanaUser = {\n                ...solanaUser,\n                walletAdapter: walletAdapter // Add wallet adapter for signing\n            };\n            // Create balance address if it doesn't exist (using SolanaNeonAccount approach)\n            if (!this.solanaUser.balanceAddress) {\n                const { SolanaNeonAccount } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @neonevm/solana-sign */ \"(app-pages-browser)/./node_modules/@neonevm/solana-sign/dist/esm/index.mjs\"));\n                const account = new SolanaNeonAccount(this.solanaUser.publicKey, this.solanaUser.neonEvmProgram, this.solanaUser.tokenMint, this.solanaUser.chainId);\n                this.solanaUser.balanceAddress = account.balanceAddress;\n            }\n            console.log(\"✅ Wallet initialized using SolanaNeonAccount approach!\");\n            console.log(\"\\uD83D\\uDCCD Connected wallet public key:\", walletAdapter.publicKey.toBase58());\n            console.log(\"\\uD83D\\uDCCD Solana user public key:\", this.solanaUser.publicKey.toBase58());\n            console.log(\"\\uD83D\\uDCCD Derived EVM address:\", this.solanaUser.neonWallet);\n            console.log(\"\\uD83D\\uDCB0 Balance address:\", ((_this_solanaUser_balanceAddress = this.solanaUser.balanceAddress) === null || _this_solanaUser_balanceAddress === void 0 ? void 0 : _this_solanaUser_balanceAddress.toBase58()) || \"Not available\");\n            console.log(\"\\uD83D\\uDD0D Full solanaUser object:\", this.solanaUser);\n            // Verify they match\n            if (walletAdapter.publicKey.toBase58() === this.solanaUser.publicKey.toBase58()) {\n                console.log(\"✅ Wallet public keys match correctly!\");\n            } else {\n                console.error(\"❌ MISMATCH: Wallet adapter and solana user have different public keys!\");\n                console.error(\"Wallet adapter:\", walletAdapter.publicKey.toBase58());\n                console.error(\"Solana user:\", this.solanaUser.publicKey.toBase58());\n            }\n            console.log(\"\\uD83D\\uDCB0 Final balance address:\", ((_this_solanaUser_balanceAddress1 = this.solanaUser.balanceAddress) === null || _this_solanaUser_balanceAddress1 === void 0 ? void 0 : _this_solanaUser_balanceAddress1.toBase58()) || \"Still not available\");\n            // Create contract instance\n            const readOnlyProvider = new ethers__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider(NEON_CORE_RPC_URL);\n            this.contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.Contract(CONTRACT_ADDRESS, SOLANA_TIPCARD_ABI, readOnlyProvider);\n            // Verify the derived EVM address is valid\n            console.log(\"\\uD83D\\uDD0D Verifying derived EVM address...\");\n            try {\n                // Check if this EVM address has been used before (has transaction history)\n                const txCount = await readOnlyProvider.getTransactionCount(this.solanaUser.neonWallet);\n                console.log(\"\\uD83D\\uDCCA EVM address transaction count:\", txCount);\n                if (txCount > 0) {\n                    console.log(\"✅ This EVM address has transaction history - it exists on-chain!\");\n                } else {\n                    console.log(\"ℹ️ This EVM address is new (no transaction history yet)\");\n                    console.log(\"ℹ️ The address will be registered on-chain when first transaction is made\");\n                }\n            } catch (verifyError) {\n                console.log(\"⚠️ Could not verify EVM address:\", verifyError);\n            }\n            // Verify contract is deployed at this address\n            try {\n                console.log(\"Verifying contract at address:\", CONTRACT_ADDRESS);\n                const code = await readOnlyProvider.getCode(CONTRACT_ADDRESS);\n                console.log(\"Contract code length:\", code.length);\n                if (code === \"0x\") {\n                    console.warn(\"⚠️ No contract code found at address:\", CONTRACT_ADDRESS);\n                    console.log(\"This might mean the contract is not deployed or address is incorrect\");\n                } else {\n                    console.log(\"✅ Contract found at address\");\n                    console.log(\"✅ Contract found and ready for transactions\");\n                }\n            } catch (verifyError) {\n                console.warn(\"Failed to verify contract:\", verifyError);\n            }\n        } catch (error) {\n            console.error(\"Failed to initialize Solana Native SDK:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Create a payment link using Solana Native SDK\n   */ async createPaymentLink(suggestedAmountSOL, isFlexible, description) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        // Convert SOL to lamports (1 SOL = 1e9 lamports)\n        const amountLamports = Math.floor(suggestedAmountSOL * 1e9);\n        try {\n            var _this_solanaUser_walletAdapter_publicKey, _scheduledTransaction_feePayer, _this_solanaUser_walletAdapter_publicKey1, _receipt_result, _receipt_result1, _receipt_result2, _receipt_result_logs, _receipt_result3, _receipt_result4, _receipt_result5, _receipt_result6, _receipt_result7, _receipt_result8, _receipt_result9;\n            // Get current nonce (exactly like working examples)\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Current nonce:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"createSolanaPaymentLink\", [\n                amountLamports,\n                isFlexible,\n                description\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Debug: Check what solanaPayer we're using\n            console.log(\"\\uD83D\\uDD0D Transaction creation debug:\");\n            console.log(\"- solanaPayer for gas estimation:\", this.solanaUser.publicKey.toBase58());\n            console.log(\"- from address in transactionData:\", transactionData.from);\n            console.log(\"- nonce:\", nonce);\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            console.log(\"Gas estimation completed\");\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            console.log(\"Scheduled transaction created\");\n            // Check if balance account exists, if not create it\n            const account = await this.connection.getAccountInfo(this.solanaUser.balanceAddress);\n            if (account === null) {\n                scheduledTransaction.instructions.unshift((0,_neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__.createBalanceAccountInstruction)(this.solanaUser.neonEvmProgram, this.solanaUser.publicKey, this.solanaUser.neonWallet, this.chainId));\n            }\n            // Sign and send transaction using exact test pattern\n            const { blockhash } = await this.connection.getLatestBlockhash();\n            scheduledTransaction.recentBlockhash = blockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            console.log(\"\\uD83D\\uDD0D Pre-signing debug:\");\n            console.log(\"- Connected wallet:\", (_this_solanaUser_walletAdapter_publicKey = this.solanaUser.walletAdapter.publicKey) === null || _this_solanaUser_walletAdapter_publicKey === void 0 ? void 0 : _this_solanaUser_walletAdapter_publicKey.toBase58());\n            console.log(\"- Solana user:\", this.solanaUser.publicKey.toBase58());\n            console.log(\"- Transaction feePayer:\", (_scheduledTransaction_feePayer = scheduledTransaction.feePayer) === null || _scheduledTransaction_feePayer === void 0 ? void 0 : _scheduledTransaction_feePayer.toBase58());\n            console.log(\"- Are they the same?\", ((_this_solanaUser_walletAdapter_publicKey1 = this.solanaUser.walletAdapter.publicKey) === null || _this_solanaUser_walletAdapter_publicKey1 === void 0 ? void 0 : _this_solanaUser_walletAdapter_publicKey1.toBase58()) === this.solanaUser.publicKey.toBase58());\n            // Sign the transaction using wallet adapter (frontend approach)\n            console.log(\"\\uD83D\\uDCDD Signing transaction with wallet adapter...\");\n            const signedTransaction = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            console.log(\"Submitting transaction...\");\n            const signature = await this.connection.sendRawTransaction(signedTransaction.serialize());\n            console.log(\"✅ Transaction submitted!\");\n            console.log(\"\\uD83D\\uDD17 Signature:\", signature);\n            // Wait a bit for processing (like working examples)\n            console.log(\"Waiting for confirmation...\");\n            await new Promise((resolve)=>setTimeout(resolve, 5000));\n            // Wait for confirmation\n            console.log(\"   Waiting for payment confirmation...\");\n            await new Promise((resolve)=>setTimeout(resolve, 5000));\n            // Check transaction status\n            try {\n                var _confirmation_value;\n                const confirmation = await connection.getSignatureStatus(signature);\n                if ((_confirmation_value = confirmation.value) === null || _confirmation_value === void 0 ? void 0 : _confirmation_value.confirmationStatus) {\n                    console.log(\"✅ Payment status: \".concat(confirmation.value.confirmationStatus));\n                }\n                // Try to get payment details\n                try {\n                    console.log(\"   Getting payment transaction details...\");\n                    const neonTxResponse = await fetch(\"https://devnet.neonevm.org/sol\", {\n                        method: \"POST\",\n                        headers: {\n                            \"Content-Type\": \"application/json\"\n                        },\n                        body: JSON.stringify({\n                            method: \"neon_getTransactionBySenderNonce\",\n                            params: [\n                                solanaUser2.neonWallet,\n                                nonce\n                            ],\n                            id: 1,\n                            jsonrpc: \"2.0\"\n                        })\n                    });\n                    const neonTxResult = await neonTxResponse.json();\n                    if (neonTxResult.result && neonTxResult.result.hash) {\n                        console.log(\"✅ Neon EVM payment hash: \".concat(neonTxResult.result.hash));\n                        // Check updated link details\n                        try {\n                            const linkDetails = await solanaTipCard.getSolanaPaymentLink(createdLinkId);\n                            console.log(\"\\uD83C\\uDF89 Updated Payment Link Details:\");\n                            console.log(\"   Link ID: \".concat(createdLinkId));\n                            console.log(\"   Total Received: \".concat(ethers__WEBPACK_IMPORTED_MODULE_6__.formatUnits(linkDetails.totalReceived, 9), \" SOL\"));\n                            console.log(\"   Payment Count: \".concat(linkDetails.paymentCount));\n                            console.log(\"   Active: \".concat(linkDetails.isActive));\n                        } catch (linkError) {\n                            console.log(\"ℹ️ Could not get updated link details: \".concat(linkError.message));\n                        }\n                    } else {\n                        console.log(\"ℹ️ Neon EVM payment transaction not found yet (may still be processing)\");\n                    }\n                } catch (neonError) {\n                    console.log(\"ℹ️ Could not get Neon payment details: \".concat(neonError.message));\n                }\n            } catch (confirmError) {\n                console.log(\"ℹ️ Payment confirmation check: \".concat(confirmError.message));\n            }\n            console.log(\"\\uD83C\\uDF89 Payment transaction completed!\");\n            // Wait for transaction execution on Neon EVM\n            const transactionStatus = await this.proxyApi.waitTransactionTreeExecution(this.solanaUser.neonWallet, nonce, 60000 // 60 second timeout\n            );\n            console.log(\"Transaction status:\", transactionStatus);\n            if (transactionStatus.length === 0) {\n                throw new Error(\"No transaction status returned - transaction may not have been processed\");\n            }\n            const txStatus = transactionStatus[0];\n            console.log(\"Transaction execution status:\", txStatus.status);\n            if (txStatus.status === \"NotStarted\") {\n                console.warn(\"⚠️ Transaction was scheduled but not yet executed by Neon operators\");\n                console.log(\"This is expected - Neon will process it eventually\");\n                console.log(\"Transaction hash:\", txStatus.transactionHash);\n                // Since we have a transaction hash, proceed with using it as the payment link ID\n                // The transaction will be processed by Neon operators eventually\n                console.log(\"✅ Using transaction hash as payment link ID - Neon will process it when ready\");\n                return {\n                    linkId: txStatus.transactionHash,\n                    txHash: txStatus.transactionHash\n                };\n            } else if (txStatus.status === \"Failed\") {\n                throw new Error(\"Transaction execution failed. Hash: \".concat(txStatus.transactionHash));\n            } else if (txStatus.status !== \"Success\") {\n                console.warn(\"Transaction finished with unexpected status:\", txStatus.status);\n                // Still try to return the transaction hash in case it's usable\n                return {\n                    linkId: txStatus.transactionHash,\n                    txHash: txStatus.transactionHash\n                };\n            }\n            const txHash = transactionStatus[0].transactionHash;\n            console.log(\"Transaction hash:\", txHash);\n            // Get the link ID from transaction receipt\n            const receipt = await this.proxyApi.getTransactionReceipt(txHash);\n            console.log(\"Full transaction receipt:\", JSON.stringify(receipt, null, 2));\n            let linkId = \"\";\n            // Check if the transaction was successful\n            if (((_receipt_result = receipt.result) === null || _receipt_result === void 0 ? void 0 : _receipt_result.status) !== \"0x1\") {\n                var _receipt_result10;\n                throw new Error(\"Transaction failed - status: \" + ((_receipt_result10 = receipt.result) === null || _receipt_result10 === void 0 ? void 0 : _receipt_result10.status));\n            }\n            // Enhanced debugging of the receipt structure\n            console.log(\"Receipt status:\", (_receipt_result1 = receipt.result) === null || _receipt_result1 === void 0 ? void 0 : _receipt_result1.status);\n            console.log(\"Receipt logs array:\", (_receipt_result2 = receipt.result) === null || _receipt_result2 === void 0 ? void 0 : _receipt_result2.logs);\n            console.log(\"Receipt logs length:\", (_receipt_result3 = receipt.result) === null || _receipt_result3 === void 0 ? void 0 : (_receipt_result_logs = _receipt_result3.logs) === null || _receipt_result_logs === void 0 ? void 0 : _receipt_result_logs.length);\n            console.log(\"Receipt logsBloom:\", (_receipt_result4 = receipt.result) === null || _receipt_result4 === void 0 ? void 0 : _receipt_result4.logsBloom);\n            console.log(\"Receipt contractAddress:\", (_receipt_result5 = receipt.result) === null || _receipt_result5 === void 0 ? void 0 : _receipt_result5.contractAddress);\n            console.log(\"Receipt gasUsed:\", (_receipt_result6 = receipt.result) === null || _receipt_result6 === void 0 ? void 0 : _receipt_result6.gasUsed);\n            console.log(\"Receipt effectiveGasPrice:\", (_receipt_result7 = receipt.result) === null || _receipt_result7 === void 0 ? void 0 : _receipt_result7.effectiveGasPrice);\n            // Check if there's a different location for logs\n            console.log(\"Raw transaction data:\", (_receipt_result8 = receipt.result) === null || _receipt_result8 === void 0 ? void 0 : _receipt_result8.neonRawTransaction);\n            // Note: getTransaction method not available on NeonProxyRpcApi\n            // Transaction details are already in the receipt\n            // Extract all neonLogs from solanaTransactions\n            const allNeonLogs = [];\n            if ((_receipt_result9 = receipt.result) === null || _receipt_result9 === void 0 ? void 0 : _receipt_result9.solanaTransactions) {\n                for (const solTx of receipt.result.solanaTransactions){\n                    if (solTx.solanaInstructions) {\n                        for (const instruction of solTx.solanaInstructions){\n                            if (instruction.neonLogs && instruction.neonLogs.length > 0) {\n                                allNeonLogs.push(...instruction.neonLogs);\n                            }\n                        }\n                    }\n                }\n            }\n            console.log(\"Found\", allNeonLogs.length, \"neonLogs to parse\");\n            // Try to parse logs for the SolanaLinkCreated event\n            if (allNeonLogs.length > 0) {\n                for (const log of allNeonLogs){\n                    try {\n                        console.log(\"Trying to parse neonLog:\", log);\n                        // Check if this log is from our contract\n                        if (log.address.toLowerCase() === CONTRACT_ADDRESS.toLowerCase()) {\n                            console.log(\"Log is from our contract, parsing...\");\n                            // Convert the log to the format expected by ethers\n                            const ethersLog = {\n                                address: log.address,\n                                data: log.data,\n                                topics: log.topics\n                            };\n                            const parsedLog = iface.parseLog(ethersLog);\n                            console.log(\"Parsed log:\", parsedLog);\n                            if ((parsedLog === null || parsedLog === void 0 ? void 0 : parsedLog.name) === \"SolanaLinkCreated\") {\n                                linkId = parsedLog.args.linkId;\n                                console.log(\"✅ Found link ID from SolanaLinkCreated event:\", linkId);\n                                break;\n                            }\n                        } else {\n                            console.log(\"Log from different contract:\", log.address);\n                        }\n                    } catch (e) {\n                        console.log(\"Failed to parse neonLog:\", e);\n                    // Skip logs that can't be parsed\n                    }\n                }\n            } else {\n                console.warn(\"No neonLogs found in transaction receipt!\");\n                console.log(\"This might indicate:\");\n                console.log(\"1. The contract call failed silently\");\n                console.log(\"2. The contract is not at the expected address\");\n                console.log(\"3. The contract function call reverted\");\n                console.log(\"4. Events are not being emitted properly\");\n                // Try calling the contract read method to see if data was actually stored\n                try {\n                    console.log(\"Attempting to read payment link using transaction hash as ID...\");\n                    const testData = await this.contract.getSolanaPaymentLink(txHash);\n                    console.log(\"Contract read result:\", testData);\n                } catch (readError) {\n                    console.log(\"Contract read failed:\", readError);\n                }\n            }\n            // If we couldn't extract from logs, investigate further\n            if (!linkId) {\n                var _receipt_result11, _receipt_result12;\n                console.error(\"Could not extract link ID from transaction events!\");\n                console.log(\"This suggests the contract call may have failed silently\");\n                // Check if the transaction actually reverted\n                console.log(\"Checking for revert data...\");\n                if ((_receipt_result11 = receipt.result) === null || _receipt_result11 === void 0 ? void 0 : _receipt_result11.neonRevertData) {\n                    console.log(\"Revert data found:\", receipt.result.neonRevertData);\n                    try {\n                        // Try to decode the revert reason\n                        const revertReason = ethers__WEBPACK_IMPORTED_MODULE_7__.toUtf8String(receipt.result.neonRevertData);\n                        console.log(\"Revert reason:\", revertReason);\n                        throw new Error(\"Contract call reverted: \".concat(revertReason));\n                    } catch (decodeError) {\n                        console.log(\"Could not decode revert reason:\", decodeError);\n                        throw new Error(\"Contract call reverted with unknown reason\");\n                    }\n                }\n                // Let's try to understand why the event wasn't emitted\n                console.log(\"Analyzing function call...\");\n                console.log(\"Contract address:\", CONTRACT_ADDRESS);\n                console.log(\"From address:\", this.solanaUser.neonWallet);\n                console.log(\"Function data in raw tx:\", (_receipt_result12 = receipt.result) === null || _receipt_result12 === void 0 ? void 0 : _receipt_result12.neonRawTransaction);\n                // Check if user is registered\n                try {\n                    const isRegistered = await this.contract.isSolanaUser(this.solanaUser.neonWallet);\n                    console.log(\"Is user registered as Solana user:\", isRegistered);\n                    if (!isRegistered) {\n                        throw new Error(\"User is not registered as a Solana user with the contract. This is required to create payment links.\");\n                    }\n                } catch (registrationError) {\n                    console.error(\"Failed to check user registration:\", registrationError);\n                    throw registrationError;\n                }\n                // If we get here, something else went wrong\n                throw new Error(\"Payment link creation failed: Contract call executed but no event was emitted. The transaction may have failed silently.\");\n            }\n            return {\n                linkId,\n                txHash\n            };\n        } catch (error) {\n            console.error(\"Error creating payment link:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Initialize read-only contract access (without wallet)\n   */ async initReadOnlyContract() {\n        if (!this.contract) {\n            // Create a simple JSON RPC provider for read operations\n            const readOnlyProvider = new ethers__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider(NEON_CORE_RPC_URL);\n            this.contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.Contract(CONTRACT_ADDRESS, SOLANA_TIPCARD_ABI, readOnlyProvider);\n        }\n    }\n    /**\n   * Get payment link details\n   */ async getPaymentLink(linkId) {\n        // Initialize contract if not already done\n        if (!this.contract) {\n            await this.initReadOnlyContract();\n        }\n        console.log(\"Getting payment link with ID:\", linkId);\n        console.log(\"Contract address:\", CONTRACT_ADDRESS);\n        try {\n            const result = await this.contract.getSolanaPaymentLink(linkId);\n            console.log(\"Raw contract result:\", result);\n            const paymentLink = {\n                evmCreator: result.evmCreator,\n                solanaCreator: result.solanaCreator,\n                amount: result.amount,\n                isFlexible: result.isFlexible,\n                isActive: result.isActive,\n                totalReceived: result.totalReceived,\n                paymentCount: Number(result.paymentCount),\n                description: result.description\n            };\n            // Check if this looks like an empty/non-existent link (transaction not processed yet)\n            if (result.evmCreator === \"0x0000000000000000000000000000000000000000\" && result.amount === BigInt(0) && !result.isActive) {\n                console.warn(\"Payment link appears to be empty/non-existent\");\n                // If this looks like a transaction hash (66 chars, starts with 0x), provide helpful info\n                if (linkId.length === 66 && linkId.startsWith(\"0x\")) {\n                    console.log(\"\\uD83D\\uDCA1 This appears to be a transaction hash - the payment link may still be processing\");\n                    console.log(\"\\uD83D\\uDCA1 Neon operators will eventually process this transaction and create the payment link\");\n                    console.log(\"\\uD83D\\uDCA1 You can bookmark this link and try again in a few minutes\");\n                    // For now, don't throw an error - let the UI handle the empty data gracefully\n                    console.log(\"Returning empty payment link data - transaction may still be processing\");\n                }\n            }\n            return paymentLink;\n        } catch (error) {\n            console.error(\"Contract call error:\", error);\n            throw new Error(\"Payment link not found or contract error\");\n        }\n    }\n    /**\n   * Get user's payment links\n   */ async getUserLinks(userEVMAddress) {\n        // Initialize contract if not already done\n        if (!this.contract) {\n            await this.initReadOnlyContract();\n        }\n        try {\n            return await this.contract.getUserSolanaLinks(userEVMAddress);\n        } catch (error) {\n            console.error(\"Error getting user links:\", error);\n            return [];\n        }\n    }\n    /**\n   * Pay a payment link using Solana Native SDK\n   */ async payLink(linkId, amountSOL) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        console.log(\"Starting payment process...\");\n        console.log(\"Link ID:\", linkId);\n        console.log(\"Amount SOL:\", amountSOL);\n        // First, get the payment link details to find the recipient\n        const linkData = await this.getPaymentLink(linkId);\n        console.log(\"Payment link data:\", linkData);\n        if (!linkData.isActive) {\n            throw new Error(\"Payment link is no longer active\");\n        }\n        // Convert SOL to lamports\n        const amountLamports = Math.floor(amountSOL * 1e9);\n        let transferSignature;\n        try {\n            var _hexString_match, _transactionStatus_, _transactionStatus_1;\n            // Step 1: Perform the actual SOL transfer first\n            console.log(\"Step 1: Performing SOL transfer...\");\n            console.log(\"From:\", this.solanaUser.publicKey.toBase58());\n            console.log(\"To recipient bytes32:\", linkData.solanaCreator);\n            console.log(\"Amount lamports:\", amountLamports);\n            // Convert recipient Solana address from bytes32 to PublicKey\n            // Remove '0x' prefix if present\n            const hexString = linkData.solanaCreator.startsWith(\"0x\") ? linkData.solanaCreator.slice(2) : linkData.solanaCreator;\n            // Convert hex string to byte array\n            const bytes = new Uint8Array(((_hexString_match = hexString.match(/.{2}/g)) === null || _hexString_match === void 0 ? void 0 : _hexString_match.map((byte)=>parseInt(byte, 16))) || []);\n            // For bytes32 from Solana addresses, we need to find the actual 32-byte public key\n            // The bytes32 should contain the 32-byte Solana public key, possibly with leading zeros\n            let recipientPubkey;\n            if (bytes.length === 32) {\n                // Direct conversion from 32 bytes\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(bytes);\n            } else if (bytes.length > 32) {\n                // Take the last 32 bytes if it's longer\n                const last32Bytes = bytes.slice(-32);\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(last32Bytes);\n            } else {\n                // Pad with leading zeros if shorter\n                const paddedBytes = new Uint8Array(32);\n                paddedBytes.set(bytes, 32 - bytes.length);\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(paddedBytes);\n            }\n            console.log(\"Recipient PublicKey:\", recipientPubkey.toBase58());\n            // Create the SOL transfer transaction\n            const { SystemProgram, Transaction } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"));\n            // Create transfer instruction\n            const transferIx = SystemProgram.transfer({\n                fromPubkey: this.solanaUser.publicKey,\n                toPubkey: recipientPubkey,\n                lamports: amountLamports\n            });\n            // Create transaction\n            const transferTx = new Transaction().add(transferIx);\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for SOL transfer...\");\n            const { blockhash, lastValidBlockHeight: transferBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh SOL transfer blockhash:\", blockhash);\n            console.log(\"Last valid block height:\", transferBlockHeight);\n            transferTx.recentBlockhash = blockhash;\n            transferTx.feePayer = this.solanaUser.publicKey;\n            // Sign and send the SOL transfer immediately\n            console.log(\"Signing and sending SOL transfer with fresh blockhash...\");\n            const signedTransferTx = await this.solanaUser.walletAdapter.signTransaction(transferTx);\n            transferSignature = await this.connection.sendRawTransaction(signedTransferTx.serialize());\n            console.log(\"SOL transfer sent:\", transferSignature);\n            // Wait for transfer confirmation using the modern API\n            await this.connection.confirmTransaction({\n                signature: transferSignature,\n                ...await this.connection.getLatestBlockhash()\n            });\n            console.log(\"SOL transfer confirmed\");\n            // Step 2: Record the payment in the contract\n            console.log(\"Step 2: Recording payment in contract...\");\n            // Convert Solana PublicKey to bytes32\n            const payerSolanaBytes32 = (0,ethers__WEBPACK_IMPORTED_MODULE_8__.zeroPadValue)((0,ethers__WEBPACK_IMPORTED_MODULE_8__.hexlify)(this.solanaUser.publicKey.toBytes()), 32);\n            // Get current nonce\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Current nonce:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"paySolanaLink\", [\n                linkId,\n                amountLamports,\n                payerSolanaBytes32\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for contract call...\");\n            const { blockhash: contractBlockhash, lastValidBlockHeight: contractBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh contract call blockhash:\", contractBlockhash);\n            console.log(\"Last valid block height:\", contractBlockHeight);\n            scheduledTransaction.recentBlockhash = contractBlockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            // Sign with wallet adapter (frontend approach)\n            console.log(\"Signing contract call with fresh blockhash...\");\n            const signedTx = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            // Send transaction immediately\n            console.log(\"Sending contract call transaction immediately...\");\n            await this.connection.sendRawTransaction(signedTx.serialize());\n            // Wait for transaction execution on Neon EVM\n            const transactionStatus = await this.proxyApi.waitTransactionTreeExecution(this.solanaUser.neonWallet, nonce, 60000);\n            if (transactionStatus.length === 0 || transactionStatus[0].status !== \"Success\") {\n                console.warn(\"Contract payment recording failed, but SOL transfer succeeded\");\n                console.log(\"Transfer signature:\", transferSignature);\n            // Don't throw error - the payment went through even if recording failed\n            }\n            console.log(\"Payment completed successfully!\");\n            console.log(\"SOL transfer:\", transferSignature);\n            console.log(\"Contract record:\", (_transactionStatus_ = transactionStatus[0]) === null || _transactionStatus_ === void 0 ? void 0 : _transactionStatus_.transactionHash);\n            return {\n                txHash: ((_transactionStatus_1 = transactionStatus[0]) === null || _transactionStatus_1 === void 0 ? void 0 : _transactionStatus_1.transactionHash) || \"contract-recording-failed\",\n                transferSignature\n            };\n        } catch (error) {\n            console.error(\"Error paying link:\", error);\n            if (transferSignature) {\n                console.log(\"Note: SOL transfer may have succeeded:\", transferSignature);\n            }\n            throw error;\n        }\n    }\n    /**\n   * Deactivate a payment link\n   */ async deactivateLink(linkId) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        try {\n            // Get current nonce\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Current nonce:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"deactivateSolanaLink\", [\n                linkId\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for deactivate transaction...\");\n            const { blockhash, lastValidBlockHeight: deactivateBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh deactivate blockhash:\", blockhash);\n            console.log(\"Last valid block height:\", deactivateBlockHeight);\n            scheduledTransaction.recentBlockhash = blockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            // Sign with wallet adapter (frontend approach)\n            console.log(\"Signing deactivate transaction with fresh blockhash...\");\n            const signedTx = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            // Send transaction immediately\n            console.log(\"Sending deactivate transaction immediately...\");\n            await this.connection.sendRawTransaction(signedTx.serialize());\n            // Wait for transaction execution\n            const transactionStatus = await this.proxyApi.waitTransactionTreeExecution(this.solanaUser.neonWallet, nonce, 60000);\n            if (transactionStatus.length === 0 || transactionStatus[0].status !== \"Success\") {\n                throw new Error(\"Deactivation transaction failed to execute on Neon EVM\");\n            }\n            return {\n                txHash: transactionStatus[0].transactionHash\n            };\n        } catch (error) {\n            throw error;\n        }\n    }\n    /**\n   * Create a shareable URL for a payment link\n   */ createPaymentURL(linkId) {\n        return \"\".concat(window.location.origin, \"?pay=\").concat(linkId);\n    }\n    /**\n   * Extract link ID from URL\n   */ static extractLinkIdFromURL(url) {\n        try {\n            const urlObj = new URL(url);\n            return urlObj.searchParams.get(\"pay\");\n        } catch (e) {\n            return null;\n        }\n    }\n    /**\n   * Get the user's EVM address derived from Solana public key\n   */ getUserEVMAddress() {\n        var _this_solanaUser;\n        return ((_this_solanaUser = this.solanaUser) === null || _this_solanaUser === void 0 ? void 0 : _this_solanaUser.neonWallet) || null;\n    }\n    constructor(){\n        this.chainId = null;\n        this.contract = null;\n        this.connection = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Connection(SOLANA_RPC_URL, \"confirmed\");\n        this.proxyApi = new _neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__.NeonProxyRpcApi(NEON_PROXY_RPC_URL);\n    }\n}\n// Export singleton instance\nconst solanaNativeContract = new SolanaNativeContract();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3NvbGFuYS1uYXRpdmUtY29udHJhY3QudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBZ0U7QUFDMEM7QUFDcEQ7QUFDVjtBQUU1Qyx1Q0FBdUM7QUFDdkMsTUFBTU8scUJBQXFCRCw4Q0FBV0E7QUFFdEMsTUFBTUUsbUJBQW1CQyw0Q0FBZ0QsSUFBSTtBQUM3RSxNQUFNRyxvQkFBb0JILDRCQUFvQyxJQUFJO0FBQ2xFLE1BQU1LLHFCQUFxQixHQUFxQixPQUFsQkYsbUJBQWtCO0FBQ2hELE1BQU1HLGlCQUFpQjtBQWFoQixNQUFNQztJQWFYOztHQUVDLEdBQ0QsTUFBTUMscUJBQXFCQyxhQUFrQixFQUFpQjtRQUM1RCxJQUFJLENBQUNBLGNBQWNDLFNBQVMsRUFBRTtZQUM1QixNQUFNLElBQUlDLE1BQU07UUFDbEI7UUFFQSxJQUFJO2dCQXVDaUMsaUNBV007WUFqRHpDQyxRQUFRQyxHQUFHLENBQUM7WUFDWkQsUUFBUUMsR0FBRyxDQUFDLHNCQUFzQkosY0FBY0MsU0FBUyxDQUFDSSxRQUFRO1lBRWxFLHlEQUF5RDtZQUN6RCxNQUFNLEVBQ0pDLFFBQVEsRUFDUkMsT0FBTyxFQUNQQyxVQUFVLEVBQ1ZDLGdCQUFnQixFQUNoQkMsY0FBYyxFQUNmLEdBQUcsTUFBTSxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDWixjQUFjQyxTQUFTO1lBRXBERSxRQUFRQyxHQUFHLENBQUMsZUFBZUc7WUFDM0JKLFFBQVFDLEdBQUcsQ0FBQyx1QkFBdUJNLGVBQWVMLFFBQVE7WUFFMUQsbURBQW1EO1lBQ25ELElBQUksQ0FBQ0UsT0FBTyxHQUFHQTtZQUNmLElBQUksQ0FBQ0MsVUFBVSxHQUFHO2dCQUNoQixHQUFHQSxVQUFVO2dCQUNiUixlQUFlQSxjQUFjLGlDQUFpQztZQUNoRTtZQUVBLGdGQUFnRjtZQUNoRixJQUFJLENBQUMsSUFBSSxDQUFDUSxVQUFVLENBQUNLLGNBQWMsRUFBRTtnQkFDbkMsTUFB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QUFpQixDQUFDLEVBQUUsQ0FBQ0csTUFBTSxLQUFLLFdBQVc7Z0JBQy9FLE1BQU0sSUFBSXRHLE1BQU07WUFDbEI7WUFFQSxPQUFPO2dCQUNMeUcsUUFBUU4saUJBQWlCLENBQUMsRUFBRSxDQUFDSSxlQUFlO1lBQzlDO1FBQ0YsRUFBRSxPQUFPdEYsT0FBWTtZQUNuQixNQUFNQTtRQUNSO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEeUssaUJBQWlCbEYsTUFBYyxFQUFVO1FBQ3ZDLE9BQU8sR0FBaUNBLE9BQTlCbUYsT0FBT0MsUUFBUSxDQUFDQyxNQUFNLEVBQUMsU0FBYyxPQUFQckY7SUFDMUM7SUFFQTs7R0FFQyxHQUNELE9BQU9zRixxQkFBcUJDLEdBQVcsRUFBaUI7UUFDdEQsSUFBSTtZQUNGLE1BQU1DLFNBQVMsSUFBSUMsSUFBSUY7WUFDdkIsT0FBT0MsT0FBT0UsWUFBWSxDQUFDQyxHQUFHLENBQUM7UUFDakMsRUFBRSxVQUFNO1lBQ04sT0FBTztRQUNUO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEQyxvQkFBbUM7WUFDMUI7UUFBUCxPQUFPLHlCQUFJLENBQUM5TCxVQUFVLGNBQWYsd0RBQWlCVSxVQUFVLEtBQUk7SUFDeEM7SUE3eUJBcUwsYUFBYzthQUhOaE0sVUFBeUI7YUFDekJlLFdBQW1DO1FBR3pDLElBQUksQ0FBQ2dDLFVBQVUsR0FBRyxJQUFJeEUsdURBQVVBLENBQUNlLGdCQUFnQjtRQUNqRCxJQUFJLENBQUNjLFFBQVEsR0FBRyxJQUFJNUIsaUVBQWVBLENBQUNhO0lBQ3RDO0FBMnlCRjtBQUVBLDRCQUE0QjtBQUNyQixNQUFNNE0sdUJBQXVCLElBQUkxTSx1QkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvc29sYW5hLW5hdGl2ZS1jb250cmFjdC50cz9kNGM2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbm5lY3Rpb24sIFB1YmxpY0tleSwgS2V5cGFpciB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcydcbmltcG9ydCB7IE5lb25Qcm94eVJwY0FwaSwgY3JlYXRlQmFsYW5jZUFjY291bnRJbnN0cnVjdGlvbiwgU29sYW5hTmVvbkFjY291bnQgfSBmcm9tICdAbmVvbmV2bS9zb2xhbmEtc2lnbidcbmltcG9ydCB7IGV0aGVycywgaGV4bGlmeSwgemVyb1BhZFZhbHVlIH0gZnJvbSAnZXRoZXJzJ1xuaW1wb3J0IENvbnRyYWN0QUJJIGZyb20gJy4vY29udHJhY3RBQkkuanNvbidcblxuLy8gVXNlIHRoZSBhY3R1YWwgZGVwbG95ZWQgY29udHJhY3QgQUJJXG5jb25zdCBTT0xBTkFfVElQQ0FSRF9BQkkgPSBDb250cmFjdEFCSVxuXG5jb25zdCBDT05UUkFDVF9BRERSRVNTID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfVElQQ0FSRF9DT05UUkFDVF9BRERSRVNTIHx8ICcweENGRTAzYzdjNjc0NTZEMDk0QzAxNjJGOTAzMDM5M0ZDMmNDYzQwQ2InXG5jb25zdCBORU9OX0NPUkVfUlBDX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX05FT05fUlBDX1VSTCB8fCAnaHR0cHM6Ly9kZXZuZXQubmVvbmV2bS5vcmcnXG5jb25zdCBORU9OX1BST1hZX1JQQ19VUkwgPSBgJHtORU9OX0NPUkVfUlBDX1VSTH0vc29sYFxuY29uc3QgU09MQU5BX1JQQ19VUkwgPSAnaHR0cHM6Ly9hcGkuZGV2bmV0LnNvbGFuYS5jb20nXG5cbmV4cG9ydCBpbnRlcmZhY2UgUGF5bWVudExpbmsge1xuICBldm1DcmVhdG9yOiBzdHJpbmdcbiAgc29sYW5hQ3JlYXRvcjogc3RyaW5nXG4gIGFtb3VudDogYmlnaW50XG4gIGlzRmxleGlibGU6IGJvb2xlYW5cbiAgaXNBY3RpdmU6IGJvb2xlYW5cbiAgdG90YWxSZWNlaXZlZDogYmlnaW50XG4gIHBheW1lbnRDb3VudDogbnVtYmVyXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcbn1cblxuZXhwb3J0IGNsYXNzIFNvbGFuYU5hdGl2ZUNvbnRyYWN0IHtcbiAgcHJpdmF0ZSBjb25uZWN0aW9uOiBDb25uZWN0aW9uXG4gIHByaXZhdGUgcHJveHlBcGk6IE5lb25Qcm94eVJwY0FwaVxuICBwcml2YXRlIHNvbGFuYVVzZXI6IGFueVxuICBwcml2YXRlIGNoYWluSWQ6IG51bWJlciB8IG51bGwgPSBudWxsXG4gIHByaXZhdGUgY29udHJhY3Q6IGV0aGVycy5Db250cmFjdCB8IG51bGwgPSBudWxsXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb25uZWN0aW9uID0gbmV3IENvbm5lY3Rpb24oU09MQU5BX1JQQ19VUkwsICdjb25maXJtZWQnKVxuICAgIHRoaXMucHJveHlBcGkgPSBuZXcgTmVvblByb3h5UnBjQXBpKE5FT05fUFJPWFlfUlBDX1VSTClcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgd2l0aCBTb2xhbmEgd2FsbGV0IHVzaW5nIHRoZSByZWNvbW1lbmRlZCBTb2xhbmFOZW9uQWNjb3VudCBhcHByb2FjaFxuICAgKi9cbiAgYXN5bmMgaW5pdFdpdGhTb2xhbmFXYWxsZXQod2FsbGV0QWRhcHRlcjogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF3YWxsZXRBZGFwdGVyLnB1YmxpY0tleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbm90IGNvbm5lY3RlZCcpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SnIFVzaW5nIHJlY29tbWVuZGVkIFNvbGFuYU5lb25BY2NvdW50IGFwcHJvYWNoLi4uJylcbiAgICAgIGNvbnNvbGUubG9nKCdXYWxsZXQgcHVibGljIGtleTonLCB3YWxsZXRBZGFwdGVyLnB1YmxpY0tleS50b0Jhc2U1OCgpKVxuICAgICAgXG4gICAgICAvLyBVc2UgcHJveHlBcGkuaW5pdCB3aXRoIGp1c3QgdGhlIHB1YmxpYyBrZXkgKGxpa2UgZGVtbylcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIHNvbGFuYVVzZXIsXG4gICAgICAgIHRva2VuTWludEFkZHJlc3MsXG4gICAgICAgIHByb2dyYW1BZGRyZXNzXG4gICAgICB9ID0gYXdhaXQgdGhpcy5wcm94eUFwaS5pbml0KHdhbGxldEFkYXB0ZXIucHVibGljS2V5KVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnLSBDaGFpbiBJRDonLCBjaGFpbklkKVxuICAgICAgY29uc29sZS5sb2coJy0gTmVvbiBFVk0gUHJvZ3JhbTonLCBwcm9ncmFtQWRkcmVzcy50b0Jhc2U1OCgpKVxuICAgICAgXG4gICAgICAvLyBTdG9yZSB0aGUgcmVzdWx0IHdpdGggd2FsbGV0IGFkYXB0ZXIgZm9yIHNpZ25pbmdcbiAgICAgIHRoaXMuY2hhaW5JZCA9IGNoYWluSWRcbiAgICAgIHRoaXMuc29sYW5hVXNlciA9IHtcbiAgICAgICAgLi4uc29sYW5hVXNlcixcbiAgICAgICAgd2FsbGV0QWRhcHRlcjogd2FsbGV0QWRhcHRlciAvLyBBZGQgd2FsbGV0IGFkYXB0ZXIgZm9yIHNpZ25pbmdcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGJhbGFuY2UgYWRkcmVzcyBpZiBpdCBkb2Vzbid0IGV4aXN0ICh1c2luZyBTb2xhbmFOZW9uQWNjb3VudCBhcHByb2FjaClcbiAgICAgIGlmICghdGhpcy5zb2xhbmFVc2VyLmJhbGFuY2VBZGRyZXNzKSB7XG4gICAgICAgIGNvbnN0IHsgU29sYW5hTmVvbkFjY291bnQgfSA9IGF3YWl0IGltcG9ydCgnQG5lb25ldm0vc29sYW5hLXNpZ24nKVxuICAgICAgICBjb25zdCBhY2NvdW50ID0gbmV3IFNvbGFuYU5lb25BY2NvdW50KFxuICAgICAgICAgIHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXksXG4gICAgICAgICAgdGhpcy5zb2xhbmFVc2VyLm5lb25Fdm1Qcm9ncmFtLFxuICAgICAgICAgIHRoaXMuc29sYW5hVXNlci50b2tlbk1pbnQsXG4gICAgICAgICAgdGhpcy5zb2xhbmFVc2VyLmNoYWluSWRcbiAgICAgICAgKVxuICAgICAgICB0aGlzLnNvbGFuYVVzZXIuYmFsYW5jZUFkZHJlc3MgPSBhY2NvdW50LmJhbGFuY2VBZGRyZXNzXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgV2FsbGV0IGluaXRpYWxpemVkIHVzaW5nIFNvbGFuYU5lb25BY2NvdW50IGFwcHJvYWNoIScpXG4gICAgICBjb25zb2xlLmxvZygn8J+TjSBDb25uZWN0ZWQgd2FsbGV0IHB1YmxpYyBrZXk6Jywgd2FsbGV0QWRhcHRlci5wdWJsaWNLZXkudG9CYXNlNTgoKSlcbiAgICAgIGNvbnNvbGUubG9nKCfwn5ONIFNvbGFuYSB1c2VyIHB1YmxpYyBrZXk6JywgdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleS50b0Jhc2U1OCgpKVxuICAgICAgY29uc29sZS5sb2coJ/Cfk40gRGVyaXZlZCBFVk0gYWRkcmVzczonLCB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldClcbiAgICAgIGNvbnNvbGUubG9nKCfwn5KwIEJhbGFuY2UgYWRkcmVzczonLCB0aGlzLnNvbGFuYVVzZXIuYmFsYW5jZUFkZHJlc3M/LnRvQmFzZTU4KCkgfHwgJ05vdCBhdmFpbGFibGUnKVxuICAgICAgY29uc29sZS5sb2coJ/CflI0gRnVsbCBzb2xhbmFVc2VyIG9iamVjdDonLCB0aGlzLnNvbGFuYVVzZXIpXG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSB0aGV5IG1hdGNoXG4gICAgICBpZiAod2FsbGV0QWRhcHRlci5wdWJsaWNLZXkudG9CYXNlNTgoKSA9PT0gdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleS50b0Jhc2U1OCgpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgV2FsbGV0IHB1YmxpYyBrZXlzIG1hdGNoIGNvcnJlY3RseSEnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIE1JU01BVENIOiBXYWxsZXQgYWRhcHRlciBhbmQgc29sYW5hIHVzZXIgaGF2ZSBkaWZmZXJlbnQgcHVibGljIGtleXMhJylcbiAgICAgICAgY29uc29sZS5lcnJvcignV2FsbGV0IGFkYXB0ZXI6Jywgd2FsbGV0QWRhcHRlci5wdWJsaWNLZXkudG9CYXNlNTgoKSlcbiAgICAgICAgY29uc29sZS5lcnJvcignU29sYW5hIHVzZXI6JywgdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleS50b0Jhc2U1OCgpKVxuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coJ/CfkrAgRmluYWwgYmFsYW5jZSBhZGRyZXNzOicsIHRoaXMuc29sYW5hVXNlci5iYWxhbmNlQWRkcmVzcz8udG9CYXNlNTgoKSB8fCAnU3RpbGwgbm90IGF2YWlsYWJsZScpXG5cbiAgICAgIC8vIENyZWF0ZSBjb250cmFjdCBpbnN0YW5jZVxuICAgICAgY29uc3QgcmVhZE9ubHlQcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKE5FT05fQ09SRV9SUENfVVJMKVxuICAgICAgdGhpcy5jb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoQ09OVFJBQ1RfQUREUkVTUywgU09MQU5BX1RJUENBUkRfQUJJLCByZWFkT25seVByb3ZpZGVyKVxuICAgICAgXG4gICAgICAvLyBWZXJpZnkgdGhlIGRlcml2ZWQgRVZNIGFkZHJlc3MgaXMgdmFsaWRcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIFZlcmlmeWluZyBkZXJpdmVkIEVWTSBhZGRyZXNzLi4uJylcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgRVZNIGFkZHJlc3MgaGFzIGJlZW4gdXNlZCBiZWZvcmUgKGhhcyB0cmFuc2FjdGlvbiBoaXN0b3J5KVxuICAgICAgICBjb25zdCB0eENvdW50ID0gYXdhaXQgcmVhZE9ubHlQcm92aWRlci5nZXRUcmFuc2FjdGlvbkNvdW50KHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0KVxuICAgICAgICBjb25zb2xlLmxvZygn8J+TiiBFVk0gYWRkcmVzcyB0cmFuc2FjdGlvbiBjb3VudDonLCB0eENvdW50KVxuICAgICAgICBcbiAgICAgICAgaWYgKHR4Q291bnQgPiAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBUaGlzIEVWTSBhZGRyZXNzIGhhcyB0cmFuc2FjdGlvbiBoaXN0b3J5IC0gaXQgZXhpc3RzIG9uLWNoYWluIScpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ+KEue+4jyBUaGlzIEVWTSBhZGRyZXNzIGlzIG5ldyAobm8gdHJhbnNhY3Rpb24gaGlzdG9yeSB5ZXQpJylcbiAgICAgICAgICBjb25zb2xlLmxvZygn4oS577iPIFRoZSBhZGRyZXNzIHdpbGwgYmUgcmVnaXN0ZXJlZCBvbi1jaGFpbiB3aGVuIGZpcnN0IHRyYW5zYWN0aW9uIGlzIG1hZGUnKVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoICh2ZXJpZnlFcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZygn4pqg77iPIENvdWxkIG5vdCB2ZXJpZnkgRVZNIGFkZHJlc3M6JywgdmVyaWZ5RXJyb3IpXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBjb250cmFjdCBpcyBkZXBsb3llZCBhdCB0aGlzIGFkZHJlc3NcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdWZXJpZnlpbmcgY29udHJhY3QgYXQgYWRkcmVzczonLCBDT05UUkFDVF9BRERSRVNTKVxuICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgcmVhZE9ubHlQcm92aWRlci5nZXRDb2RlKENPTlRSQUNUX0FERFJFU1MpXG4gICAgICAgIGNvbnNvbGUubG9nKCdDb250cmFjdCBjb2RlIGxlbmd0aDonLCBjb2RlLmxlbmd0aClcbiAgICAgICAgaWYgKGNvZGUgPT09ICcweCcpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBObyBjb250cmFjdCBjb2RlIGZvdW5kIGF0IGFkZHJlc3M6JywgQ09OVFJBQ1RfQUREUkVTUylcbiAgICAgICAgICBjb25zb2xlLmxvZygnVGhpcyBtaWdodCBtZWFuIHRoZSBjb250cmFjdCBpcyBub3QgZGVwbG95ZWQgb3IgYWRkcmVzcyBpcyBpbmNvcnJlY3QnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgQ29udHJhY3QgZm91bmQgYXQgYWRkcmVzcycpXG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBDb250cmFjdCBmb3VuZCBhbmQgcmVhZHkgZm9yIHRyYW5zYWN0aW9ucycpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHZlcmlmeUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHZlcmlmeSBjb250cmFjdDonLCB2ZXJpZnlFcnJvcilcbiAgICAgIH1cbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBTb2xhbmEgTmF0aXZlIFNESzonLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHBheW1lbnQgbGluayB1c2luZyBTb2xhbmEgTmF0aXZlIFNES1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlUGF5bWVudExpbmsoXG4gICAgc3VnZ2VzdGVkQW1vdW50U09MOiBudW1iZXIsXG4gICAgaXNGbGV4aWJsZTogYm9vbGVhbixcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gICk6IFByb21pc2U8eyBsaW5rSWQ6IHN0cmluZzsgdHhIYXNoOiBzdHJpbmcgfT4ge1xuICAgIGlmICghdGhpcy5zb2xhbmFVc2VyIHx8ICF0aGlzLmNvbnRyYWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBjb25uZWN0IHdhbGxldCBmaXJzdCcpXG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBTT0wgdG8gbGFtcG9ydHMgKDEgU09MID0gMWU5IGxhbXBvcnRzKVxuICAgIGNvbnN0IGFtb3VudExhbXBvcnRzID0gTWF0aC5mbG9vcihzdWdnZXN0ZWRBbW91bnRTT0wgKiAxZTkpXG5cbiAgICB0cnkge1xuICAgICAgLy8gR2V0IGN1cnJlbnQgbm9uY2UgKGV4YWN0bHkgbGlrZSB3b3JraW5nIGV4YW1wbGVzKVxuICAgICAgY29uc3Qgbm9uY2UgPSBOdW1iZXIoYXdhaXQgdGhpcy5wcm94eUFwaS5nZXRUcmFuc2FjdGlvbkNvdW50KHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0KSlcbiAgICAgIGNvbnNvbGUubG9nKCdDdXJyZW50IG5vbmNlOicsIG5vbmNlKVxuXG4gICAgICAvLyBQcmVwYXJlIGNvbnRyYWN0IGNhbGwgZGF0YVxuICAgICAgY29uc3QgaWZhY2UgPSBuZXcgZXRoZXJzLkludGVyZmFjZShTT0xBTkFfVElQQ0FSRF9BQkkpXG4gICAgICBjb25zdCBkYXRhID0gaWZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKCdjcmVhdGVTb2xhbmFQYXltZW50TGluaycsIFtcbiAgICAgICAgYW1vdW50TGFtcG9ydHMsXG4gICAgICAgIGlzRmxleGlibGUsXG4gICAgICAgIGRlc2NyaXB0aW9uXG4gICAgICBdKVxuXG4gICAgICAvLyBDcmVhdGUgdHJhbnNhY3Rpb24gZGF0YVxuICAgICAgY29uc3QgdHJhbnNhY3Rpb25EYXRhID0ge1xuICAgICAgICBmcm9tOiB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCxcbiAgICAgICAgdG86IENPTlRSQUNUX0FERFJFU1MsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH1cblxuICAgICAgLy8gRGVidWc6IENoZWNrIHdoYXQgc29sYW5hUGF5ZXIgd2UncmUgdXNpbmdcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIFRyYW5zYWN0aW9uIGNyZWF0aW9uIGRlYnVnOicpXG4gICAgICBjb25zb2xlLmxvZygnLSBzb2xhbmFQYXllciBmb3IgZ2FzIGVzdGltYXRpb246JywgdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleS50b0Jhc2U1OCgpKVxuICAgICAgY29uc29sZS5sb2coJy0gZnJvbSBhZGRyZXNzIGluIHRyYW5zYWN0aW9uRGF0YTonLCB0cmFuc2FjdGlvbkRhdGEuZnJvbSlcbiAgICAgIGNvbnNvbGUubG9nKCctIG5vbmNlOicsIG5vbmNlKVxuXG4gICAgICAvLyBFc3RpbWF0ZSBnYXNcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uR2FzID0gYXdhaXQgdGhpcy5wcm94eUFwaS5lc3RpbWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uR2FzKHtcbiAgICAgICAgc29sYW5hUGF5ZXI6IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXksXG4gICAgICAgIHRyYW5zYWN0aW9uczogW3RyYW5zYWN0aW9uRGF0YV0sXG4gICAgICB9KVxuXG4gICAgICBjb25zb2xlLmxvZygnR2FzIGVzdGltYXRpb24gY29tcGxldGVkJylcblxuICAgICAgLy8gQ3JlYXRlIHNjaGVkdWxlZCB0cmFuc2FjdGlvblxuICAgICAgbGV0IHsgc2NoZWR1bGVkVHJhbnNhY3Rpb24gfSA9IGF3YWl0IHRoaXMucHJveHlBcGkuY3JlYXRlU2NoZWR1bGVkVHJhbnNhY3Rpb24oe1xuICAgICAgICB0cmFuc2FjdGlvbkdhcyxcbiAgICAgICAgdHJhbnNhY3Rpb25EYXRhLFxuICAgICAgICBub25jZVxuICAgICAgfSlcblxuICAgICAgY29uc29sZS5sb2coJ1NjaGVkdWxlZCB0cmFuc2FjdGlvbiBjcmVhdGVkJylcblxuICAgICAgLy8gQ2hlY2sgaWYgYmFsYW5jZSBhY2NvdW50IGV4aXN0cywgaWYgbm90IGNyZWF0ZSBpdFxuICAgICAgY29uc3QgYWNjb3VudCA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5nZXRBY2NvdW50SW5mbyh0aGlzLnNvbGFuYVVzZXIuYmFsYW5jZUFkZHJlc3MpXG4gICAgICBpZiAoYWNjb3VudCA9PT0gbnVsbCkge1xuICAgICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5pbnN0cnVjdGlvbnMudW5zaGlmdChcbiAgICAgICAgICBjcmVhdGVCYWxhbmNlQWNjb3VudEluc3RydWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5zb2xhbmFVc2VyLm5lb25Fdm1Qcm9ncmFtLFxuICAgICAgICAgICAgdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleSxcbiAgICAgICAgICAgIHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0LFxuICAgICAgICAgICAgdGhpcy5jaGFpbklkIVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyBTaWduIGFuZCBzZW5kIHRyYW5zYWN0aW9uIHVzaW5nIGV4YWN0IHRlc3QgcGF0dGVyblxuICAgICAgY29uc3QgeyBibG9ja2hhc2ggfSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goKVxuICAgICAgc2NoZWR1bGVkVHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoXG4gICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5mZWVQYXllciA9IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXlcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ/CflI0gUHJlLXNpZ25pbmcgZGVidWc6JylcbiAgICAgIGNvbnNvbGUubG9nKCctIENvbm5lY3RlZCB3YWxsZXQ6JywgdGhpcy5zb2xhbmFVc2VyLndhbGxldEFkYXB0ZXIucHVibGljS2V5Py50b0Jhc2U1OCgpKVxuICAgICAgY29uc29sZS5sb2coJy0gU29sYW5hIHVzZXI6JywgdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleS50b0Jhc2U1OCgpKVxuICAgICAgY29uc29sZS5sb2coJy0gVHJhbnNhY3Rpb24gZmVlUGF5ZXI6Jywgc2NoZWR1bGVkVHJhbnNhY3Rpb24uZmVlUGF5ZXI/LnRvQmFzZTU4KCkpXG4gICAgICBjb25zb2xlLmxvZygnLSBBcmUgdGhleSB0aGUgc2FtZT8nLCB0aGlzLnNvbGFuYVVzZXIud2FsbGV0QWRhcHRlci5wdWJsaWNLZXk/LnRvQmFzZTU4KCkgPT09IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXkudG9CYXNlNTgoKSlcbiAgICAgIFxuICAgICAgLy8gU2lnbiB0aGUgdHJhbnNhY3Rpb24gdXNpbmcgd2FsbGV0IGFkYXB0ZXIgKGZyb250ZW5kIGFwcHJvYWNoKVxuICAgICAgY29uc29sZS5sb2coJ/Cfk50gU2lnbmluZyB0cmFuc2FjdGlvbiB3aXRoIHdhbGxldCBhZGFwdGVyLi4uJylcbiAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5zb2xhbmFVc2VyLndhbGxldEFkYXB0ZXIuc2lnblRyYW5zYWN0aW9uKHNjaGVkdWxlZFRyYW5zYWN0aW9uKVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnU3VibWl0dGluZyB0cmFuc2FjdGlvbi4uLicpXG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uc2VuZFJhd1RyYW5zYWN0aW9uKHNpZ25lZFRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpKVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFRyYW5zYWN0aW9uIHN1Ym1pdHRlZCEnKVxuICAgICAgY29uc29sZS5sb2coJ/CflJcgU2lnbmF0dXJlOicsIHNpZ25hdHVyZSlcblxuICAgICAgLy8gV2FpdCBhIGJpdCBmb3IgcHJvY2Vzc2luZyAobGlrZSB3b3JraW5nIGV4YW1wbGVzKVxuICAgICAgY29uc29sZS5sb2coJ1dhaXRpbmcgZm9yIGNvbmZpcm1hdGlvbi4uLicpXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwMCkpXG5cbiAgICAgIC8vIFdhaXQgZm9yIGNvbmZpcm1hdGlvblxuICAgICAgY29uc29sZS5sb2coYCAgIFdhaXRpbmcgZm9yIHBheW1lbnQgY29uZmlybWF0aW9uLi4uYCk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwMCkpO1xuXG4gICAgICAvLyBDaGVjayB0cmFuc2FjdGlvbiBzdGF0dXNcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvbmZpcm1hdGlvbiA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0U2lnbmF0dXJlU3RhdHVzKHNpZ25hdHVyZSk7XG4gICAgICAgIGlmIChjb25maXJtYXRpb24udmFsdWU/LmNvbmZpcm1hdGlvblN0YXR1cykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgUGF5bWVudCBzdGF0dXM6ICR7Y29uZmlybWF0aW9uLnZhbHVlLmNvbmZpcm1hdGlvblN0YXR1c31gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyeSB0byBnZXQgcGF5bWVudCBkZXRhaWxzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYCAgIEdldHRpbmcgcGF5bWVudCB0cmFuc2FjdGlvbiBkZXRhaWxzLi4uYCk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgbmVvblR4UmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9kZXZuZXQubmVvbmV2bS5vcmcvc29sJywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgbWV0aG9kOiBcIm5lb25fZ2V0VHJhbnNhY3Rpb25CeVNlbmRlck5vbmNlXCIsXG4gICAgICAgICAgICAgIHBhcmFtczogW3NvbGFuYVVzZXIyLm5lb25XYWxsZXQsIG5vbmNlXSxcbiAgICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgbmVvblR4UmVzdWx0ID0gYXdhaXQgbmVvblR4UmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChuZW9uVHhSZXN1bHQucmVzdWx0ICYmIG5lb25UeFJlc3VsdC5yZXN1bHQuaGFzaCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBOZW9uIEVWTSBwYXltZW50IGhhc2g6ICR7bmVvblR4UmVzdWx0LnJlc3VsdC5oYXNofWApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDaGVjayB1cGRhdGVkIGxpbmsgZGV0YWlsc1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgbGlua0RldGFpbHMgPSBhd2FpdCBzb2xhbmFUaXBDYXJkLmdldFNvbGFuYVBheW1lbnRMaW5rKGNyZWF0ZWRMaW5rSWQpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+OiSBVcGRhdGVkIFBheW1lbnQgTGluayBEZXRhaWxzOmApO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgTGluayBJRDogJHtjcmVhdGVkTGlua0lkfWApO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgVG90YWwgUmVjZWl2ZWQ6ICR7ZXRoZXJzLmZvcm1hdFVuaXRzKGxpbmtEZXRhaWxzLnRvdGFsUmVjZWl2ZWQsIDkpfSBTT0xgKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYCAgIFBheW1lbnQgQ291bnQ6ICR7bGlua0RldGFpbHMucGF5bWVudENvdW50fWApO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgQWN0aXZlOiAke2xpbmtEZXRhaWxzLmlzQWN0aXZlfWApO1xuICAgICAgICAgICAgfSBjYXRjaCAobGlua0Vycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDihLnvuI8gQ291bGQgbm90IGdldCB1cGRhdGVkIGxpbmsgZGV0YWlsczogJHtsaW5rRXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKEue+4jyBOZW9uIEVWTSBwYXltZW50IHRyYW5zYWN0aW9uIG5vdCBmb3VuZCB5ZXQgKG1heSBzdGlsbCBiZSBwcm9jZXNzaW5nKWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgfSBjYXRjaCAobmVvbkVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKEue+4jyBDb3VsZCBub3QgZ2V0IE5lb24gcGF5bWVudCBkZXRhaWxzOiAke25lb25FcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgfSBjYXRjaCAoY29uZmlybUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDihLnvuI8gUGF5bWVudCBjb25maXJtYXRpb24gY2hlY2s6ICR7Y29uZmlybUVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKGDwn46JIFBheW1lbnQgdHJhbnNhY3Rpb24gY29tcGxldGVkIWApO1xuXG4gICAgICAvLyBXYWl0IGZvciB0cmFuc2FjdGlvbiBleGVjdXRpb24gb24gTmVvbiBFVk1cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uU3RhdHVzID0gYXdhaXQgdGhpcy5wcm94eUFwaS53YWl0VHJhbnNhY3Rpb25UcmVlRXhlY3V0aW9uKFxuICAgICAgICB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCwgXG4gICAgICAgIG5vbmNlLCBcbiAgICAgICAgNjAwMDAgLy8gNjAgc2Vjb25kIHRpbWVvdXRcbiAgICAgIClcblxuICAgICAgY29uc29sZS5sb2coJ1RyYW5zYWN0aW9uIHN0YXR1czonLCB0cmFuc2FjdGlvblN0YXR1cylcblxuICAgICAgaWYgKHRyYW5zYWN0aW9uU3RhdHVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHRyYW5zYWN0aW9uIHN0YXR1cyByZXR1cm5lZCAtIHRyYW5zYWN0aW9uIG1heSBub3QgaGF2ZSBiZWVuIHByb2Nlc3NlZCcpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHR4U3RhdHVzID0gdHJhbnNhY3Rpb25TdGF0dXNbMF1cbiAgICAgIGNvbnNvbGUubG9nKCdUcmFuc2FjdGlvbiBleGVjdXRpb24gc3RhdHVzOicsIHR4U3RhdHVzLnN0YXR1cylcbiAgICAgIFxuICAgICAgaWYgKHR4U3RhdHVzLnN0YXR1cyA9PT0gJ05vdFN0YXJ0ZWQnKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIFRyYW5zYWN0aW9uIHdhcyBzY2hlZHVsZWQgYnV0IG5vdCB5ZXQgZXhlY3V0ZWQgYnkgTmVvbiBvcGVyYXRvcnMnKVxuICAgICAgICBjb25zb2xlLmxvZygnVGhpcyBpcyBleHBlY3RlZCAtIE5lb24gd2lsbCBwcm9jZXNzIGl0IGV2ZW50dWFsbHknKVxuICAgICAgICBjb25zb2xlLmxvZygnVHJhbnNhY3Rpb24gaGFzaDonLCB0eFN0YXR1cy50cmFuc2FjdGlvbkhhc2gpXG4gICAgICAgIFxuICAgICAgICAvLyBTaW5jZSB3ZSBoYXZlIGEgdHJhbnNhY3Rpb24gaGFzaCwgcHJvY2VlZCB3aXRoIHVzaW5nIGl0IGFzIHRoZSBwYXltZW50IGxpbmsgSURcbiAgICAgICAgLy8gVGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IE5lb24gb3BlcmF0b3JzIGV2ZW50dWFsbHlcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBVc2luZyB0cmFuc2FjdGlvbiBoYXNoIGFzIHBheW1lbnQgbGluayBJRCAtIE5lb24gd2lsbCBwcm9jZXNzIGl0IHdoZW4gcmVhZHknKVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsaW5rSWQ6IHR4U3RhdHVzLnRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICB0eEhhc2g6IHR4U3RhdHVzLnRyYW5zYWN0aW9uSGFzaFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgfSBlbHNlIGlmICh0eFN0YXR1cy5zdGF0dXMgPT09ICdGYWlsZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gZXhlY3V0aW9uIGZhaWxlZC4gSGFzaDogJHt0eFN0YXR1cy50cmFuc2FjdGlvbkhhc2h9YClcbiAgICAgIH0gZWxzZSBpZiAodHhTdGF0dXMuc3RhdHVzICE9PSAnU3VjY2VzcycpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdUcmFuc2FjdGlvbiBmaW5pc2hlZCB3aXRoIHVuZXhwZWN0ZWQgc3RhdHVzOicsIHR4U3RhdHVzLnN0YXR1cylcbiAgICAgICAgLy8gU3RpbGwgdHJ5IHRvIHJldHVybiB0aGUgdHJhbnNhY3Rpb24gaGFzaCBpbiBjYXNlIGl0J3MgdXNhYmxlXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGlua0lkOiB0eFN0YXR1cy50cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgdHhIYXNoOiB0eFN0YXR1cy50cmFuc2FjdGlvbkhhc2hcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB0eEhhc2ggPSB0cmFuc2FjdGlvblN0YXR1c1swXS50cmFuc2FjdGlvbkhhc2hcbiAgICAgIGNvbnNvbGUubG9nKCdUcmFuc2FjdGlvbiBoYXNoOicsIHR4SGFzaClcblxuICAgICAgLy8gR2V0IHRoZSBsaW5rIElEIGZyb20gdHJhbnNhY3Rpb24gcmVjZWlwdFxuICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMucHJveHlBcGkuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaClcbiAgICAgIGNvbnNvbGUubG9nKCdGdWxsIHRyYW5zYWN0aW9uIHJlY2VpcHQ6JywgSlNPTi5zdHJpbmdpZnkocmVjZWlwdCwgbnVsbCwgMikpXG4gICAgICBcbiAgICAgIGxldCBsaW5rSWQgPSAnJ1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0aGUgdHJhbnNhY3Rpb24gd2FzIHN1Y2Nlc3NmdWxcbiAgICAgIGlmIChyZWNlaXB0LnJlc3VsdD8uc3RhdHVzICE9PSAnMHgxJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIGZhaWxlZCAtIHN0YXR1czogJyArIHJlY2VpcHQucmVzdWx0Py5zdGF0dXMpXG4gICAgICB9XG5cbiAgICAgIC8vIEVuaGFuY2VkIGRlYnVnZ2luZyBvZiB0aGUgcmVjZWlwdCBzdHJ1Y3R1cmVcbiAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXB0IHN0YXR1czonLCByZWNlaXB0LnJlc3VsdD8uc3RhdHVzKVxuICAgICAgY29uc29sZS5sb2coJ1JlY2VpcHQgbG9ncyBhcnJheTonLCByZWNlaXB0LnJlc3VsdD8ubG9ncylcbiAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXB0IGxvZ3MgbGVuZ3RoOicsIHJlY2VpcHQucmVzdWx0Py5sb2dzPy5sZW5ndGgpXG4gICAgICBjb25zb2xlLmxvZygnUmVjZWlwdCBsb2dzQmxvb206JywgcmVjZWlwdC5yZXN1bHQ/LmxvZ3NCbG9vbSlcbiAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXB0IGNvbnRyYWN0QWRkcmVzczonLCByZWNlaXB0LnJlc3VsdD8uY29udHJhY3RBZGRyZXNzKVxuICAgICAgY29uc29sZS5sb2coJ1JlY2VpcHQgZ2FzVXNlZDonLCByZWNlaXB0LnJlc3VsdD8uZ2FzVXNlZClcbiAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXB0IGVmZmVjdGl2ZUdhc1ByaWNlOicsIHJlY2VpcHQucmVzdWx0Py5lZmZlY3RpdmVHYXNQcmljZSlcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhIGRpZmZlcmVudCBsb2NhdGlvbiBmb3IgbG9nc1xuICAgICAgY29uc29sZS5sb2coJ1JhdyB0cmFuc2FjdGlvbiBkYXRhOicsIHJlY2VpcHQucmVzdWx0Py5uZW9uUmF3VHJhbnNhY3Rpb24pXG4gICAgICBcbiAgICAgIC8vIE5vdGU6IGdldFRyYW5zYWN0aW9uIG1ldGhvZCBub3QgYXZhaWxhYmxlIG9uIE5lb25Qcm94eVJwY0FwaVxuICAgICAgLy8gVHJhbnNhY3Rpb24gZGV0YWlscyBhcmUgYWxyZWFkeSBpbiB0aGUgcmVjZWlwdFxuXG4gICAgICAvLyBFeHRyYWN0IGFsbCBuZW9uTG9ncyBmcm9tIHNvbGFuYVRyYW5zYWN0aW9uc1xuICAgICAgY29uc3QgYWxsTmVvbkxvZ3M6IGFueVtdID0gW11cbiAgICAgIGlmIChyZWNlaXB0LnJlc3VsdD8uc29sYW5hVHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc29sVHggb2YgcmVjZWlwdC5yZXN1bHQuc29sYW5hVHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgaWYgKHNvbFR4LnNvbGFuYUluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbnN0cnVjdGlvbiBvZiBzb2xUeC5zb2xhbmFJbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLm5lb25Mb2dzICYmIGluc3RydWN0aW9uLm5lb25Mb2dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBhbGxOZW9uTG9ncy5wdXNoKC4uLmluc3RydWN0aW9uLm5lb25Mb2dzKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCcsIGFsbE5lb25Mb2dzLmxlbmd0aCwgJ25lb25Mb2dzIHRvIHBhcnNlJylcblxuICAgICAgLy8gVHJ5IHRvIHBhcnNlIGxvZ3MgZm9yIHRoZSBTb2xhbmFMaW5rQ3JlYXRlZCBldmVudFxuICAgICAgaWYgKGFsbE5lb25Mb2dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChjb25zdCBsb2cgb2YgYWxsTmVvbkxvZ3MpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1RyeWluZyB0byBwYXJzZSBuZW9uTG9nOicsIGxvZylcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBsb2cgaXMgZnJvbSBvdXIgY29udHJhY3RcbiAgICAgICAgICAgIGlmIChsb2cuYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBDT05UUkFDVF9BRERSRVNTLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0xvZyBpcyBmcm9tIG91ciBjb250cmFjdCwgcGFyc2luZy4uLicpXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBsb2cgdG8gdGhlIGZvcm1hdCBleHBlY3RlZCBieSBldGhlcnNcbiAgICAgICAgICAgICAgY29uc3QgZXRoZXJzTG9nID0ge1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGxvZy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgIGRhdGE6IGxvZy5kYXRhLFxuICAgICAgICAgICAgICAgIHRvcGljczogbG9nLnRvcGljc1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBjb25zdCBwYXJzZWRMb2cgPSBpZmFjZS5wYXJzZUxvZyhldGhlcnNMb2cpXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQYXJzZWQgbG9nOicsIHBhcnNlZExvZylcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmIChwYXJzZWRMb2c/Lm5hbWUgPT09ICdTb2xhbmFMaW5rQ3JlYXRlZCcpIHtcbiAgICAgICAgICAgICAgICBsaW5rSWQgPSBwYXJzZWRMb2cuYXJncy5saW5rSWRcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIEZvdW5kIGxpbmsgSUQgZnJvbSBTb2xhbmFMaW5rQ3JlYXRlZCBldmVudDonLCBsaW5rSWQpXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0xvZyBmcm9tIGRpZmZlcmVudCBjb250cmFjdDonLCBsb2cuYWRkcmVzcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmFpbGVkIHRvIHBhcnNlIG5lb25Mb2c6JywgZSlcbiAgICAgICAgICAgIC8vIFNraXAgbG9ncyB0aGF0IGNhbid0IGJlIHBhcnNlZFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdObyBuZW9uTG9ncyBmb3VuZCBpbiB0cmFuc2FjdGlvbiByZWNlaXB0IScpXG4gICAgICAgIGNvbnNvbGUubG9nKCdUaGlzIG1pZ2h0IGluZGljYXRlOicpXG4gICAgICAgIGNvbnNvbGUubG9nKCcxLiBUaGUgY29udHJhY3QgY2FsbCBmYWlsZWQgc2lsZW50bHknKVxuICAgICAgICBjb25zb2xlLmxvZygnMi4gVGhlIGNvbnRyYWN0IGlzIG5vdCBhdCB0aGUgZXhwZWN0ZWQgYWRkcmVzcycpXG4gICAgICAgIGNvbnNvbGUubG9nKCczLiBUaGUgY29udHJhY3QgZnVuY3Rpb24gY2FsbCByZXZlcnRlZCcpXG4gICAgICAgIGNvbnNvbGUubG9nKCc0LiBFdmVudHMgYXJlIG5vdCBiZWluZyBlbWl0dGVkIHByb3Blcmx5JylcbiAgICAgICAgXG4gICAgICAgIC8vIFRyeSBjYWxsaW5nIHRoZSBjb250cmFjdCByZWFkIG1ldGhvZCB0byBzZWUgaWYgZGF0YSB3YXMgYWN0dWFsbHkgc3RvcmVkXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0F0dGVtcHRpbmcgdG8gcmVhZCBwYXltZW50IGxpbmsgdXNpbmcgdHJhbnNhY3Rpb24gaGFzaCBhcyBJRC4uLicpXG4gICAgICAgICAgY29uc3QgdGVzdERhdGEgPSBhd2FpdCB0aGlzLmNvbnRyYWN0IS5nZXRTb2xhbmFQYXltZW50TGluayh0eEhhc2gpXG4gICAgICAgICAgY29uc29sZS5sb2coJ0NvbnRyYWN0IHJlYWQgcmVzdWx0OicsIHRlc3REYXRhKVxuICAgICAgICB9IGNhdGNoIChyZWFkRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ29udHJhY3QgcmVhZCBmYWlsZWQ6JywgcmVhZEVycm9yKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlIGNvdWxkbid0IGV4dHJhY3QgZnJvbSBsb2dzLCBpbnZlc3RpZ2F0ZSBmdXJ0aGVyXG4gICAgICBpZiAoIWxpbmtJZCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdDb3VsZCBub3QgZXh0cmFjdCBsaW5rIElEIGZyb20gdHJhbnNhY3Rpb24gZXZlbnRzIScpXG4gICAgICAgIGNvbnNvbGUubG9nKCdUaGlzIHN1Z2dlc3RzIHRoZSBjb250cmFjdCBjYWxsIG1heSBoYXZlIGZhaWxlZCBzaWxlbnRseScpXG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgdHJhbnNhY3Rpb24gYWN0dWFsbHkgcmV2ZXJ0ZWRcbiAgICAgICAgY29uc29sZS5sb2coJ0NoZWNraW5nIGZvciByZXZlcnQgZGF0YS4uLicpXG4gICAgICAgIGlmIChyZWNlaXB0LnJlc3VsdD8ubmVvblJldmVydERhdGEpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnUmV2ZXJ0IGRhdGEgZm91bmQ6JywgcmVjZWlwdC5yZXN1bHQubmVvblJldmVydERhdGEpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBkZWNvZGUgdGhlIHJldmVydCByZWFzb25cbiAgICAgICAgICAgIGNvbnN0IHJldmVydFJlYXNvbiA9IGV0aGVycy50b1V0ZjhTdHJpbmcocmVjZWlwdC5yZXN1bHQubmVvblJldmVydERhdGEpXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUmV2ZXJ0IHJlYXNvbjonLCByZXZlcnRSZWFzb24pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnRyYWN0IGNhbGwgcmV2ZXJ0ZWQ6ICR7cmV2ZXJ0UmVhc29ufWApXG4gICAgICAgICAgfSBjYXRjaCAoZGVjb2RlRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb3VsZCBub3QgZGVjb2RlIHJldmVydCByZWFzb246JywgZGVjb2RlRXJyb3IpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRyYWN0IGNhbGwgcmV2ZXJ0ZWQgd2l0aCB1bmtub3duIHJlYXNvbicpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBMZXQncyB0cnkgdG8gdW5kZXJzdGFuZCB3aHkgdGhlIGV2ZW50IHdhc24ndCBlbWl0dGVkXG4gICAgICAgIGNvbnNvbGUubG9nKCdBbmFseXppbmcgZnVuY3Rpb24gY2FsbC4uLicpXG4gICAgICAgIGNvbnNvbGUubG9nKCdDb250cmFjdCBhZGRyZXNzOicsIENPTlRSQUNUX0FERFJFU1MpXG4gICAgICAgIGNvbnNvbGUubG9nKCdGcm9tIGFkZHJlc3M6JywgdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQpXG4gICAgICAgIGNvbnNvbGUubG9nKCdGdW5jdGlvbiBkYXRhIGluIHJhdyB0eDonLCByZWNlaXB0LnJlc3VsdD8ubmVvblJhd1RyYW5zYWN0aW9uKVxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgdXNlciBpcyByZWdpc3RlcmVkXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgaXNSZWdpc3RlcmVkID0gYXdhaXQgdGhpcy5jb250cmFjdCEuaXNTb2xhbmFVc2VyKHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0KVxuICAgICAgICAgIGNvbnNvbGUubG9nKCdJcyB1c2VyIHJlZ2lzdGVyZWQgYXMgU29sYW5hIHVzZXI6JywgaXNSZWdpc3RlcmVkKVxuICAgICAgICAgIFxuICAgICAgICAgIGlmICghaXNSZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZXIgaXMgbm90IHJlZ2lzdGVyZWQgYXMgYSBTb2xhbmEgdXNlciB3aXRoIHRoZSBjb250cmFjdC4gVGhpcyBpcyByZXF1aXJlZCB0byBjcmVhdGUgcGF5bWVudCBsaW5rcy4nKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAocmVnaXN0cmF0aW9uRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY2hlY2sgdXNlciByZWdpc3RyYXRpb246JywgcmVnaXN0cmF0aW9uRXJyb3IpXG4gICAgICAgICAgdGhyb3cgcmVnaXN0cmF0aW9uRXJyb3JcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIHNvbWV0aGluZyBlbHNlIHdlbnQgd3JvbmdcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXltZW50IGxpbmsgY3JlYXRpb24gZmFpbGVkOiBDb250cmFjdCBjYWxsIGV4ZWN1dGVkIGJ1dCBubyBldmVudCB3YXMgZW1pdHRlZC4gVGhlIHRyYW5zYWN0aW9uIG1heSBoYXZlIGZhaWxlZCBzaWxlbnRseS4nKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5rSWQsXG4gICAgICAgIHR4SGFzaFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHBheW1lbnQgbGluazonLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgcmVhZC1vbmx5IGNvbnRyYWN0IGFjY2VzcyAod2l0aG91dCB3YWxsZXQpXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGluaXRSZWFkT25seUNvbnRyYWN0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5jb250cmFjdCkge1xuICAgICAgLy8gQ3JlYXRlIGEgc2ltcGxlIEpTT04gUlBDIHByb3ZpZGVyIGZvciByZWFkIG9wZXJhdGlvbnNcbiAgICAgIGNvbnN0IHJlYWRPbmx5UHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihORU9OX0NPUkVfUlBDX1VSTClcbiAgICAgIHRoaXMuY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KENPTlRSQUNUX0FERFJFU1MsIFNPTEFOQV9USVBDQVJEX0FCSSwgcmVhZE9ubHlQcm92aWRlcilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHBheW1lbnQgbGluayBkZXRhaWxzXG4gICAqL1xuICBhc3luYyBnZXRQYXltZW50TGluayhsaW5rSWQ6IHN0cmluZyk6IFByb21pc2U8UGF5bWVudExpbms+IHtcbiAgICAvLyBJbml0aWFsaXplIGNvbnRyYWN0IGlmIG5vdCBhbHJlYWR5IGRvbmVcbiAgICBpZiAoIXRoaXMuY29udHJhY3QpIHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdFJlYWRPbmx5Q29udHJhY3QoKVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIHBheW1lbnQgbGluayB3aXRoIElEOicsIGxpbmtJZClcbiAgICBjb25zb2xlLmxvZygnQ29udHJhY3QgYWRkcmVzczonLCBDT05UUkFDVF9BRERSRVNTKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY29udHJhY3QhLmdldFNvbGFuYVBheW1lbnRMaW5rKGxpbmtJZClcbiAgICAgIGNvbnNvbGUubG9nKCdSYXcgY29udHJhY3QgcmVzdWx0OicsIHJlc3VsdClcbiAgICAgIFxuICAgICAgY29uc3QgcGF5bWVudExpbmsgPSB7XG4gICAgICAgIGV2bUNyZWF0b3I6IHJlc3VsdC5ldm1DcmVhdG9yLFxuICAgICAgICBzb2xhbmFDcmVhdG9yOiByZXN1bHQuc29sYW5hQ3JlYXRvcixcbiAgICAgICAgYW1vdW50OiByZXN1bHQuYW1vdW50LFxuICAgICAgICBpc0ZsZXhpYmxlOiByZXN1bHQuaXNGbGV4aWJsZSxcbiAgICAgICAgaXNBY3RpdmU6IHJlc3VsdC5pc0FjdGl2ZSxcbiAgICAgICAgdG90YWxSZWNlaXZlZDogcmVzdWx0LnRvdGFsUmVjZWl2ZWQsXG4gICAgICAgIHBheW1lbnRDb3VudDogTnVtYmVyKHJlc3VsdC5wYXltZW50Q291bnQpLFxuICAgICAgICBkZXNjcmlwdGlvbjogcmVzdWx0LmRlc2NyaXB0aW9uXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgbG9va3MgbGlrZSBhbiBlbXB0eS9ub24tZXhpc3RlbnQgbGluayAodHJhbnNhY3Rpb24gbm90IHByb2Nlc3NlZCB5ZXQpXG4gICAgICBpZiAocmVzdWx0LmV2bUNyZWF0b3IgPT09ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnICYmIFxuICAgICAgICAgIHJlc3VsdC5hbW91bnQgPT09IEJpZ0ludCgwKSAmJiBcbiAgICAgICAgICAhcmVzdWx0LmlzQWN0aXZlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignUGF5bWVudCBsaW5rIGFwcGVhcnMgdG8gYmUgZW1wdHkvbm9uLWV4aXN0ZW50JylcbiAgICAgICAgXG4gICAgICAgIC8vIElmIHRoaXMgbG9va3MgbGlrZSBhIHRyYW5zYWN0aW9uIGhhc2ggKDY2IGNoYXJzLCBzdGFydHMgd2l0aCAweCksIHByb3ZpZGUgaGVscGZ1bCBpbmZvXG4gICAgICAgIGlmIChsaW5rSWQubGVuZ3RoID09PSA2NiAmJiBsaW5rSWQuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5KhIFRoaXMgYXBwZWFycyB0byBiZSBhIHRyYW5zYWN0aW9uIGhhc2ggLSB0aGUgcGF5bWVudCBsaW5rIG1heSBzdGlsbCBiZSBwcm9jZXNzaW5nJylcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+SoSBOZW9uIG9wZXJhdG9ycyB3aWxsIGV2ZW50dWFsbHkgcHJvY2VzcyB0aGlzIHRyYW5zYWN0aW9uIGFuZCBjcmVhdGUgdGhlIHBheW1lbnQgbGluaycpXG4gICAgICAgICAgY29uc29sZS5sb2coJ/CfkqEgWW91IGNhbiBib29rbWFyayB0aGlzIGxpbmsgYW5kIHRyeSBhZ2FpbiBpbiBhIGZldyBtaW51dGVzJylcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGb3Igbm93LCBkb24ndCB0aHJvdyBhbiBlcnJvciAtIGxldCB0aGUgVUkgaGFuZGxlIHRoZSBlbXB0eSBkYXRhIGdyYWNlZnVsbHlcbiAgICAgICAgICBjb25zb2xlLmxvZygnUmV0dXJuaW5nIGVtcHR5IHBheW1lbnQgbGluayBkYXRhIC0gdHJhbnNhY3Rpb24gbWF5IHN0aWxsIGJlIHByb2Nlc3NpbmcnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBwYXltZW50TGlua1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDb250cmFjdCBjYWxsIGVycm9yOicsIGVycm9yKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXltZW50IGxpbmsgbm90IGZvdW5kIG9yIGNvbnRyYWN0IGVycm9yJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHVzZXIncyBwYXltZW50IGxpbmtzXG4gICAqL1xuICBhc3luYyBnZXRVc2VyTGlua3ModXNlckVWTUFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICAvLyBJbml0aWFsaXplIGNvbnRyYWN0IGlmIG5vdCBhbHJlYWR5IGRvbmVcbiAgICBpZiAoIXRoaXMuY29udHJhY3QpIHtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdFJlYWRPbmx5Q29udHJhY3QoKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb250cmFjdCEuZ2V0VXNlclNvbGFuYUxpbmtzKHVzZXJFVk1BZGRyZXNzKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHVzZXIgbGlua3M6JywgZXJyb3IpXG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGF5IGEgcGF5bWVudCBsaW5rIHVzaW5nIFNvbGFuYSBOYXRpdmUgU0RLXG4gICAqL1xuICBhc3luYyBwYXlMaW5rKFxuICAgIGxpbmtJZDogc3RyaW5nLFxuICAgIGFtb3VudFNPTDogbnVtYmVyXG4gICk6IFByb21pc2U8eyB0eEhhc2g6IHN0cmluZzsgdHJhbnNmZXJTaWduYXR1cmU/OiBzdHJpbmcgfT4ge1xuICAgIGlmICghdGhpcy5zb2xhbmFVc2VyIHx8ICF0aGlzLmNvbnRyYWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBjb25uZWN0IHdhbGxldCBmaXJzdCcpXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIHBheW1lbnQgcHJvY2Vzcy4uLicpXG4gICAgY29uc29sZS5sb2coJ0xpbmsgSUQ6JywgbGlua0lkKVxuICAgIGNvbnNvbGUubG9nKCdBbW91bnQgU09MOicsIGFtb3VudFNPTClcblxuICAgIC8vIEZpcnN0LCBnZXQgdGhlIHBheW1lbnQgbGluayBkZXRhaWxzIHRvIGZpbmQgdGhlIHJlY2lwaWVudFxuICAgIGNvbnN0IGxpbmtEYXRhID0gYXdhaXQgdGhpcy5nZXRQYXltZW50TGluayhsaW5rSWQpXG4gICAgY29uc29sZS5sb2coJ1BheW1lbnQgbGluayBkYXRhOicsIGxpbmtEYXRhKVxuXG4gICAgaWYgKCFsaW5rRGF0YS5pc0FjdGl2ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXltZW50IGxpbmsgaXMgbm8gbG9uZ2VyIGFjdGl2ZScpXG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBTT0wgdG8gbGFtcG9ydHNcbiAgICBjb25zdCBhbW91bnRMYW1wb3J0cyA9IE1hdGguZmxvb3IoYW1vdW50U09MICogMWU5KVxuICAgIFxuICAgIGxldCB0cmFuc2ZlclNpZ25hdHVyZTogc3RyaW5nIHwgdW5kZWZpbmVkXG5cbiAgICB0cnkge1xuICAgICAgLy8gU3RlcCAxOiBQZXJmb3JtIHRoZSBhY3R1YWwgU09MIHRyYW5zZmVyIGZpcnN0XG4gICAgICBjb25zb2xlLmxvZygnU3RlcCAxOiBQZXJmb3JtaW5nIFNPTCB0cmFuc2Zlci4uLicpXG4gICAgICBjb25zb2xlLmxvZygnRnJvbTonLCB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LnRvQmFzZTU4KCkpXG4gICAgICBjb25zb2xlLmxvZygnVG8gcmVjaXBpZW50IGJ5dGVzMzI6JywgbGlua0RhdGEuc29sYW5hQ3JlYXRvcilcbiAgICAgIGNvbnNvbGUubG9nKCdBbW91bnQgbGFtcG9ydHM6JywgYW1vdW50TGFtcG9ydHMpXG5cbiAgICAgIC8vIENvbnZlcnQgcmVjaXBpZW50IFNvbGFuYSBhZGRyZXNzIGZyb20gYnl0ZXMzMiB0byBQdWJsaWNLZXlcbiAgICAgIC8vIFJlbW92ZSAnMHgnIHByZWZpeCBpZiBwcmVzZW50XG4gICAgICBjb25zdCBoZXhTdHJpbmcgPSBsaW5rRGF0YS5zb2xhbmFDcmVhdG9yLnN0YXJ0c1dpdGgoJzB4JykgXG4gICAgICAgID8gbGlua0RhdGEuc29sYW5hQ3JlYXRvci5zbGljZSgyKSBcbiAgICAgICAgOiBsaW5rRGF0YS5zb2xhbmFDcmVhdG9yXG4gICAgICBcbiAgICAgIC8vIENvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG4gICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGhleFN0cmluZy5tYXRjaCgvLnsyfS9nKT8ubWFwKGJ5dGUgPT4gcGFyc2VJbnQoYnl0ZSwgMTYpKSB8fCBbXSlcbiAgICAgIFxuICAgICAgLy8gRm9yIGJ5dGVzMzIgZnJvbSBTb2xhbmEgYWRkcmVzc2VzLCB3ZSBuZWVkIHRvIGZpbmQgdGhlIGFjdHVhbCAzMi1ieXRlIHB1YmxpYyBrZXlcbiAgICAgIC8vIFRoZSBieXRlczMyIHNob3VsZCBjb250YWluIHRoZSAzMi1ieXRlIFNvbGFuYSBwdWJsaWMga2V5LCBwb3NzaWJseSB3aXRoIGxlYWRpbmcgemVyb3NcbiAgICAgIGxldCByZWNpcGllbnRQdWJrZXlcbiAgICAgIFxuICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMzIpIHtcbiAgICAgICAgLy8gRGlyZWN0IGNvbnZlcnNpb24gZnJvbSAzMiBieXRlc1xuICAgICAgICByZWNpcGllbnRQdWJrZXkgPSBuZXcgKGF3YWl0IGltcG9ydCgnQHNvbGFuYS93ZWIzLmpzJykpLlB1YmxpY0tleShieXRlcylcbiAgICAgIH0gZWxzZSBpZiAoYnl0ZXMubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgLy8gVGFrZSB0aGUgbGFzdCAzMiBieXRlcyBpZiBpdCdzIGxvbmdlclxuICAgICAgICBjb25zdCBsYXN0MzJCeXRlcyA9IGJ5dGVzLnNsaWNlKC0zMilcbiAgICAgICAgcmVjaXBpZW50UHVia2V5ID0gbmV3IChhd2FpdCBpbXBvcnQoJ0Bzb2xhbmEvd2ViMy5qcycpKS5QdWJsaWNLZXkobGFzdDMyQnl0ZXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBQYWQgd2l0aCBsZWFkaW5nIHplcm9zIGlmIHNob3J0ZXJcbiAgICAgICAgY29uc3QgcGFkZGVkQnl0ZXMgPSBuZXcgVWludDhBcnJheSgzMilcbiAgICAgICAgcGFkZGVkQnl0ZXMuc2V0KGJ5dGVzLCAzMiAtIGJ5dGVzLmxlbmd0aClcbiAgICAgICAgcmVjaXBpZW50UHVia2V5ID0gbmV3IChhd2FpdCBpbXBvcnQoJ0Bzb2xhbmEvd2ViMy5qcycpKS5QdWJsaWNLZXkocGFkZGVkQnl0ZXMpXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdSZWNpcGllbnQgUHVibGljS2V5OicsIHJlY2lwaWVudFB1YmtleS50b0Jhc2U1OCgpKVxuXG4gICAgICAvLyBDcmVhdGUgdGhlIFNPTCB0cmFuc2ZlciB0cmFuc2FjdGlvblxuICAgICAgY29uc3QgeyBTeXN0ZW1Qcm9ncmFtLCBUcmFuc2FjdGlvbiB9ID0gYXdhaXQgaW1wb3J0KCdAc29sYW5hL3dlYjMuanMnKVxuXG4gICAgICAvLyBDcmVhdGUgdHJhbnNmZXIgaW5zdHJ1Y3Rpb25cbiAgICAgIGNvbnN0IHRyYW5zZmVySXggPSBTeXN0ZW1Qcm9ncmFtLnRyYW5zZmVyKHtcbiAgICAgICAgZnJvbVB1YmtleTogdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleSxcbiAgICAgICAgdG9QdWJrZXk6IHJlY2lwaWVudFB1YmtleSxcbiAgICAgICAgbGFtcG9ydHM6IGFtb3VudExhbXBvcnRzXG4gICAgICB9KVxuXG4gICAgICAvLyBDcmVhdGUgdHJhbnNhY3Rpb25cbiAgICAgIGNvbnN0IHRyYW5zZmVyVHggPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQodHJhbnNmZXJJeClcbiAgICAgIFxuICAgICAgLy8gR2V0IGZyZXNoIHJlY2VudCBibG9ja2hhc2ggcmlnaHQgYmVmb3JlIHNpZ25pbmdcbiAgICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIGZyZXNoIGJsb2NraGFzaCBmb3IgU09MIHRyYW5zZmVyLi4uJylcbiAgICAgIGNvbnN0IHsgYmxvY2toYXNoLCBsYXN0VmFsaWRCbG9ja0hlaWdodDogdHJhbnNmZXJCbG9ja0hlaWdodCB9ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgnY29uZmlybWVkJylcbiAgICAgIGNvbnNvbGUubG9nKCdGcmVzaCBTT0wgdHJhbnNmZXIgYmxvY2toYXNoOicsIGJsb2NraGFzaClcbiAgICAgIGNvbnNvbGUubG9nKCdMYXN0IHZhbGlkIGJsb2NrIGhlaWdodDonLCB0cmFuc2ZlckJsb2NrSGVpZ2h0KVxuICAgICAgXG4gICAgICB0cmFuc2ZlclR4LnJlY2VudEJsb2NraGFzaCA9IGJsb2NraGFzaFxuICAgICAgdHJhbnNmZXJUeC5mZWVQYXllciA9IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXlcblxuICAgICAgLy8gU2lnbiBhbmQgc2VuZCB0aGUgU09MIHRyYW5zZmVyIGltbWVkaWF0ZWx5XG4gICAgICBjb25zb2xlLmxvZygnU2lnbmluZyBhbmQgc2VuZGluZyBTT0wgdHJhbnNmZXIgd2l0aCBmcmVzaCBibG9ja2hhc2guLi4nKVxuICAgICAgY29uc3Qgc2lnbmVkVHJhbnNmZXJUeCA9IGF3YWl0IHRoaXMuc29sYW5hVXNlci53YWxsZXRBZGFwdGVyLnNpZ25UcmFuc2FjdGlvbih0cmFuc2ZlclR4KVxuICAgICAgdHJhbnNmZXJTaWduYXR1cmUgPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uc2VuZFJhd1RyYW5zYWN0aW9uKHNpZ25lZFRyYW5zZmVyVHguc2VyaWFsaXplKCkpXG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdTT0wgdHJhbnNmZXIgc2VudDonLCB0cmFuc2ZlclNpZ25hdHVyZSlcbiAgICAgIFxuICAgICAgLy8gV2FpdCBmb3IgdHJhbnNmZXIgY29uZmlybWF0aW9uIHVzaW5nIHRoZSBtb2Rlcm4gQVBJXG4gICAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHtcbiAgICAgICAgc2lnbmF0dXJlOiB0cmFuc2ZlclNpZ25hdHVyZSxcbiAgICAgICAgLi4uKGF3YWl0IHRoaXMuY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goKSlcbiAgICAgIH0pXG4gICAgICBjb25zb2xlLmxvZygnU09MIHRyYW5zZmVyIGNvbmZpcm1lZCcpXG5cbiAgICAgIC8vIFN0ZXAgMjogUmVjb3JkIHRoZSBwYXltZW50IGluIHRoZSBjb250cmFjdFxuICAgICAgY29uc29sZS5sb2coJ1N0ZXAgMjogUmVjb3JkaW5nIHBheW1lbnQgaW4gY29udHJhY3QuLi4nKVxuICAgICAgXG4gICAgICAvLyBDb252ZXJ0IFNvbGFuYSBQdWJsaWNLZXkgdG8gYnl0ZXMzMlxuICAgICAgY29uc3QgcGF5ZXJTb2xhbmFCeXRlczMyID0gemVyb1BhZFZhbHVlKGhleGxpZnkodGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleS50b0J5dGVzKCkpLCAzMilcblxuICAgICAgLy8gR2V0IGN1cnJlbnQgbm9uY2VcbiAgICAgIGNvbnN0IG5vbmNlID0gTnVtYmVyKGF3YWl0IHRoaXMucHJveHlBcGkuZ2V0VHJhbnNhY3Rpb25Db3VudCh0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCkpXG4gICAgICBjb25zb2xlLmxvZygnQ3VycmVudCBub25jZTonLCBub25jZSlcblxuICAgICAgLy8gUHJlcGFyZSBjb250cmFjdCBjYWxsIGRhdGFcbiAgICAgIGNvbnN0IGlmYWNlID0gbmV3IGV0aGVycy5JbnRlcmZhY2UoU09MQU5BX1RJUENBUkRfQUJJKVxuICAgICAgY29uc3QgZGF0YSA9IGlmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YSgncGF5U29sYW5hTGluaycsIFtcbiAgICAgICAgbGlua0lkLFxuICAgICAgICBhbW91bnRMYW1wb3J0cyxcbiAgICAgICAgcGF5ZXJTb2xhbmFCeXRlczMyXG4gICAgICBdKVxuXG4gICAgICAvLyBDcmVhdGUgdHJhbnNhY3Rpb24gZGF0YVxuICAgICAgY29uc3QgdHJhbnNhY3Rpb25EYXRhID0ge1xuICAgICAgICBmcm9tOiB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCxcbiAgICAgICAgdG86IENPTlRSQUNUX0FERFJFU1MsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH1cblxuICAgICAgLy8gRXN0aW1hdGUgZ2FzXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkdhcyA9IGF3YWl0IHRoaXMucHJveHlBcGkuZXN0aW1hdGVTY2hlZHVsZWRUcmFuc2FjdGlvbkdhcyh7XG4gICAgICAgIHNvbGFuYVBheWVyOiB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LFxuICAgICAgICB0cmFuc2FjdGlvbnM6IFt0cmFuc2FjdGlvbkRhdGFdLFxuICAgICAgfSlcblxuICAgICAgLy8gQ3JlYXRlIHNjaGVkdWxlZCB0cmFuc2FjdGlvblxuICAgICAgbGV0IHsgc2NoZWR1bGVkVHJhbnNhY3Rpb24gfSA9IGF3YWl0IHRoaXMucHJveHlBcGkuY3JlYXRlU2NoZWR1bGVkVHJhbnNhY3Rpb24oe1xuICAgICAgICB0cmFuc2FjdGlvbkdhcyxcbiAgICAgICAgdHJhbnNhY3Rpb25EYXRhLFxuICAgICAgICBub25jZVxuICAgICAgfSlcblxuICAgICAgLy8gR2V0IGZyZXNoIHJlY2VudCBibG9ja2hhc2ggcmlnaHQgYmVmb3JlIHNpZ25pbmdcbiAgICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIGZyZXNoIGJsb2NraGFzaCBmb3IgY29udHJhY3QgY2FsbC4uLicpXG4gICAgICBjb25zdCB7IGJsb2NraGFzaDogY29udHJhY3RCbG9ja2hhc2gsIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiBjb250cmFjdEJsb2NrSGVpZ2h0IH0gPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCdjb25maXJtZWQnKVxuICAgICAgY29uc29sZS5sb2coJ0ZyZXNoIGNvbnRyYWN0IGNhbGwgYmxvY2toYXNoOicsIGNvbnRyYWN0QmxvY2toYXNoKVxuICAgICAgY29uc29sZS5sb2coJ0xhc3QgdmFsaWQgYmxvY2sgaGVpZ2h0OicsIGNvbnRyYWN0QmxvY2tIZWlnaHQpXG4gICAgICBcbiAgICAgIHNjaGVkdWxlZFRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGNvbnRyYWN0QmxvY2toYXNoXG4gICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5mZWVQYXllciA9IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXlcblxuICAgICAgLy8gU2lnbiB3aXRoIHdhbGxldCBhZGFwdGVyIChmcm9udGVuZCBhcHByb2FjaClcbiAgICAgIGNvbnNvbGUubG9nKCdTaWduaW5nIGNvbnRyYWN0IGNhbGwgd2l0aCBmcmVzaCBibG9ja2hhc2guLi4nKVxuICAgICAgY29uc3Qgc2lnbmVkVHggPSBhd2FpdCB0aGlzLnNvbGFuYVVzZXIud2FsbGV0QWRhcHRlci5zaWduVHJhbnNhY3Rpb24oc2NoZWR1bGVkVHJhbnNhY3Rpb24pXG4gICAgICBcbiAgICAgIC8vIFNlbmQgdHJhbnNhY3Rpb24gaW1tZWRpYXRlbHlcbiAgICAgIGNvbnNvbGUubG9nKCdTZW5kaW5nIGNvbnRyYWN0IGNhbGwgdHJhbnNhY3Rpb24gaW1tZWRpYXRlbHkuLi4nKVxuICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihzaWduZWRUeC5zZXJpYWxpemUoKSlcblxuICAgICAgLy8gV2FpdCBmb3IgdHJhbnNhY3Rpb24gZXhlY3V0aW9uIG9uIE5lb24gRVZNXG4gICAgICBjb25zdCB0cmFuc2FjdGlvblN0YXR1cyA9IGF3YWl0IHRoaXMucHJveHlBcGkud2FpdFRyYW5zYWN0aW9uVHJlZUV4ZWN1dGlvbihcbiAgICAgICAgdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsIFxuICAgICAgICBub25jZSwgXG4gICAgICAgIDYwMDAwXG4gICAgICApXG5cbiAgICAgIGlmICh0cmFuc2FjdGlvblN0YXR1cy5sZW5ndGggPT09IDAgfHwgdHJhbnNhY3Rpb25TdGF0dXNbMF0uc3RhdHVzICE9PSAnU3VjY2VzcycpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDb250cmFjdCBwYXltZW50IHJlY29yZGluZyBmYWlsZWQsIGJ1dCBTT0wgdHJhbnNmZXIgc3VjY2VlZGVkJylcbiAgICAgICAgY29uc29sZS5sb2coJ1RyYW5zZmVyIHNpZ25hdHVyZTonLCB0cmFuc2ZlclNpZ25hdHVyZSlcbiAgICAgICAgLy8gRG9uJ3QgdGhyb3cgZXJyb3IgLSB0aGUgcGF5bWVudCB3ZW50IHRocm91Z2ggZXZlbiBpZiByZWNvcmRpbmcgZmFpbGVkXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdQYXltZW50IGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkhJylcbiAgICAgIGNvbnNvbGUubG9nKCdTT0wgdHJhbnNmZXI6JywgdHJhbnNmZXJTaWduYXR1cmUpXG4gICAgICBjb25zb2xlLmxvZygnQ29udHJhY3QgcmVjb3JkOicsIHRyYW5zYWN0aW9uU3RhdHVzWzBdPy50cmFuc2FjdGlvbkhhc2gpXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR4SGFzaDogdHJhbnNhY3Rpb25TdGF0dXNbMF0/LnRyYW5zYWN0aW9uSGFzaCB8fCAnY29udHJhY3QtcmVjb3JkaW5nLWZhaWxlZCcsXG4gICAgICAgIHRyYW5zZmVyU2lnbmF0dXJlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGF5aW5nIGxpbms6JywgZXJyb3IpXG4gICAgICBpZiAodHJhbnNmZXJTaWduYXR1cmUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ05vdGU6IFNPTCB0cmFuc2ZlciBtYXkgaGF2ZSBzdWNjZWVkZWQ6JywgdHJhbnNmZXJTaWduYXR1cmUpXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWFjdGl2YXRlIGEgcGF5bWVudCBsaW5rXG4gICAqL1xuICBhc3luYyBkZWFjdGl2YXRlTGluayhsaW5rSWQ6IHN0cmluZyk6IFByb21pc2U8eyB0eEhhc2g6IHN0cmluZyB9PiB7XG4gICAgaWYgKCF0aGlzLnNvbGFuYVVzZXIgfHwgIXRoaXMuY29udHJhY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIGNvbm5lY3Qgd2FsbGV0IGZpcnN0JylcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gR2V0IGN1cnJlbnQgbm9uY2VcbiAgICAgIGNvbnN0IG5vbmNlID0gTnVtYmVyKGF3YWl0IHRoaXMucHJveHlBcGkuZ2V0VHJhbnNhY3Rpb25Db3VudCh0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCkpXG4gICAgICBjb25zb2xlLmxvZygnQ3VycmVudCBub25jZTonLCBub25jZSlcblxuICAgICAgLy8gUHJlcGFyZSBjb250cmFjdCBjYWxsIGRhdGFcbiAgICAgIGNvbnN0IGlmYWNlID0gbmV3IGV0aGVycy5JbnRlcmZhY2UoU09MQU5BX1RJUENBUkRfQUJJKVxuICAgICAgY29uc3QgZGF0YSA9IGlmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YSgnZGVhY3RpdmF0ZVNvbGFuYUxpbmsnLCBbbGlua0lkXSlcblxuICAgICAgLy8gQ3JlYXRlIHRyYW5zYWN0aW9uIGRhdGFcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uRGF0YSA9IHtcbiAgICAgICAgZnJvbTogdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsXG4gICAgICAgIHRvOiBDT05UUkFDVF9BRERSRVNTLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9XG5cbiAgICAgIC8vIEVzdGltYXRlIGdhc1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25HYXMgPSBhd2FpdCB0aGlzLnByb3h5QXBpLmVzdGltYXRlU2NoZWR1bGVkVHJhbnNhY3Rpb25HYXMoe1xuICAgICAgICBzb2xhbmFQYXllcjogdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleSxcbiAgICAgICAgdHJhbnNhY3Rpb25zOiBbdHJhbnNhY3Rpb25EYXRhXSxcbiAgICAgIH0pXG5cbiAgICAgIC8vIENyZWF0ZSBzY2hlZHVsZWQgdHJhbnNhY3Rpb25cbiAgICAgIGxldCB7IHNjaGVkdWxlZFRyYW5zYWN0aW9uIH0gPSBhd2FpdCB0aGlzLnByb3h5QXBpLmNyZWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgdHJhbnNhY3Rpb25HYXMsXG4gICAgICAgIHRyYW5zYWN0aW9uRGF0YSxcbiAgICAgICAgbm9uY2VcbiAgICAgIH0pXG5cbiAgICAgIC8vIEdldCBmcmVzaCByZWNlbnQgYmxvY2toYXNoIHJpZ2h0IGJlZm9yZSBzaWduaW5nXG4gICAgICBjb25zb2xlLmxvZygnR2V0dGluZyBmcmVzaCBibG9ja2hhc2ggZm9yIGRlYWN0aXZhdGUgdHJhbnNhY3Rpb24uLi4nKVxuICAgICAgY29uc3QgeyBibG9ja2hhc2gsIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiBkZWFjdGl2YXRlQmxvY2tIZWlnaHQgfSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goJ2NvbmZpcm1lZCcpXG4gICAgICBjb25zb2xlLmxvZygnRnJlc2ggZGVhY3RpdmF0ZSBibG9ja2hhc2g6JywgYmxvY2toYXNoKVxuICAgICAgY29uc29sZS5sb2coJ0xhc3QgdmFsaWQgYmxvY2sgaGVpZ2h0OicsIGRlYWN0aXZhdGVCbG9ja0hlaWdodClcbiAgICAgIFxuICAgICAgc2NoZWR1bGVkVHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoXG4gICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5mZWVQYXllciA9IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXlcblxuICAgICAgLy8gU2lnbiB3aXRoIHdhbGxldCBhZGFwdGVyIChmcm9udGVuZCBhcHByb2FjaClcbiAgICAgIGNvbnNvbGUubG9nKCdTaWduaW5nIGRlYWN0aXZhdGUgdHJhbnNhY3Rpb24gd2l0aCBmcmVzaCBibG9ja2hhc2guLi4nKVxuICAgICAgY29uc3Qgc2lnbmVkVHggPSBhd2FpdCB0aGlzLnNvbGFuYVVzZXIud2FsbGV0QWRhcHRlci5zaWduVHJhbnNhY3Rpb24oc2NoZWR1bGVkVHJhbnNhY3Rpb24pXG4gICAgICBcbiAgICAgIC8vIFNlbmQgdHJhbnNhY3Rpb24gaW1tZWRpYXRlbHlcbiAgICAgIGNvbnNvbGUubG9nKCdTZW5kaW5nIGRlYWN0aXZhdGUgdHJhbnNhY3Rpb24gaW1tZWRpYXRlbHkuLi4nKVxuICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihzaWduZWRUeC5zZXJpYWxpemUoKSlcblxuICAgICAgLy8gV2FpdCBmb3IgdHJhbnNhY3Rpb24gZXhlY3V0aW9uXG4gICAgICBjb25zdCB0cmFuc2FjdGlvblN0YXR1cyA9IGF3YWl0IHRoaXMucHJveHlBcGkud2FpdFRyYW5zYWN0aW9uVHJlZUV4ZWN1dGlvbihcbiAgICAgICAgdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsIFxuICAgICAgICBub25jZSwgXG4gICAgICAgIDYwMDAwXG4gICAgICApXG5cbiAgICAgIGlmICh0cmFuc2FjdGlvblN0YXR1cy5sZW5ndGggPT09IDAgfHwgdHJhbnNhY3Rpb25TdGF0dXNbMF0uc3RhdHVzICE9PSAnU3VjY2VzcycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWFjdGl2YXRpb24gdHJhbnNhY3Rpb24gZmFpbGVkIHRvIGV4ZWN1dGUgb24gTmVvbiBFVk0nKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eEhhc2g6IHRyYW5zYWN0aW9uU3RhdHVzWzBdLnRyYW5zYWN0aW9uSGFzaFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNoYXJlYWJsZSBVUkwgZm9yIGEgcGF5bWVudCBsaW5rXG4gICAqL1xuICBjcmVhdGVQYXltZW50VVJMKGxpbmtJZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn0/cGF5PSR7bGlua0lkfWBcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IGxpbmsgSUQgZnJvbSBVUkxcbiAgICovXG4gIHN0YXRpYyBleHRyYWN0TGlua0lkRnJvbVVSTCh1cmw6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1cmxPYmogPSBuZXcgVVJMKHVybClcbiAgICAgIHJldHVybiB1cmxPYmouc2VhcmNoUGFyYW1zLmdldCgncGF5JylcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdXNlcidzIEVWTSBhZGRyZXNzIGRlcml2ZWQgZnJvbSBTb2xhbmEgcHVibGljIGtleVxuICAgKi9cbiAgZ2V0VXNlckVWTUFkZHJlc3MoKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuc29sYW5hVXNlcj8ubmVvbldhbGxldCB8fCBudWxsXG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IHNvbGFuYU5hdGl2ZUNvbnRyYWN0ID0gbmV3IFNvbGFuYU5hdGl2ZUNvbnRyYWN0KCkiXSwibmFtZXMiOlsiQ29ubmVjdGlvbiIsIk5lb25Qcm94eVJwY0FwaSIsImNyZWF0ZUJhbGFuY2VBY2NvdW50SW5zdHJ1Y3Rpb24iLCJldGhlcnMiLCJoZXhsaWZ5IiwiemVyb1BhZFZhbHVlIiwiQ29udHJhY3RBQkkiLCJTT0xBTkFfVElQQ0FSRF9BQkkiLCJDT05UUkFDVF9BRERSRVNTIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1RJUENBUkRfQ09OVFJBQ1RfQUREUkVTUyIsIk5FT05fQ09SRV9SUENfVVJMIiwiTkVYVF9QVUJMSUNfTkVPTl9SUENfVVJMIiwiTkVPTl9QUk9YWV9SUENfVVJMIiwiU09MQU5BX1JQQ19VUkwiLCJTb2xhbmFOYXRpdmVDb250cmFjdCIsImluaXRXaXRoU29sYW5hV2FsbGV0Iiwid2FsbGV0QWRhcHRlciIsInB1YmxpY0tleSIsIkVycm9yIiwiY29uc29sZSIsImxvZyIsInRvQmFzZTU4IiwicHJvdmlkZXIiLCJjaGFpbklkIiwic29sYW5hVXNlciIsInRva2VuTWludEFkZHJlc3MiLCJwcm9ncmFtQWRkcmVzcyIsInByb3h5QXBpIiwiaW5pdCIsImJhbGFuY2VBZGRyZXNzIiwiU29sYW5hTmVvbkFjY291bnQiLCJhY2NvdW50IiwibmVvbkV2bVByb2dyYW0iLCJ0b2tlbk1pbnQiLCJuZW9uV2FsbGV0IiwiZXJyb3IiLCJyZWFkT25seVByb3ZpZGVyIiwiSnNvblJwY1Byb3ZpZGVyIiwiY29udHJhY3QiLCJDb250cmFjdCIsInR4Q291bnQiLCJnZXRUcmFuc2FjdGlvbkNvdW50IiwidmVyaWZ5RXJyb3IiLCJjb2RlIiwiZ2V0Q29kZSIsImxlbmd0aCIsIndhcm4iLCJjcmVhdGVQYXltZW50TGluayIsInN1Z2dlc3RlZEFtb3VudFNPTCIsImlzRmxleGlibGUiLCJkZXNjcmlwdGlvbiIsImFtb3VudExhbXBvcnRzIiwiTWF0aCIsImZsb29yIiwic2NoZWR1bGVkVHJhbnNhY3Rpb24iLCJyZWNlaXB0Iiwibm9uY2UiLCJOdW1iZXIiLCJpZmFjZSIsIkludGVyZmFjZSIsImRhdGEiLCJlbmNvZGVGdW5jdGlvbkRhdGEiLCJ0cmFuc2FjdGlvbkRhdGEiLCJmcm9tIiwidG8iLCJ0cmFuc2FjdGlvbkdhcyIsImVzdGltYXRlU2NoZWR1bGVkVHJhbnNhY3Rpb25HYXMiLCJzb2xhbmFQYXllciIsInRyYW5zYWN0aW9ucyIsImNyZWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uIiwiY29ubmVjdGlvbiIsImdldEFjY291bnRJbmZvIiwiaW5zdHJ1Y3Rpb25zIiwidW5zaGlmdCIsImJsb2NraGFzaCIsImdldExhdGVzdEJsb2NraGFzaCIsInJlY2VudEJsb2NraGFzaCIsImZlZVBheWVyIiwic2lnbmVkVHJhbnNhY3Rpb24iLCJzaWduVHJhbnNhY3Rpb24iLCJzaWduYXR1cmUiLCJzZW5kUmF3VHJhbnNhY3Rpb24iLCJzZXJpYWxpemUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJjb25maXJtYXRpb24iLCJnZXRTaWduYXR1cmVTdGF0dXMiLCJ2YWx1ZSIsImNvbmZpcm1hdGlvblN0YXR1cyIsIm5lb25UeFJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJwYXJhbXMiLCJzb2xhbmFVc2VyMiIsImlkIiwianNvbnJwYyIsIm5lb25UeFJlc3VsdCIsImpzb24iLCJyZXN1bHQiLCJoYXNoIiwibGlua0RldGFpbHMiLCJzb2xhbmFUaXBDYXJkIiwiZ2V0U29sYW5hUGF5bWVudExpbmsiLCJjcmVhdGVkTGlua0lkIiwiZm9ybWF0VW5pdHMiLCJ0b3RhbFJlY2VpdmVkIiwicGF5bWVudENvdW50IiwiaXNBY3RpdmUiLCJsaW5rRXJyb3IiLCJtZXNzYWdlIiwibmVvbkVycm9yIiwiY29uZmlybUVycm9yIiwidHJhbnNhY3Rpb25TdGF0dXMiLCJ3YWl0VHJhbnNhY3Rpb25UcmVlRXhlY3V0aW9uIiwidHhTdGF0dXMiLCJzdGF0dXMiLCJ0cmFuc2FjdGlvbkhhc2giLCJsaW5rSWQiLCJ0eEhhc2giLCJnZXRUcmFuc2FjdGlvblJlY2VpcHQiLCJsb2dzIiwibG9nc0Jsb29tIiwiY29udHJhY3RBZGRyZXNzIiwiZ2FzVXNlZCIsImVmZmVjdGl2ZUdhc1ByaWNlIiwibmVvblJhd1RyYW5zYWN0aW9uIiwiYWxsTmVvbkxvZ3MiLCJzb2xhbmFUcmFuc2FjdGlvbnMiLCJzb2xUeCIsInNvbGFuYUluc3RydWN0aW9ucyIsImluc3RydWN0aW9uIiwibmVvbkxvZ3MiLCJwdXNoIiwiYWRkcmVzcyIsInRvTG93ZXJDYXNlIiwiZXRoZXJzTG9nIiwidG9waWNzIiwicGFyc2VkTG9nIiwicGFyc2VMb2ciLCJuYW1lIiwiYXJncyIsImUiLCJ0ZXN0RGF0YSIsInJlYWRFcnJvciIsIm5lb25SZXZlcnREYXRhIiwicmV2ZXJ0UmVhc29uIiwidG9VdGY4U3RyaW5nIiwiZGVjb2RlRXJyb3IiLCJpc1JlZ2lzdGVyZWQiLCJpc1NvbGFuYVVzZXIiLCJyZWdpc3RyYXRpb25FcnJvciIsImluaXRSZWFkT25seUNvbnRyYWN0IiwiZ2V0UGF5bWVudExpbmsiLCJwYXltZW50TGluayIsImV2bUNyZWF0b3IiLCJzb2xhbmFDcmVhdG9yIiwiYW1vdW50IiwiQmlnSW50Iiwic3RhcnRzV2l0aCIsImdldFVzZXJMaW5rcyIsInVzZXJFVk1BZGRyZXNzIiwiZ2V0VXNlclNvbGFuYUxpbmtzIiwicGF5TGluayIsImFtb3VudFNPTCIsImxpbmtEYXRhIiwidHJhbnNmZXJTaWduYXR1cmUiLCJoZXhTdHJpbmciLCJzbGljZSIsImJ5dGVzIiwiVWludDhBcnJheSIsIm1hdGNoIiwibWFwIiwiYnl0ZSIsInBhcnNlSW50IiwicmVjaXBpZW50UHVia2V5IiwiUHVibGljS2V5IiwibGFzdDMyQnl0ZXMiLCJwYWRkZWRCeXRlcyIsInNldCIsIlN5c3RlbVByb2dyYW0iLCJUcmFuc2FjdGlvbiIsInRyYW5zZmVySXgiLCJ0cmFuc2ZlciIsImZyb21QdWJrZXkiLCJ0b1B1YmtleSIsImxhbXBvcnRzIiwidHJhbnNmZXJUeCIsImFkZCIsImxhc3RWYWxpZEJsb2NrSGVpZ2h0IiwidHJhbnNmZXJCbG9ja0hlaWdodCIsInNpZ25lZFRyYW5zZmVyVHgiLCJjb25maXJtVHJhbnNhY3Rpb24iLCJwYXllclNvbGFuYUJ5dGVzMzIiLCJ0b0J5dGVzIiwiY29udHJhY3RCbG9ja2hhc2giLCJjb250cmFjdEJsb2NrSGVpZ2h0Iiwic2lnbmVkVHgiLCJkZWFjdGl2YXRlTGluayIsImRlYWN0aXZhdGVCbG9ja0hlaWdodCIsImNyZWF0ZVBheW1lbnRVUkwiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIm9yaWdpbiIsImV4dHJhY3RMaW5rSWRGcm9tVVJMIiwidXJsIiwidXJsT2JqIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwiZ2V0IiwiZ2V0VXNlckVWTUFkZHJlc3MiLCJjb25zdHJ1Y3RvciIsInNvbGFuYU5hdGl2ZUNvbnRyYWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/solana-native-contract.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/utils/fixednumber.js":
/*!**********************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/fixednumber.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedNumber: function() { return /* binding */ FixedNumber; }\n/* harmony export */ });\n/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/* harmony import */ var _properties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./properties.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/properties.js\");\n/**\n *  The **FixedNumber** class permits using values with decimal places,\n *  using fixed-pont math.\n *\n *  Fixed-point math is still based on integers under-the-hood, but uses an\n *  internal offset to store fractional components below, and each operation\n *  corrects for this after each operation.\n *\n *  @_section: api/utils/fixed-point-math:Fixed-Point Maths  [about-fixed-point-math]\n */\n\n\n\n\nconst BN_N1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_5 = BigInt(5);\nconst _guard = {};\n// Constant to pull zeros from for multipliers\nlet Zeros = \"0000\";\nwhile (Zeros.length < 80) {\n    Zeros += Zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getTens(decimals) {\n    let result = Zeros;\n    while (result.length < decimals) {\n        result += result;\n    }\n    return BigInt(\"1\" + result.substring(0, decimals));\n}\nfunction checkValue(val, format, safeOp) {\n    const width = BigInt(format.width);\n    if (format.signed) {\n        const limit = (BN_1 << (width - BN_1));\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(safeOp == null || (val >= -limit && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp, fault: \"overflow\", value: val\n        });\n        if (val > BN_0) {\n            val = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)((0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.mask)(val, width), width);\n        }\n        else {\n            val = -(0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)((0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.mask)(-val, width), width);\n        }\n    }\n    else {\n        const limit = (BN_1 << width);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(safeOp == null || (val >= 0 && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp, fault: \"overflow\", value: val\n        });\n        val = (((val % limit) + limit) % limit) & (limit - BN_1);\n    }\n    return val;\n}\nfunction getFormat(value) {\n    if (typeof (value) === \"number\") {\n        value = `fixed128x${value}`;\n    }\n    let signed = true;\n    let width = 128;\n    let decimals = 18;\n    if (typeof (value) === \"string\") {\n        // Parse the format string\n        if (value === \"fixed\") {\n            // defaults...\n        }\n        else if (value === \"ufixed\") {\n            signed = false;\n        }\n        else {\n            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(match, \"invalid fixed format\", \"format\", value);\n            signed = (match[1] !== \"u\");\n            width = parseInt(match[2]);\n            decimals = parseInt(match[3]);\n        }\n    }\n    else if (value) {\n        // Extract the values from the object\n        const v = value;\n        const check = (key, type, defaultValue) => {\n            if (v[key] == null) {\n                return defaultValue;\n            }\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (v[key]) === type, \"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, v[key]);\n            return v[key];\n        };\n        signed = check(\"signed\", \"boolean\", signed);\n        width = check(\"width\", \"number\", width);\n        decimals = check(\"decimals\", \"number\", decimals);\n    }\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)((width % 8) === 0, \"invalid FixedNumber width (not byte aligned)\", \"format.width\", width);\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(decimals <= 80, \"invalid FixedNumber decimals (too large)\", \"format.decimals\", decimals);\n    const name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n    return { signed, width, decimals, name };\n}\nfunction toString(val, decimals) {\n    let negative = \"\";\n    if (val < BN_0) {\n        negative = \"-\";\n        val *= BN_N1;\n    }\n    let str = val.toString();\n    // No decimal point for whole values\n    if (decimals === 0) {\n        return (negative + str);\n    }\n    // Pad out to the whole component (including a whole digit)\n    while (str.length <= decimals) {\n        str = Zeros + str;\n    }\n    // Insert the decimal point\n    const index = str.length - decimals;\n    str = str.substring(0, index) + \".\" + str.substring(index);\n    // Trim the whole component (leaving at least one 0)\n    while (str[0] === \"0\" && str[1] !== \".\") {\n        str = str.substring(1);\n    }\n    // Trim the decimal component (leaving at least one 0)\n    while (str[str.length - 1] === \"0\" && str[str.length - 2] !== \".\") {\n        str = str.substring(0, str.length - 1);\n    }\n    return (negative + str);\n}\n/**\n *  A FixedNumber represents a value over its [[FixedFormat]]\n *  arithmetic field.\n *\n *  A FixedNumber can be used to perform math, losslessly, on\n *  values which have decmial places.\n *\n *  A FixedNumber has a fixed bit-width to store values in, and stores all\n *  values internally by multiplying the value by 10 raised to the power of\n *  %%decimals%%.\n *\n *  If operations are performed that cause a value to grow too high (close to\n *  positive infinity) or too low (close to negative infinity), the value\n *  is said to //overflow//.\n *\n *  For example, an 8-bit signed value, with 0 decimals may only be within\n *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become\n *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.\n *\n *  Many operation have a normal and //unsafe// variant. The normal variant\n *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//\n *  variant will silently allow overflow, corrupting its value value.\n *\n *  If operations are performed that cause a value to become too small\n *  (close to zero), the value loses precison and is said to //underflow//.\n *\n *  For example, a value with 1 decimal place may store a number as small\n *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit\n *  into 1 decimal place, so underflow occurs which means precision is lost\n *  and the value becomes ``0``.\n *\n *  Some operations have a normal and //signalling// variant. The normal\n *  variant will silently ignore underflow, while the //signalling// variant\n *  will thow a [[NumericFaultError]] on underflow.\n */\nclass FixedNumber {\n    /**\n     *  The specific fixed-point arithmetic field for this value.\n     */\n    format;\n    #format;\n    // The actual value (accounting for decimals)\n    #val;\n    // A base-10 value to multiple values by to maintain the magnitude\n    #tens;\n    /**\n     *  This is a property so console.log shows a human-meaningful value.\n     *\n     *  @private\n     */\n    _value;\n    // Use this when changing this file to get some typing info,\n    // but then switch to any to mask the internal type\n    //constructor(guard: any, value: bigint, format: _FixedFormat) {\n    /**\n     *  @private\n     */\n    constructor(guard, value, format) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertPrivate)(guard, _guard, \"FixedNumber\");\n        this.#val = value;\n        this.#format = format;\n        const _value = toString(value, format.decimals);\n        (0,_properties_js__WEBPACK_IMPORTED_MODULE_2__.defineProperties)(this, { format: format.name, _value });\n        this.#tens = getTens(format.decimals);\n    }\n    /**\n     *  If true, negative values are permitted, otherwise only\n     *  positive values and zero are allowed.\n     */\n    get signed() { return this.#format.signed; }\n    /**\n     *  The number of bits available to store the value.\n     */\n    get width() { return this.#format.width; }\n    /**\n     *  The number of decimal places in the fixed-point arithment field.\n     */\n    get decimals() { return this.#format.decimals; }\n    /**\n     *  The value as an integer, based on the smallest unit the\n     *  [[decimals]] allow.\n     */\n    get value() { return this.#val; }\n    #checkFormat(other) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(this.format === other.format, \"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n    }\n    #checkValue(val, safeOp) {\n        /*\n                const width = BigInt(this.width);\n                if (this.signed) {\n                    const limit = (BN_1 << (width - BN_1));\n                    assert(safeOp == null || (val >= -limit  && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n        \n                    if (val > BN_0) {\n                        val = fromTwos(mask(val, width), width);\n                    } else {\n                        val = -fromTwos(mask(-val, width), width);\n                    }\n        \n                } else {\n                    const masked = mask(val, width);\n                    assert(safeOp == null || (val >= 0 && val === masked), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n                    val = masked;\n                }\n        */\n        val = checkValue(val, this.#format, safeOp);\n        return new FixedNumber(_guard, val, this.#format);\n    }\n    #add(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val + o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%, ignoring overflow.\n     */\n    addUnsafe(other) { return this.#add(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    add(other) { return this.#add(other, \"add\"); }\n    #sub(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val - o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%, ignoring overflow.\n     */\n    subUnsafe(other) { return this.#sub(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    sub(other) { return this.#sub(other, \"sub\"); }\n    #mul(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue((this.#val * o.#val) / this.#tens, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%, ignoring overflow and underflow (precision loss).\n     */\n    mulUnsafe(other) { return this.#mul(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    mul(other) { return this.#mul(other, \"mul\"); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs or if underflow (precision loss) occurs.\n     */\n    mulSignal(other) {\n        this.#checkFormat(other);\n        const value = this.#val * other.#val;\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)((value % this.#tens) === BN_0, \"precision lost during signalling mul\", \"NUMERIC_FAULT\", {\n            operation: \"mulSignal\", fault: \"underflow\", value: this\n        });\n        return this.#checkValue(value / this.#tens, \"mulSignal\");\n    }\n    #div(o, safeOp) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(o.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\", fault: \"divide-by-zero\", value: this\n        });\n        this.#checkFormat(o);\n        return this.#checkValue((this.#val * this.#tens) / o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n    divUnsafe(other) { return this.#div(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n    div(other) { return this.#div(other, \"div\"); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%. A [[NumericFaultError]] is thrown if underflow\n     *  (precision loss) occurs.\n     */\n    divSignal(other) {\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(other.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\", fault: \"divide-by-zero\", value: this\n        });\n        this.#checkFormat(other);\n        const value = (this.#val * this.#tens);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)((value % other.#val) === BN_0, \"precision lost during signalling div\", \"NUMERIC_FAULT\", {\n            operation: \"divSignal\", fault: \"underflow\", value: this\n        });\n        return this.#checkValue(value / other.#val, \"divSignal\");\n    }\n    /**\n     *  Returns a comparison result between %%this%% and %%other%%.\n     *\n     *  This is suitable for use in sorting, where ``-1`` implies %%this%%\n     *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies\n     *  both are equal.\n     */\n    cmp(other) {\n        let a = this.value, b = other.value;\n        // Coerce a and b to the same magnitude\n        const delta = this.decimals - other.decimals;\n        if (delta > 0) {\n            b *= getTens(delta);\n        }\n        else if (delta < 0) {\n            a *= getTens(-delta);\n        }\n        // Comnpare\n        if (a < b) {\n            return -1;\n        }\n        if (a > b) {\n            return 1;\n        }\n        return 0;\n    }\n    /**\n     *  Returns true if %%other%% is equal to %%this%%.\n     */\n    eq(other) { return this.cmp(other) === 0; }\n    /**\n     *  Returns true if %%other%% is less than to %%this%%.\n     */\n    lt(other) { return this.cmp(other) < 0; }\n    /**\n     *  Returns true if %%other%% is less than or equal to %%this%%.\n     */\n    lte(other) { return this.cmp(other) <= 0; }\n    /**\n     *  Returns true if %%other%% is greater than to %%this%%.\n     */\n    gt(other) { return this.cmp(other) > 0; }\n    /**\n     *  Returns true if %%other%% is greater than or equal to %%this%%.\n     */\n    gte(other) { return this.cmp(other) >= 0; }\n    /**\n     *  Returns a new [[FixedNumber]] which is the largest **integer**\n     *  that is less than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n    floor() {\n        let val = this.#val;\n        if (this.#val < BN_0) {\n            val -= this.#tens - BN_1;\n        }\n        val = (this.#val / this.#tens) * this.#tens;\n        return this.#checkValue(val, \"floor\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] which is the smallest **integer**\n     *  that is greater than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n    ceiling() {\n        let val = this.#val;\n        if (this.#val > BN_0) {\n            val += this.#tens - BN_1;\n        }\n        val = (this.#val / this.#tens) * this.#tens;\n        return this.#checkValue(val, \"ceiling\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the decimal component\n     *  rounded up on ties at %%decimals%% places.\n     */\n    round(decimals) {\n        if (decimals == null) {\n            decimals = 0;\n        }\n        // Not enough precision to not already be rounded\n        if (decimals >= this.decimals) {\n            return this;\n        }\n        const delta = this.decimals - decimals;\n        const bump = BN_5 * getTens(delta - 1);\n        let value = this.value + bump;\n        const tens = getTens(delta);\n        value = (value / tens) * tens;\n        checkValue(value, this.#format, \"round\");\n        return new FixedNumber(_guard, value, this.#format);\n    }\n    /**\n     *  Returns true if %%this%% is equal to ``0``.\n     */\n    isZero() { return (this.#val === BN_0); }\n    /**\n     *  Returns true if %%this%% is less than ``0``.\n     */\n    isNegative() { return (this.#val < BN_0); }\n    /**\n     *  Returns the string representation of %%this%%.\n     */\n    toString() { return this._value; }\n    /**\n     *  Returns a float approximation.\n     *\n     *  Due to IEEE 754 precission (or lack thereof), this function\n     *  can only return an approximation and most values will contain\n     *  rounding errors.\n     */\n    toUnsafeFloat() { return parseFloat(this.toString()); }\n    /**\n     *  Return a new [[FixedNumber]] with the same value but has had\n     *  its field set to %%format%%.\n     *\n     *  This will throw if the value cannot fit into %%format%%.\n     */\n    toFormat(format) {\n        return FixedNumber.fromString(this.toString(), format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% divided by\n     *  %%decimal%% places with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted\n     *  for %%decimals%%) cannot fit in %%format%%, either due to overflow\n     *  or underflow (precision loss).\n     */\n    static fromValue(_value, _decimals, _format) {\n        const decimals = (_decimals == null) ? 0 : (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(_decimals);\n        const format = getFormat(_format);\n        let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getBigInt)(_value, \"value\");\n        const delta = decimals - format.decimals;\n        if (delta > 0) {\n            const tens = getTens(delta);\n            (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)((value % tens) === BN_0, \"value loses precision for format\", \"NUMERIC_FAULT\", {\n                operation: \"fromValue\", fault: \"underflow\", value: _value\n            });\n            value /= tens;\n        }\n        else if (delta < 0) {\n            value *= getTens(-delta);\n        }\n        checkValue(value, format, \"fromValue\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%%, either due to overflow or underflow (precision loss).\n     */\n    static fromString(_value, _format) {\n        const match = _value.match(/^(-?)([0-9]*)\\.?([0-9]*)$/);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(match && (match[2].length + match[3].length) > 0, \"invalid FixedNumber string value\", \"value\", _value);\n        const format = getFormat(_format);\n        let whole = (match[2] || \"0\"), decimal = (match[3] || \"\");\n        // Pad out the decimals\n        while (decimal.length < format.decimals) {\n            decimal += Zeros;\n        }\n        // Check precision is safe\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assert)(decimal.substring(format.decimals).match(/^0*$/), \"too many decimals for format\", \"NUMERIC_FAULT\", {\n            operation: \"fromString\", fault: \"underflow\", value: _value\n        });\n        // Remove extra padding\n        decimal = decimal.substring(0, format.decimals);\n        const value = BigInt(match[1] + whole + decimal);\n        checkValue(value, format, \"fromString\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] with the big-endian representation\n     *  %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%% due to overflow.\n     */\n    static fromBytes(_value, _format) {\n        let value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt)((0,_data_js__WEBPACK_IMPORTED_MODULE_3__.getBytes)(_value, \"value\"));\n        const format = getFormat(_format);\n        if (format.signed) {\n            value = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.fromTwos)(value, format.width);\n        }\n        checkValue(value, format, \"fromBytes\");\n        return new FixedNumber(_guard, value, format);\n    }\n}\n//const f1 = FixedNumber.fromString(\"12.56\", \"fixed16x2\");\n//const f2 = FixedNumber.fromString(\"0.3\", \"fixed16x2\");\n//console.log(f1.divSignal(f2));\n//const BUMP = FixedNumber.from(\"0.5\");\n//# sourceMappingURL=fixednumber.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy9maXhlZG51bWJlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3FDO0FBQytCO0FBQ1E7QUFDekI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsbURBQVEsQ0FBQywrQ0FBSTtBQUMvQjtBQUNBO0FBQ0EsbUJBQW1CLG1EQUFRLENBQUMsK0NBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwREFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDBEQUFjO0FBQ2xCLElBQUksMERBQWM7QUFDbEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxvREFBUztBQUM1RDtBQUNBLG9CQUFvQixvREFBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtEQUFNO0FBQ2xCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1EQUFRLENBQUMsa0RBQVE7QUFDckM7QUFDQTtBQUNBLG9CQUFvQixtREFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXRoZXJzL2xpYi5lc20vdXRpbHMvZml4ZWRudW1iZXIuanM/YWZkMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBUaGUgKipGaXhlZE51bWJlcioqIGNsYXNzIHBlcm1pdHMgdXNpbmcgdmFsdWVzIHdpdGggZGVjaW1hbCBwbGFjZXMsXG4gKiAgdXNpbmcgZml4ZWQtcG9udCBtYXRoLlxuICpcbiAqICBGaXhlZC1wb2ludCBtYXRoIGlzIHN0aWxsIGJhc2VkIG9uIGludGVnZXJzIHVuZGVyLXRoZS1ob29kLCBidXQgdXNlcyBhblxuICogIGludGVybmFsIG9mZnNldCB0byBzdG9yZSBmcmFjdGlvbmFsIGNvbXBvbmVudHMgYmVsb3csIGFuZCBlYWNoIG9wZXJhdGlvblxuICogIGNvcnJlY3RzIGZvciB0aGlzIGFmdGVyIGVhY2ggb3BlcmF0aW9uLlxuICpcbiAqICBAX3NlY3Rpb246IGFwaS91dGlscy9maXhlZC1wb2ludC1tYXRoOkZpeGVkLVBvaW50IE1hdGhzICBbYWJvdXQtZml4ZWQtcG9pbnQtbWF0aF1cbiAqL1xuaW1wb3J0IHsgZ2V0Qnl0ZXMgfSBmcm9tIFwiLi9kYXRhLmpzXCI7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2VydEFyZ3VtZW50LCBhc3NlcnRQcml2YXRlIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBnZXRCaWdJbnQsIGdldE51bWJlciwgZnJvbVR3b3MsIG1hc2ssIHRvQmlnSW50IH0gZnJvbSBcIi4vbWF0aHMuanNcIjtcbmltcG9ydCB7IGRlZmluZVByb3BlcnRpZXMgfSBmcm9tIFwiLi9wcm9wZXJ0aWVzLmpzXCI7XG5jb25zdCBCTl9OMSA9IEJpZ0ludCgtMSk7XG5jb25zdCBCTl8wID0gQmlnSW50KDApO1xuY29uc3QgQk5fMSA9IEJpZ0ludCgxKTtcbmNvbnN0IEJOXzUgPSBCaWdJbnQoNSk7XG5jb25zdCBfZ3VhcmQgPSB7fTtcbi8vIENvbnN0YW50IHRvIHB1bGwgemVyb3MgZnJvbSBmb3IgbXVsdGlwbGllcnNcbmxldCBaZXJvcyA9IFwiMDAwMFwiO1xud2hpbGUgKFplcm9zLmxlbmd0aCA8IDgwKSB7XG4gICAgWmVyb3MgKz0gWmVyb3M7XG59XG4vLyBSZXR1cm5zIGEgc3RyaW5nIFwiMVwiIGZvbGxvd2VkIGJ5IGRlY2ltYWwgXCIwXCJzXG5mdW5jdGlvbiBnZXRUZW5zKGRlY2ltYWxzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFplcm9zO1xuICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgZGVjaW1hbHMpIHtcbiAgICAgICAgcmVzdWx0ICs9IHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludChcIjFcIiArIHJlc3VsdC5zdWJzdHJpbmcoMCwgZGVjaW1hbHMpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrVmFsdWUodmFsLCBmb3JtYXQsIHNhZmVPcCkge1xuICAgIGNvbnN0IHdpZHRoID0gQmlnSW50KGZvcm1hdC53aWR0aCk7XG4gICAgaWYgKGZvcm1hdC5zaWduZWQpIHtcbiAgICAgICAgY29uc3QgbGltaXQgPSAoQk5fMSA8PCAod2lkdGggLSBCTl8xKSk7XG4gICAgICAgIGFzc2VydChzYWZlT3AgPT0gbnVsbCB8fCAodmFsID49IC1saW1pdCAmJiB2YWwgPCBsaW1pdCksIFwib3ZlcmZsb3dcIiwgXCJOVU1FUklDX0ZBVUxUXCIsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogc2FmZU9wLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogdmFsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodmFsID4gQk5fMCkge1xuICAgICAgICAgICAgdmFsID0gZnJvbVR3b3MobWFzayh2YWwsIHdpZHRoKSwgd2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsID0gLWZyb21Ud29zKG1hc2soLXZhbCwgd2lkdGgpLCB3aWR0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gKEJOXzEgPDwgd2lkdGgpO1xuICAgICAgICBhc3NlcnQoc2FmZU9wID09IG51bGwgfHwgKHZhbCA+PSAwICYmIHZhbCA8IGxpbWl0KSwgXCJvdmVyZmxvd1wiLCBcIk5VTUVSSUNfRkFVTFRcIiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBzYWZlT3AsIGZhdWx0OiBcIm92ZXJmbG93XCIsIHZhbHVlOiB2YWxcbiAgICAgICAgfSk7XG4gICAgICAgIHZhbCA9ICgoKHZhbCAlIGxpbWl0KSArIGxpbWl0KSAlIGxpbWl0KSAmIChsaW1pdCAtIEJOXzEpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gZ2V0Rm9ybWF0KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHZhbHVlID0gYGZpeGVkMTI4eCR7dmFsdWV9YDtcbiAgICB9XG4gICAgbGV0IHNpZ25lZCA9IHRydWU7XG4gICAgbGV0IHdpZHRoID0gMTI4O1xuICAgIGxldCBkZWNpbWFscyA9IDE4O1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAvLyBQYXJzZSB0aGUgZm9ybWF0IHN0cmluZ1xuICAgICAgICBpZiAodmFsdWUgPT09IFwiZml4ZWRcIikge1xuICAgICAgICAgICAgLy8gZGVmYXVsdHMuLi5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gXCJ1Zml4ZWRcIikge1xuICAgICAgICAgICAgc2lnbmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHZhbHVlLm1hdGNoKC9eKHU/KWZpeGVkKFswLTldKyl4KFswLTldKykkLyk7XG4gICAgICAgICAgICBhc3NlcnRBcmd1bWVudChtYXRjaCwgXCJpbnZhbGlkIGZpeGVkIGZvcm1hdFwiLCBcImZvcm1hdFwiLCB2YWx1ZSk7XG4gICAgICAgICAgICBzaWduZWQgPSAobWF0Y2hbMV0gIT09IFwidVwiKTtcbiAgICAgICAgICAgIHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgICAgICAgZGVjaW1hbHMgPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgdmFsdWVzIGZyb20gdGhlIG9iamVjdFxuICAgICAgICBjb25zdCB2ID0gdmFsdWU7XG4gICAgICAgIGNvbnN0IGNoZWNrID0gKGtleSwgdHlwZSwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0QXJndW1lbnQodHlwZW9mICh2W2tleV0pID09PSB0eXBlLCBcImludmFsaWQgZml4ZWQgZm9ybWF0IChcIiArIGtleSArIFwiIG5vdCBcIiArIHR5cGUgKyBcIilcIiwgXCJmb3JtYXQuXCIgKyBrZXksIHZba2V5XSk7XG4gICAgICAgICAgICByZXR1cm4gdltrZXldO1xuICAgICAgICB9O1xuICAgICAgICBzaWduZWQgPSBjaGVjayhcInNpZ25lZFwiLCBcImJvb2xlYW5cIiwgc2lnbmVkKTtcbiAgICAgICAgd2lkdGggPSBjaGVjayhcIndpZHRoXCIsIFwibnVtYmVyXCIsIHdpZHRoKTtcbiAgICAgICAgZGVjaW1hbHMgPSBjaGVjayhcImRlY2ltYWxzXCIsIFwibnVtYmVyXCIsIGRlY2ltYWxzKTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoKHdpZHRoICUgOCkgPT09IDAsIFwiaW52YWxpZCBGaXhlZE51bWJlciB3aWR0aCAobm90IGJ5dGUgYWxpZ25lZClcIiwgXCJmb3JtYXQud2lkdGhcIiwgd2lkdGgpO1xuICAgIGFzc2VydEFyZ3VtZW50KGRlY2ltYWxzIDw9IDgwLCBcImludmFsaWQgRml4ZWROdW1iZXIgZGVjaW1hbHMgKHRvbyBsYXJnZSlcIiwgXCJmb3JtYXQuZGVjaW1hbHNcIiwgZGVjaW1hbHMpO1xuICAgIGNvbnN0IG5hbWUgPSAoc2lnbmVkID8gXCJcIiA6IFwidVwiKSArIFwiZml4ZWRcIiArIFN0cmluZyh3aWR0aCkgKyBcInhcIiArIFN0cmluZyhkZWNpbWFscyk7XG4gICAgcmV0dXJuIHsgc2lnbmVkLCB3aWR0aCwgZGVjaW1hbHMsIG5hbWUgfTtcbn1cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbCwgZGVjaW1hbHMpIHtcbiAgICBsZXQgbmVnYXRpdmUgPSBcIlwiO1xuICAgIGlmICh2YWwgPCBCTl8wKSB7XG4gICAgICAgIG5lZ2F0aXZlID0gXCItXCI7XG4gICAgICAgIHZhbCAqPSBCTl9OMTtcbiAgICB9XG4gICAgbGV0IHN0ciA9IHZhbC50b1N0cmluZygpO1xuICAgIC8vIE5vIGRlY2ltYWwgcG9pbnQgZm9yIHdob2xlIHZhbHVlc1xuICAgIGlmIChkZWNpbWFscyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gKG5lZ2F0aXZlICsgc3RyKTtcbiAgICB9XG4gICAgLy8gUGFkIG91dCB0byB0aGUgd2hvbGUgY29tcG9uZW50IChpbmNsdWRpbmcgYSB3aG9sZSBkaWdpdClcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8PSBkZWNpbWFscykge1xuICAgICAgICBzdHIgPSBaZXJvcyArIHN0cjtcbiAgICB9XG4gICAgLy8gSW5zZXJ0IHRoZSBkZWNpbWFsIHBvaW50XG4gICAgY29uc3QgaW5kZXggPSBzdHIubGVuZ3RoIC0gZGVjaW1hbHM7XG4gICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpbmRleCkgKyBcIi5cIiArIHN0ci5zdWJzdHJpbmcoaW5kZXgpO1xuICAgIC8vIFRyaW0gdGhlIHdob2xlIGNvbXBvbmVudCAobGVhdmluZyBhdCBsZWFzdCBvbmUgMClcbiAgICB3aGlsZSAoc3RyWzBdID09PSBcIjBcIiAmJiBzdHJbMV0gIT09IFwiLlwiKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIC8vIFRyaW0gdGhlIGRlY2ltYWwgY29tcG9uZW50IChsZWF2aW5nIGF0IGxlYXN0IG9uZSAwKVxuICAgIHdoaWxlIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSBcIjBcIiAmJiBzdHJbc3RyLmxlbmd0aCAtIDJdICE9PSBcIi5cIikge1xuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIChuZWdhdGl2ZSArIHN0cik7XG59XG4vKipcbiAqICBBIEZpeGVkTnVtYmVyIHJlcHJlc2VudHMgYSB2YWx1ZSBvdmVyIGl0cyBbW0ZpeGVkRm9ybWF0XV1cbiAqICBhcml0aG1ldGljIGZpZWxkLlxuICpcbiAqICBBIEZpeGVkTnVtYmVyIGNhbiBiZSB1c2VkIHRvIHBlcmZvcm0gbWF0aCwgbG9zc2xlc3NseSwgb25cbiAqICB2YWx1ZXMgd2hpY2ggaGF2ZSBkZWNtaWFsIHBsYWNlcy5cbiAqXG4gKiAgQSBGaXhlZE51bWJlciBoYXMgYSBmaXhlZCBiaXQtd2lkdGggdG8gc3RvcmUgdmFsdWVzIGluLCBhbmQgc3RvcmVzIGFsbFxuICogIHZhbHVlcyBpbnRlcm5hbGx5IGJ5IG11bHRpcGx5aW5nIHRoZSB2YWx1ZSBieSAxMCByYWlzZWQgdG8gdGhlIHBvd2VyIG9mXG4gKiAgJSVkZWNpbWFscyUlLlxuICpcbiAqICBJZiBvcGVyYXRpb25zIGFyZSBwZXJmb3JtZWQgdGhhdCBjYXVzZSBhIHZhbHVlIHRvIGdyb3cgdG9vIGhpZ2ggKGNsb3NlIHRvXG4gKiAgcG9zaXRpdmUgaW5maW5pdHkpIG9yIHRvbyBsb3cgKGNsb3NlIHRvIG5lZ2F0aXZlIGluZmluaXR5KSwgdGhlIHZhbHVlXG4gKiAgaXMgc2FpZCB0byAvL292ZXJmbG93Ly8uXG4gKlxuICogIEZvciBleGFtcGxlLCBhbiA4LWJpdCBzaWduZWQgdmFsdWUsIHdpdGggMCBkZWNpbWFscyBtYXkgb25seSBiZSB3aXRoaW5cbiAqICB0aGUgcmFuZ2UgYGAtMTI4YGAgdG8gYGAxMjdgYDsgc28gYGAtMTI4IC0gMWBgIHdpbGwgb3ZlcmZsb3cgYW5kIGJlY29tZVxuICogIGBgMTI3YGAuIExpa2V3aXNlLCBgYDEyNyArIDFgYCB3aWxsIG92ZXJmbG93IGFuZCBiZWNvbWUgYGAtMTI3YGAuXG4gKlxuICogIE1hbnkgb3BlcmF0aW9uIGhhdmUgYSBub3JtYWwgYW5kIC8vdW5zYWZlLy8gdmFyaWFudC4gVGhlIG5vcm1hbCB2YXJpYW50XG4gKiAgd2lsbCB0aHJvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBvbiBhbnkgb3ZlcmZsb3csIHdoaWxlIHRoZSAvL3Vuc2FmZS8vXG4gKiAgdmFyaWFudCB3aWxsIHNpbGVudGx5IGFsbG93IG92ZXJmbG93LCBjb3JydXB0aW5nIGl0cyB2YWx1ZSB2YWx1ZS5cbiAqXG4gKiAgSWYgb3BlcmF0aW9ucyBhcmUgcGVyZm9ybWVkIHRoYXQgY2F1c2UgYSB2YWx1ZSB0byBiZWNvbWUgdG9vIHNtYWxsXG4gKiAgKGNsb3NlIHRvIHplcm8pLCB0aGUgdmFsdWUgbG9zZXMgcHJlY2lzb24gYW5kIGlzIHNhaWQgdG8gLy91bmRlcmZsb3cvLy5cbiAqXG4gKiAgRm9yIGV4YW1wbGUsIGEgdmFsdWUgd2l0aCAxIGRlY2ltYWwgcGxhY2UgbWF5IHN0b3JlIGEgbnVtYmVyIGFzIHNtYWxsXG4gKiAgYXMgYGAwLjFgYCwgYnV0IHRoZSB2YWx1ZSBvZiBgYDAuMSAvIDJgYCBpcyBgYDAuMDVgYCwgd2hpY2ggY2Fubm90IGZpdFxuICogIGludG8gMSBkZWNpbWFsIHBsYWNlLCBzbyB1bmRlcmZsb3cgb2NjdXJzIHdoaWNoIG1lYW5zIHByZWNpc2lvbiBpcyBsb3N0XG4gKiAgYW5kIHRoZSB2YWx1ZSBiZWNvbWVzIGBgMGBgLlxuICpcbiAqICBTb21lIG9wZXJhdGlvbnMgaGF2ZSBhIG5vcm1hbCBhbmQgLy9zaWduYWxsaW5nLy8gdmFyaWFudC4gVGhlIG5vcm1hbFxuICogIHZhcmlhbnQgd2lsbCBzaWxlbnRseSBpZ25vcmUgdW5kZXJmbG93LCB3aGlsZSB0aGUgLy9zaWduYWxsaW5nLy8gdmFyaWFudFxuICogIHdpbGwgdGhvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBvbiB1bmRlcmZsb3cuXG4gKi9cbmV4cG9ydCBjbGFzcyBGaXhlZE51bWJlciB7XG4gICAgLyoqXG4gICAgICogIFRoZSBzcGVjaWZpYyBmaXhlZC1wb2ludCBhcml0aG1ldGljIGZpZWxkIGZvciB0aGlzIHZhbHVlLlxuICAgICAqL1xuICAgIGZvcm1hdDtcbiAgICAjZm9ybWF0O1xuICAgIC8vIFRoZSBhY3R1YWwgdmFsdWUgKGFjY291bnRpbmcgZm9yIGRlY2ltYWxzKVxuICAgICN2YWw7XG4gICAgLy8gQSBiYXNlLTEwIHZhbHVlIHRvIG11bHRpcGxlIHZhbHVlcyBieSB0byBtYWludGFpbiB0aGUgbWFnbml0dWRlXG4gICAgI3RlbnM7XG4gICAgLyoqXG4gICAgICogIFRoaXMgaXMgYSBwcm9wZXJ0eSBzbyBjb25zb2xlLmxvZyBzaG93cyBhIGh1bWFuLW1lYW5pbmdmdWwgdmFsdWUuXG4gICAgICpcbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdmFsdWU7XG4gICAgLy8gVXNlIHRoaXMgd2hlbiBjaGFuZ2luZyB0aGlzIGZpbGUgdG8gZ2V0IHNvbWUgdHlwaW5nIGluZm8sXG4gICAgLy8gYnV0IHRoZW4gc3dpdGNoIHRvIGFueSB0byBtYXNrIHRoZSBpbnRlcm5hbCB0eXBlXG4gICAgLy9jb25zdHJ1Y3RvcihndWFyZDogYW55LCB2YWx1ZTogYmlnaW50LCBmb3JtYXQ6IF9GaXhlZEZvcm1hdCkge1xuICAgIC8qKlxuICAgICAqICBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGd1YXJkLCB2YWx1ZSwgZm9ybWF0KSB7XG4gICAgICAgIGFzc2VydFByaXZhdGUoZ3VhcmQsIF9ndWFyZCwgXCJGaXhlZE51bWJlclwiKTtcbiAgICAgICAgdGhpcy4jdmFsID0gdmFsdWU7XG4gICAgICAgIHRoaXMuI2Zvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgY29uc3QgX3ZhbHVlID0gdG9TdHJpbmcodmFsdWUsIGZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIGRlZmluZVByb3BlcnRpZXModGhpcywgeyBmb3JtYXQ6IGZvcm1hdC5uYW1lLCBfdmFsdWUgfSk7XG4gICAgICAgIHRoaXMuI3RlbnMgPSBnZXRUZW5zKGZvcm1hdC5kZWNpbWFscyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBJZiB0cnVlLCBuZWdhdGl2ZSB2YWx1ZXMgYXJlIHBlcm1pdHRlZCwgb3RoZXJ3aXNlIG9ubHlcbiAgICAgKiAgcG9zaXRpdmUgdmFsdWVzIGFuZCB6ZXJvIGFyZSBhbGxvd2VkLlxuICAgICAqL1xuICAgIGdldCBzaWduZWQoKSB7IHJldHVybiB0aGlzLiNmb3JtYXQuc2lnbmVkOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSBudW1iZXIgb2YgYml0cyBhdmFpbGFibGUgdG8gc3RvcmUgdGhlIHZhbHVlLlxuICAgICAqL1xuICAgIGdldCB3aWR0aCgpIHsgcmV0dXJuIHRoaXMuI2Zvcm1hdC53aWR0aDsgfVxuICAgIC8qKlxuICAgICAqICBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGluIHRoZSBmaXhlZC1wb2ludCBhcml0aG1lbnQgZmllbGQuXG4gICAgICovXG4gICAgZ2V0IGRlY2ltYWxzKCkgeyByZXR1cm4gdGhpcy4jZm9ybWF0LmRlY2ltYWxzOyB9XG4gICAgLyoqXG4gICAgICogIFRoZSB2YWx1ZSBhcyBhbiBpbnRlZ2VyLCBiYXNlZCBvbiB0aGUgc21hbGxlc3QgdW5pdCB0aGVcbiAgICAgKiAgW1tkZWNpbWFsc11dIGFsbG93LlxuICAgICAqL1xuICAgIGdldCB2YWx1ZSgpIHsgcmV0dXJuIHRoaXMuI3ZhbDsgfVxuICAgICNjaGVja0Zvcm1hdChvdGhlcikge1xuICAgICAgICBhc3NlcnRBcmd1bWVudCh0aGlzLmZvcm1hdCA9PT0gb3RoZXIuZm9ybWF0LCBcImluY29tcGF0aWJsZSBmb3JtYXQ7IHVzZSBmaXhlZE51bWJlci50b0Zvcm1hdFwiLCBcIm90aGVyXCIsIG90aGVyKTtcbiAgICB9XG4gICAgI2NoZWNrVmFsdWUodmFsLCBzYWZlT3ApIHtcbiAgICAgICAgLypcbiAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IEJpZ0ludCh0aGlzLndpZHRoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGltaXQgPSAoQk5fMSA8PCAod2lkdGggLSBCTl8xKSk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChzYWZlT3AgPT0gbnVsbCB8fCAodmFsID49IC1saW1pdCAgJiYgdmFsIDwgbGltaXQpLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IDxzdHJpbmc+c2FmZU9wLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogdmFsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA+IEJOXzApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGZyb21Ud29zKG1hc2sodmFsLCB3aWR0aCksIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IC1mcm9tVHdvcyhtYXNrKC12YWwsIHdpZHRoKSwgd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hc2tlZCA9IG1hc2sodmFsLCB3aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChzYWZlT3AgPT0gbnVsbCB8fCAodmFsID49IDAgJiYgdmFsID09PSBtYXNrZWQpLCBcIm92ZXJmbG93XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IDxzdHJpbmc+c2FmZU9wLCBmYXVsdDogXCJvdmVyZmxvd1wiLCB2YWx1ZTogdmFsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBtYXNrZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgICB2YWwgPSBjaGVja1ZhbHVlKHZhbCwgdGhpcy4jZm9ybWF0LCBzYWZlT3ApO1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9ndWFyZCwgdmFsLCB0aGlzLiNmb3JtYXQpO1xuICAgIH1cbiAgICAjYWRkKG8sIHNhZmVPcCkge1xuICAgICAgICB0aGlzLiNjaGVja0Zvcm1hdChvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodGhpcy4jdmFsICsgby4jdmFsLCBzYWZlT3ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIGFkZGVkXG4gICAgICogIHRvICUlb3RoZXIlJSwgaWdub3Jpbmcgb3ZlcmZsb3cuXG4gICAgICovXG4gICAgYWRkVW5zYWZlKG90aGVyKSB7IHJldHVybiB0aGlzLiNhZGQob3RoZXIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBhZGRlZFxuICAgICAqICB0byAlJW90aGVyJSUuIEEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvd1xuICAgICAqICBvY2N1cnMuXG4gICAgICovXG4gICAgYWRkKG90aGVyKSB7IHJldHVybiB0aGlzLiNhZGQob3RoZXIsIFwiYWRkXCIpOyB9XG4gICAgI3N1YihvLCBzYWZlT3ApIHtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQobyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKHRoaXMuI3ZhbCAtIG8uI3ZhbCwgc2FmZU9wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJW90aGVyJSUgc3VidHJhY3RlZFxuICAgICAqICBmcm9tICUldGhpcyUlLCBpZ25vcmluZyBvdmVyZmxvdy5cbiAgICAgKi9cbiAgICBzdWJVbnNhZmUob3RoZXIpIHsgcmV0dXJuIHRoaXMuI3N1YihvdGhlcik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUlb3RoZXIlJSBzdWJ0cmFjdGVkXG4gICAgICogIGZyb20gJSV0aGlzJSUuIEEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvd1xuICAgICAqICBvY2N1cnMuXG4gICAgICovXG4gICAgc3ViKG90aGVyKSB7IHJldHVybiB0aGlzLiNzdWIob3RoZXIsIFwic3ViXCIpOyB9XG4gICAgI211bChvLCBzYWZlT3ApIHtcbiAgICAgICAgdGhpcy4jY2hlY2tGb3JtYXQobyk7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGVja1ZhbHVlKCh0aGlzLiN2YWwgKiBvLiN2YWwpIC8gdGhpcy4jdGVucywgc2FmZU9wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBtdWx0aXBsaWVkXG4gICAgICogIGJ5ICUlb3RoZXIlJSwgaWdub3Jpbmcgb3ZlcmZsb3cgYW5kIHVuZGVyZmxvdyAocHJlY2lzaW9uIGxvc3MpLlxuICAgICAqL1xuICAgIG11bFVuc2FmZShvdGhlcikgeyByZXR1cm4gdGhpcy4jbXVsKG90aGVyKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSByZXN1bHQgb2YgJSV0aGlzJSUgbXVsdGlwbGllZFxuICAgICAqICBieSAlJW90aGVyJSUuIEEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlzIHRocm93biBpZiBvdmVyZmxvd1xuICAgICAqICBvY2N1cnMuXG4gICAgICovXG4gICAgbXVsKG90aGVyKSB7IHJldHVybiB0aGlzLiNtdWwob3RoZXIsIFwibXVsXCIpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIHJlc3VsdCBvZiAlJXRoaXMlJSBtdWx0aXBsaWVkXG4gICAgICogIGJ5ICUlb3RoZXIlJS4gQSBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIG92ZXJmbG93XG4gICAgICogIG9jY3VycyBvciBpZiB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKSBvY2N1cnMuXG4gICAgICovXG4gICAgbXVsU2lnbmFsKG90aGVyKSB7XG4gICAgICAgIHRoaXMuI2NoZWNrRm9ybWF0KG90aGVyKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiN2YWwgKiBvdGhlci4jdmFsO1xuICAgICAgICBhc3NlcnQoKHZhbHVlICUgdGhpcy4jdGVucykgPT09IEJOXzAsIFwicHJlY2lzaW9uIGxvc3QgZHVyaW5nIHNpZ25hbGxpbmcgbXVsXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwibXVsU2lnbmFsXCIsIGZhdWx0OiBcInVuZGVyZmxvd1wiLCB2YWx1ZTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodmFsdWUgLyB0aGlzLiN0ZW5zLCBcIm11bFNpZ25hbFwiKTtcbiAgICB9XG4gICAgI2RpdihvLCBzYWZlT3ApIHtcbiAgICAgICAgYXNzZXJ0KG8uI3ZhbCAhPT0gQk5fMCwgXCJkaXZpc2lvbiBieSB6ZXJvXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZGl2XCIsIGZhdWx0OiBcImRpdmlkZS1ieS16ZXJvXCIsIHZhbHVlOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNjaGVja0Zvcm1hdChvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUoKHRoaXMuI3ZhbCAqIHRoaXMuI3RlbnMpIC8gby4jdmFsLCBzYWZlT3ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIGRpdmlkZWRcbiAgICAgKiAgYnkgJSVvdGhlciUlLCBpZ25vcmluZyB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS4gQVxuICAgICAqICBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIG92ZXJmbG93IG9jY3Vycy5cbiAgICAgKi9cbiAgICBkaXZVbnNhZmUob3RoZXIpIHsgcmV0dXJuIHRoaXMuI2RpdihvdGhlcik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIGRpdmlkZWRcbiAgICAgKiAgYnkgJSVvdGhlciUlLCBpZ25vcmluZyB1bmRlcmZsb3cgKHByZWNpc2lvbiBsb3NzKS4gQVxuICAgICAqICBbW051bWVyaWNGYXVsdEVycm9yXV0gaXMgdGhyb3duIGlmIG92ZXJmbG93IG9jY3Vycy5cbiAgICAgKi9cbiAgICBkaXYob3RoZXIpIHsgcmV0dXJuIHRoaXMuI2RpdihvdGhlciwgXCJkaXZcIik7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgcmVzdWx0IG9mICUldGhpcyUlIGRpdmlkZWRcbiAgICAgKiAgYnkgJSVvdGhlciUlLiBBIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpcyB0aHJvd24gaWYgdW5kZXJmbG93XG4gICAgICogIChwcmVjaXNpb24gbG9zcykgb2NjdXJzLlxuICAgICAqL1xuICAgIGRpdlNpZ25hbChvdGhlcikge1xuICAgICAgICBhc3NlcnQob3RoZXIuI3ZhbCAhPT0gQk5fMCwgXCJkaXZpc2lvbiBieSB6ZXJvXCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZGl2XCIsIGZhdWx0OiBcImRpdmlkZS1ieS16ZXJvXCIsIHZhbHVlOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNjaGVja0Zvcm1hdChvdGhlcik7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gKHRoaXMuI3ZhbCAqIHRoaXMuI3RlbnMpO1xuICAgICAgICBhc3NlcnQoKHZhbHVlICUgb3RoZXIuI3ZhbCkgPT09IEJOXzAsIFwicHJlY2lzaW9uIGxvc3QgZHVyaW5nIHNpZ25hbGxpbmcgZGl2XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZGl2U2lnbmFsXCIsIGZhdWx0OiBcInVuZGVyZmxvd1wiLCB2YWx1ZTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodmFsdWUgLyBvdGhlci4jdmFsLCBcImRpdlNpZ25hbFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgYSBjb21wYXJpc29uIHJlc3VsdCBiZXR3ZWVuICUldGhpcyUlIGFuZCAlJW90aGVyJSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBzdWl0YWJsZSBmb3IgdXNlIGluIHNvcnRpbmcsIHdoZXJlIGBgLTFgYCBpbXBsaWVzICUldGhpcyUlXG4gICAgICogIGlzIHNtYWxsZXIsIGBgMWBgIGltcGxpZXMgJSV0aGlzJSUgaXMgbGFyZ2VyIGFuZCBgYDBgYCBpbXBsaWVzXG4gICAgICogIGJvdGggYXJlIGVxdWFsLlxuICAgICAqL1xuICAgIGNtcChvdGhlcikge1xuICAgICAgICBsZXQgYSA9IHRoaXMudmFsdWUsIGIgPSBvdGhlci52YWx1ZTtcbiAgICAgICAgLy8gQ29lcmNlIGEgYW5kIGIgdG8gdGhlIHNhbWUgbWFnbml0dWRlXG4gICAgICAgIGNvbnN0IGRlbHRhID0gdGhpcy5kZWNpbWFscyAtIG90aGVyLmRlY2ltYWxzO1xuICAgICAgICBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgICAgICBiICo9IGdldFRlbnMoZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICAgICAgYSAqPSBnZXRUZW5zKC1kZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tbnBhcmVcbiAgICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEgPiBiKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgaXMgZXF1YWwgdG8gJSV0aGlzJSUuXG4gICAgICovXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA9PT0gMDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGxlc3MgdGhhbiB0byAlJXRoaXMlJS5cbiAgICAgKi9cbiAgICBsdChvdGhlcikgeyByZXR1cm4gdGhpcy5jbXAob3RoZXIpIDwgMDsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRydWUgaWYgJSVvdGhlciUlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byAlJXRoaXMlJS5cbiAgICAgKi9cbiAgICBsdGUob3RoZXIpIHsgcmV0dXJuIHRoaXMuY21wKG90aGVyKSA8PSAwOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgaXMgZ3JlYXRlciB0aGFuIHRvICUldGhpcyUlLlxuICAgICAqL1xuICAgIGd0KG90aGVyKSB7IHJldHVybiB0aGlzLmNtcChvdGhlcikgPiAwOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJW90aGVyJSUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICUldGhpcyUlLlxuICAgICAqL1xuICAgIGd0ZShvdGhlcikgeyByZXR1cm4gdGhpcy5jbXAob3RoZXIpID49IDA7IH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2hpY2ggaXMgdGhlIGxhcmdlc3QgKippbnRlZ2VyKipcbiAgICAgKiAgdGhhdCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gJSV0aGlzJSUuXG4gICAgICpcbiAgICAgKiAgVGhlIGRlY2ltYWwgY29tcG9uZW50IG9mIHRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgYGAwYGAuXG4gICAgICovXG4gICAgZmxvb3IoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzLiN2YWw7XG4gICAgICAgIGlmICh0aGlzLiN2YWwgPCBCTl8wKSB7XG4gICAgICAgICAgICB2YWwgLT0gdGhpcy4jdGVucyAtIEJOXzE7XG4gICAgICAgIH1cbiAgICAgICAgdmFsID0gKHRoaXMuI3ZhbCAvIHRoaXMuI3RlbnMpICogdGhpcy4jdGVucztcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodmFsLCBcImZsb29yXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2hpY2ggaXMgdGhlIHNtYWxsZXN0ICoqaW50ZWdlcioqXG4gICAgICogIHRoYXQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICUldGhpcyUlLlxuICAgICAqXG4gICAgICogIFRoZSBkZWNpbWFsIGNvbXBvbmVudCBvZiB0aGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIGBgMGBgLlxuICAgICAqL1xuICAgIGNlaWxpbmcoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzLiN2YWw7XG4gICAgICAgIGlmICh0aGlzLiN2YWwgPiBCTl8wKSB7XG4gICAgICAgICAgICB2YWwgKz0gdGhpcy4jdGVucyAtIEJOXzE7XG4gICAgICAgIH1cbiAgICAgICAgdmFsID0gKHRoaXMuI3ZhbCAvIHRoaXMuI3RlbnMpICogdGhpcy4jdGVucztcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoZWNrVmFsdWUodmFsLCBcImNlaWxpbmdcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgbmV3IFtbRml4ZWROdW1iZXJdXSB3aXRoIHRoZSBkZWNpbWFsIGNvbXBvbmVudFxuICAgICAqICByb3VuZGVkIHVwIG9uIHRpZXMgYXQgJSVkZWNpbWFscyUlIHBsYWNlcy5cbiAgICAgKi9cbiAgICByb3VuZChkZWNpbWFscykge1xuICAgICAgICBpZiAoZGVjaW1hbHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVjaW1hbHMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdCBlbm91Z2ggcHJlY2lzaW9uIHRvIG5vdCBhbHJlYWR5IGJlIHJvdW5kZWRcbiAgICAgICAgaWYgKGRlY2ltYWxzID49IHRoaXMuZGVjaW1hbHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlbHRhID0gdGhpcy5kZWNpbWFscyAtIGRlY2ltYWxzO1xuICAgICAgICBjb25zdCBidW1wID0gQk5fNSAqIGdldFRlbnMoZGVsdGEgLSAxKTtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy52YWx1ZSArIGJ1bXA7XG4gICAgICAgIGNvbnN0IHRlbnMgPSBnZXRUZW5zKGRlbHRhKTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgLyB0ZW5zKSAqIHRlbnM7XG4gICAgICAgIGNoZWNrVmFsdWUodmFsdWUsIHRoaXMuI2Zvcm1hdCwgXCJyb3VuZFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfZ3VhcmQsIHZhbHVlLCB0aGlzLiNmb3JtYXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgUmV0dXJucyB0cnVlIGlmICUldGhpcyUlIGlzIGVxdWFsIHRvIGBgMGBgLlxuICAgICAqL1xuICAgIGlzWmVybygpIHsgcmV0dXJuICh0aGlzLiN2YWwgPT09IEJOXzApOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybnMgdHJ1ZSBpZiAlJXRoaXMlJSBpcyBsZXNzIHRoYW4gYGAwYGAuXG4gICAgICovXG4gICAgaXNOZWdhdGl2ZSgpIHsgcmV0dXJuICh0aGlzLiN2YWwgPCBCTl8wKTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgJSV0aGlzJSUuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLl92YWx1ZTsgfVxuICAgIC8qKlxuICAgICAqICBSZXR1cm5zIGEgZmxvYXQgYXBwcm94aW1hdGlvbi5cbiAgICAgKlxuICAgICAqICBEdWUgdG8gSUVFRSA3NTQgcHJlY2lzc2lvbiAob3IgbGFjayB0aGVyZW9mKSwgdGhpcyBmdW5jdGlvblxuICAgICAqICBjYW4gb25seSByZXR1cm4gYW4gYXBwcm94aW1hdGlvbiBhbmQgbW9zdCB2YWx1ZXMgd2lsbCBjb250YWluXG4gICAgICogIHJvdW5kaW5nIGVycm9ycy5cbiAgICAgKi9cbiAgICB0b1Vuc2FmZUZsb2F0KCkgeyByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLnRvU3RyaW5nKCkpOyB9XG4gICAgLyoqXG4gICAgICogIFJldHVybiBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gd2l0aCB0aGUgc2FtZSB2YWx1ZSBidXQgaGFzIGhhZFxuICAgICAqICBpdHMgZmllbGQgc2V0IHRvICUlZm9ybWF0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGlmIHRoZSB2YWx1ZSBjYW5ub3QgZml0IGludG8gJSVmb3JtYXQlJS5cbiAgICAgKi9cbiAgICB0b0Zvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21TdHJpbmcodGhpcy50b1N0cmluZygpLCBmb3JtYXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQ3JlYXRlcyBhIG5ldyBbW0ZpeGVkTnVtYmVyXV0gZm9yICUldmFsdWUlJSBkaXZpZGVkIGJ5XG4gICAgICogICUlZGVjaW1hbCUlIHBsYWNlcyB3aXRoICUlZm9ybWF0JSUuXG4gICAgICpcbiAgICAgKiAgVGhpcyB3aWxsIHRocm93IGEgW1tOdW1lcmljRmF1bHRFcnJvcl1dIGlmICUldmFsdWUlJSAob25jZSBhZGp1c3RlZFxuICAgICAqICBmb3IgJSVkZWNpbWFscyUlKSBjYW5ub3QgZml0IGluICUlZm9ybWF0JSUsIGVpdGhlciBkdWUgdG8gb3ZlcmZsb3dcbiAgICAgKiAgb3IgdW5kZXJmbG93IChwcmVjaXNpb24gbG9zcykuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21WYWx1ZShfdmFsdWUsIF9kZWNpbWFscywgX2Zvcm1hdCkge1xuICAgICAgICBjb25zdCBkZWNpbWFscyA9IChfZGVjaW1hbHMgPT0gbnVsbCkgPyAwIDogZ2V0TnVtYmVyKF9kZWNpbWFscyk7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IGdldEZvcm1hdChfZm9ybWF0KTtcbiAgICAgICAgbGV0IHZhbHVlID0gZ2V0QmlnSW50KF92YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBkZWNpbWFscyAtIGZvcm1hdC5kZWNpbWFscztcbiAgICAgICAgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICAgICAgY29uc3QgdGVucyA9IGdldFRlbnMoZGVsdGEpO1xuICAgICAgICAgICAgYXNzZXJ0KCh2YWx1ZSAlIHRlbnMpID09PSBCTl8wLCBcInZhbHVlIGxvc2VzIHByZWNpc2lvbiBmb3IgZm9ybWF0XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZyb21WYWx1ZVwiLCBmYXVsdDogXCJ1bmRlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YWx1ZSAvPSB0ZW5zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgICAgICAgdmFsdWUgKj0gZ2V0VGVucygtZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrVmFsdWUodmFsdWUsIGZvcm1hdCwgXCJmcm9tVmFsdWVcIik7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2d1YXJkLCB2YWx1ZSwgZm9ybWF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIGZvciAlJXZhbHVlJSUgd2l0aCAlJWZvcm1hdCUlLlxuICAgICAqXG4gICAgICogIFRoaXMgd2lsbCB0aHJvdyBhIFtbTnVtZXJpY0ZhdWx0RXJyb3JdXSBpZiAlJXZhbHVlJSUgY2Fubm90IGZpdFxuICAgICAqICBpbiAlJWZvcm1hdCUlLCBlaXRoZXIgZHVlIHRvIG92ZXJmbG93IG9yIHVuZGVyZmxvdyAocHJlY2lzaW9uIGxvc3MpLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU3RyaW5nKF92YWx1ZSwgX2Zvcm1hdCkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IF92YWx1ZS5tYXRjaCgvXigtPykoWzAtOV0qKVxcLj8oWzAtOV0qKSQvKTtcbiAgICAgICAgYXNzZXJ0QXJndW1lbnQobWF0Y2ggJiYgKG1hdGNoWzJdLmxlbmd0aCArIG1hdGNoWzNdLmxlbmd0aCkgPiAwLCBcImludmFsaWQgRml4ZWROdW1iZXIgc3RyaW5nIHZhbHVlXCIsIFwidmFsdWVcIiwgX3ZhbHVlKTtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gZ2V0Rm9ybWF0KF9mb3JtYXQpO1xuICAgICAgICBsZXQgd2hvbGUgPSAobWF0Y2hbMl0gfHwgXCIwXCIpLCBkZWNpbWFsID0gKG1hdGNoWzNdIHx8IFwiXCIpO1xuICAgICAgICAvLyBQYWQgb3V0IHRoZSBkZWNpbWFsc1xuICAgICAgICB3aGlsZSAoZGVjaW1hbC5sZW5ndGggPCBmb3JtYXQuZGVjaW1hbHMpIHtcbiAgICAgICAgICAgIGRlY2ltYWwgKz0gWmVyb3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgcHJlY2lzaW9uIGlzIHNhZmVcbiAgICAgICAgYXNzZXJ0KGRlY2ltYWwuc3Vic3RyaW5nKGZvcm1hdC5kZWNpbWFscykubWF0Y2goL14wKiQvKSwgXCJ0b28gbWFueSBkZWNpbWFscyBmb3IgZm9ybWF0XCIsIFwiTlVNRVJJQ19GQVVMVFwiLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiZnJvbVN0cmluZ1wiLCBmYXVsdDogXCJ1bmRlcmZsb3dcIiwgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmVtb3ZlIGV4dHJhIHBhZGRpbmdcbiAgICAgICAgZGVjaW1hbCA9IGRlY2ltYWwuc3Vic3RyaW5nKDAsIGZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gQmlnSW50KG1hdGNoWzFdICsgd2hvbGUgKyBkZWNpbWFsKTtcbiAgICAgICAgY2hlY2tWYWx1ZSh2YWx1ZSwgZm9ybWF0LCBcImZyb21TdHJpbmdcIik7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2d1YXJkLCB2YWx1ZSwgZm9ybWF0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIENyZWF0ZXMgYSBuZXcgW1tGaXhlZE51bWJlcl1dIHdpdGggdGhlIGJpZy1lbmRpYW4gcmVwcmVzZW50YXRpb25cbiAgICAgKiAgJSV2YWx1ZSUlIHdpdGggJSVmb3JtYXQlJS5cbiAgICAgKlxuICAgICAqICBUaGlzIHdpbGwgdGhyb3cgYSBbW051bWVyaWNGYXVsdEVycm9yXV0gaWYgJSV2YWx1ZSUlIGNhbm5vdCBmaXRcbiAgICAgKiAgaW4gJSVmb3JtYXQlJSBkdWUgdG8gb3ZlcmZsb3cuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21CeXRlcyhfdmFsdWUsIF9mb3JtYXQpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdG9CaWdJbnQoZ2V0Qnl0ZXMoX3ZhbHVlLCBcInZhbHVlXCIpKTtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gZ2V0Rm9ybWF0KF9mb3JtYXQpO1xuICAgICAgICBpZiAoZm9ybWF0LnNpZ25lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmcm9tVHdvcyh2YWx1ZSwgZm9ybWF0LndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja1ZhbHVlKHZhbHVlLCBmb3JtYXQsIFwiZnJvbUJ5dGVzXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9ndWFyZCwgdmFsdWUsIGZvcm1hdCk7XG4gICAgfVxufVxuLy9jb25zdCBmMSA9IEZpeGVkTnVtYmVyLmZyb21TdHJpbmcoXCIxMi41NlwiLCBcImZpeGVkMTZ4MlwiKTtcbi8vY29uc3QgZjIgPSBGaXhlZE51bWJlci5mcm9tU3RyaW5nKFwiMC4zXCIsIFwiZml4ZWQxNngyXCIpO1xuLy9jb25zb2xlLmxvZyhmMS5kaXZTaWduYWwoZjIpKTtcbi8vY29uc3QgQlVNUCA9IEZpeGVkTnVtYmVyLmZyb20oXCIwLjVcIik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maXhlZG51bWJlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/utils/fixednumber.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ethers/lib.esm/utils/units.js":
/*!****************************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils/units.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatEther: function() { return /* binding */ formatEther; },\n/* harmony export */   formatUnits: function() { return /* binding */ formatUnits; },\n/* harmony export */   parseEther: function() { return /* binding */ parseEther; },\n/* harmony export */   parseUnits: function() { return /* binding */ parseUnits; }\n/* harmony export */ });\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/errors.js\");\n/* harmony import */ var _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fixednumber.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/fixednumber.js\");\n/* harmony import */ var _maths_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths.js */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/maths.js\");\n/**\n *  Most interactions with Ethereum requires integer values, which use\n *  the smallest magnitude unit.\n *\n *  For example, imagine dealing with dollars and cents. Since dollars\n *  are divisible, non-integer values are possible, such as ``$10.77``.\n *  By using the smallest indivisible unit (i.e. cents), the value can\n *  be kept as the integer ``1077``.\n *\n *  When receiving decimal input from the user (as a decimal string),\n *  the value should be converted to an integer and when showing a user\n *  a value, the integer value should be converted to a decimal string.\n *\n *  This creates a clear distinction, between values to be used by code\n *  (integers) and values used for display logic to users (decimals).\n *\n *  The native unit in Ethereum, //ether// is divisible to 18 decimal places,\n *  where each individual unit is called a //wei//.\n *\n *  @_subsection api/utils:Unit Conversion  [about-units]\n */\n\n\n\nconst names = [\n    \"wei\",\n    \"kwei\",\n    \"mwei\",\n    \"gwei\",\n    \"szabo\",\n    \"finney\",\n    \"ether\",\n];\n/**\n *  Converts %%value%% into a //decimal string//, assuming %%unit%% decimal\n *  places. The %%unit%% may be the number of decimal places or the name of\n *  a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n *\n */\nfunction formatUnits(value, unit) {\n    let decimals = 18;\n    if (typeof (unit) === \"string\") {\n        const index = names.indexOf(unit);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    }\n    else if (unit != null) {\n        decimals = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(unit, \"unit\");\n    }\n    return _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__.FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();\n}\n/**\n *  Converts the //decimal string// %%value%% to a BigInt, assuming\n *  %%unit%% decimal places. The %%unit%% may the number of decimal places\n *  or the name of a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n */\nfunction parseUnits(value, unit) {\n    (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(typeof (value) === \"string\", \"value must be a string\", \"value\", value);\n    let decimals = 18;\n    if (typeof (unit) === \"string\") {\n        const index = names.indexOf(unit);\n        (0,_errors_js__WEBPACK_IMPORTED_MODULE_0__.assertArgument)(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    }\n    else if (unit != null) {\n        decimals = (0,_maths_js__WEBPACK_IMPORTED_MODULE_1__.getNumber)(unit, \"unit\");\n    }\n    return _fixednumber_js__WEBPACK_IMPORTED_MODULE_2__.FixedNumber.fromString(value, { decimals, width: 512 }).value;\n}\n/**\n *  Converts %%value%% into a //decimal string// using 18 decimal places.\n */\nfunction formatEther(wei) {\n    return formatUnits(wei, 18);\n}\n/**\n *  Converts the //decimal string// %%ether%% to a BigInt, using 18\n *  decimal places.\n */\nfunction parseEther(ether) {\n    return parseUnits(ether, 18);\n}\n//# sourceMappingURL=units.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy91bml0cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzZDO0FBQ0U7QUFDUjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMERBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFTO0FBQzVCO0FBQ0EsV0FBVyx3REFBVyw4QkFBOEIsc0JBQXNCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSwwREFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvREFBUztBQUM1QjtBQUNBLFdBQVcsd0RBQVcscUJBQXFCLHNCQUFzQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL3V0aWxzL3VuaXRzLmpzPzQ4NzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgTW9zdCBpbnRlcmFjdGlvbnMgd2l0aCBFdGhlcmV1bSByZXF1aXJlcyBpbnRlZ2VyIHZhbHVlcywgd2hpY2ggdXNlXG4gKiAgdGhlIHNtYWxsZXN0IG1hZ25pdHVkZSB1bml0LlxuICpcbiAqICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBkZWFsaW5nIHdpdGggZG9sbGFycyBhbmQgY2VudHMuIFNpbmNlIGRvbGxhcnNcbiAqICBhcmUgZGl2aXNpYmxlLCBub24taW50ZWdlciB2YWx1ZXMgYXJlIHBvc3NpYmxlLCBzdWNoIGFzIGBgJDEwLjc3YGAuXG4gKiAgQnkgdXNpbmcgdGhlIHNtYWxsZXN0IGluZGl2aXNpYmxlIHVuaXQgKGkuZS4gY2VudHMpLCB0aGUgdmFsdWUgY2FuXG4gKiAgYmUga2VwdCBhcyB0aGUgaW50ZWdlciBgYDEwNzdgYC5cbiAqXG4gKiAgV2hlbiByZWNlaXZpbmcgZGVjaW1hbCBpbnB1dCBmcm9tIHRoZSB1c2VyIChhcyBhIGRlY2ltYWwgc3RyaW5nKSxcbiAqICB0aGUgdmFsdWUgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhbiBpbnRlZ2VyIGFuZCB3aGVuIHNob3dpbmcgYSB1c2VyXG4gKiAgYSB2YWx1ZSwgdGhlIGludGVnZXIgdmFsdWUgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhIGRlY2ltYWwgc3RyaW5nLlxuICpcbiAqICBUaGlzIGNyZWF0ZXMgYSBjbGVhciBkaXN0aW5jdGlvbiwgYmV0d2VlbiB2YWx1ZXMgdG8gYmUgdXNlZCBieSBjb2RlXG4gKiAgKGludGVnZXJzKSBhbmQgdmFsdWVzIHVzZWQgZm9yIGRpc3BsYXkgbG9naWMgdG8gdXNlcnMgKGRlY2ltYWxzKS5cbiAqXG4gKiAgVGhlIG5hdGl2ZSB1bml0IGluIEV0aGVyZXVtLCAvL2V0aGVyLy8gaXMgZGl2aXNpYmxlIHRvIDE4IGRlY2ltYWwgcGxhY2VzLFxuICogIHdoZXJlIGVhY2ggaW5kaXZpZHVhbCB1bml0IGlzIGNhbGxlZCBhIC8vd2VpLy8uXG4gKlxuICogIEBfc3Vic2VjdGlvbiBhcGkvdXRpbHM6VW5pdCBDb252ZXJzaW9uICBbYWJvdXQtdW5pdHNdXG4gKi9cbmltcG9ydCB7IGFzc2VydEFyZ3VtZW50IH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBGaXhlZE51bWJlciB9IGZyb20gXCIuL2ZpeGVkbnVtYmVyLmpzXCI7XG5pbXBvcnQgeyBnZXROdW1iZXIgfSBmcm9tIFwiLi9tYXRocy5qc1wiO1xuY29uc3QgbmFtZXMgPSBbXG4gICAgXCJ3ZWlcIixcbiAgICBcImt3ZWlcIixcbiAgICBcIm13ZWlcIixcbiAgICBcImd3ZWlcIixcbiAgICBcInN6YWJvXCIsXG4gICAgXCJmaW5uZXlcIixcbiAgICBcImV0aGVyXCIsXG5dO1xuLyoqXG4gKiAgQ29udmVydHMgJSV2YWx1ZSUlIGludG8gYSAvL2RlY2ltYWwgc3RyaW5nLy8sIGFzc3VtaW5nICUldW5pdCUlIGRlY2ltYWxcbiAqICBwbGFjZXMuIFRoZSAlJXVuaXQlJSBtYXkgYmUgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvciB0aGUgbmFtZSBvZlxuICogIGEgdW5pdCAoZS5nLiBgYFwiZ3dlaVwiYGAgZm9yIDkgZGVjaW1hbCBwbGFjZXMpLlxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFVuaXRzKHZhbHVlLCB1bml0KSB7XG4gICAgbGV0IGRlY2ltYWxzID0gMTg7XG4gICAgaWYgKHR5cGVvZiAodW5pdCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBuYW1lcy5pbmRleE9mKHVuaXQpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA+PSAwLCBcImludmFsaWQgdW5pdFwiLCBcInVuaXRcIiwgdW5pdCk7XG4gICAgICAgIGRlY2ltYWxzID0gMyAqIGluZGV4O1xuICAgIH1cbiAgICBlbHNlIGlmICh1bml0ICE9IG51bGwpIHtcbiAgICAgICAgZGVjaW1hbHMgPSBnZXROdW1iZXIodW5pdCwgXCJ1bml0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKHZhbHVlLCBkZWNpbWFscywgeyBkZWNpbWFscywgd2lkdGg6IDUxMiB9KS50b1N0cmluZygpO1xufVxuLyoqXG4gKiAgQ29udmVydHMgdGhlIC8vZGVjaW1hbCBzdHJpbmcvLyAlJXZhbHVlJSUgdG8gYSBCaWdJbnQsIGFzc3VtaW5nXG4gKiAgJSV1bml0JSUgZGVjaW1hbCBwbGFjZXMuIFRoZSAlJXVuaXQlJSBtYXkgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuICogIG9yIHRoZSBuYW1lIG9mIGEgdW5pdCAoZS5nLiBgYFwiZ3dlaVwiYGAgZm9yIDkgZGVjaW1hbCBwbGFjZXMpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VVbml0cyh2YWx1ZSwgdW5pdCkge1xuICAgIGFzc2VydEFyZ3VtZW50KHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiLCBcInZhbHVlIG11c3QgYmUgYSBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgbGV0IGRlY2ltYWxzID0gMTg7XG4gICAgaWYgKHR5cGVvZiAodW5pdCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBuYW1lcy5pbmRleE9mKHVuaXQpO1xuICAgICAgICBhc3NlcnRBcmd1bWVudChpbmRleCA+PSAwLCBcImludmFsaWQgdW5pdFwiLCBcInVuaXRcIiwgdW5pdCk7XG4gICAgICAgIGRlY2ltYWxzID0gMyAqIGluZGV4O1xuICAgIH1cbiAgICBlbHNlIGlmICh1bml0ICE9IG51bGwpIHtcbiAgICAgICAgZGVjaW1hbHMgPSBnZXROdW1iZXIodW5pdCwgXCJ1bml0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVN0cmluZyh2YWx1ZSwgeyBkZWNpbWFscywgd2lkdGg6IDUxMiB9KS52YWx1ZTtcbn1cbi8qKlxuICogIENvbnZlcnRzICUldmFsdWUlJSBpbnRvIGEgLy9kZWNpbWFsIHN0cmluZy8vIHVzaW5nIDE4IGRlY2ltYWwgcGxhY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RXRoZXIod2VpKSB7XG4gICAgcmV0dXJuIGZvcm1hdFVuaXRzKHdlaSwgMTgpO1xufVxuLyoqXG4gKiAgQ29udmVydHMgdGhlIC8vZGVjaW1hbCBzdHJpbmcvLyAlJWV0aGVyJSUgdG8gYSBCaWdJbnQsIHVzaW5nIDE4XG4gKiAgZGVjaW1hbCBwbGFjZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUV0aGVyKGV0aGVyKSB7XG4gICAgcmV0dXJuIHBhcnNlVW5pdHMoZXRoZXIsIDE4KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaXRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ethers/lib.esm/utils/units.js\n"));

/***/ })

});