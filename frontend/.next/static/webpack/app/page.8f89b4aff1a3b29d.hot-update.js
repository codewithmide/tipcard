"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/solana-native-contract.ts":
/*!*****************************************!*\
  !*** ./utils/solana-native-contract.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaNativeContract: function() { return /* binding */ SolanaNativeContract; },\n/* harmony export */   solanaNativeContract: function() { return /* binding */ solanaNativeContract; }\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var _neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @neonevm/solana-sign */ \"(app-pages-browser)/./node_modules/@neonevm/solana-sign/dist/esm/index.mjs\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/abi/interface.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var _contractABI_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contractABI.json */ \"(app-pages-browser)/./utils/contractABI.json\");\n\n\n\n\n// Use the actual deployed contract ABI\nconst SOLANA_TIPCARD_ABI = _contractABI_json__WEBPACK_IMPORTED_MODULE_2__;\nconst CONTRACT_ADDRESS = \"0xCFE03c7c67456D094C0162F9030393FC2cCc40Cb\" || 0;\nconst NEON_CORE_RPC_URL = \"https://devnet.neonevm.org\" || 0;\nconst NEON_PROXY_RPC_URL = \"\".concat(NEON_CORE_RPC_URL, \"/sol\");\nconst SOLANA_RPC_URL = \"https://api.devnet.solana.com\";\nclass SolanaNativeContract {\n    /**\n   * Initialize with Solana wallet using the recommended SolanaNeonAccount approach\n   */ async initWithSolanaWallet(walletAdapter) {\n        if (!walletAdapter.publicKey) {\n            throw new Error(\"Wallet not connected\");\n        }\n        try {\n            var _this_solanaUser_balanceAddress;\n            console.log(\"\\uD83D\\uDD27 Using recommended SolanaNeonAccount approach...\");\n            console.log(\"Wallet public key:\", walletAdapter.publicKey.toBase58());\n            // Use proxyApi.init with just the public key (like demo)\n            const { provider, chainId, solanaUser, tokenMintAddress, programAddress } = await this.proxyApi.init(walletAdapter.publicKey);\n            console.log(\"- Chain ID:\", chainId);\n            console.log(\"- Neon EVM Program:\", programAddress.toBase58());\n            // Store the result with wallet adapter for signing\n            this.chainId = chainId;\n            this.solanaUser = {\n                ...solanaUser,\n                walletAdapter: walletAdapter // Add wallet adapter for signing\n            };\n            // Create balance address if it doesn't exist (using SolanaNeonAccount approach)\n            if (!this.solanaUser.balanceAddress) {\n                const { SolanaNeonAccount } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @neonevm/solana-sign */ \"(app-pages-browser)/./node_modules/@neonevm/solana-sign/dist/esm/index.mjs\"));\n                const account = new SolanaNeonAccount(this.solanaUser.publicKey, this.solanaUser.neonEvmProgram, this.solanaUser.tokenMint, this.solanaUser.chainId);\n                this.solanaUser.balanceAddress = account.balanceAddress;\n            }\n            // Verify they match\n            if (walletAdapter.publicKey.toBase58() === this.solanaUser.publicKey.toBase58()) {\n                console.log(\"‚úÖ Wallet public keys match correctly!\");\n            } else {\n                console.error(\"‚ùå MISMATCH: Wallet adapter and solana user have different public keys!\");\n                console.error(\"Wallet adapter:\", walletAdapter.publicKey.toBase58());\n                console.error(\"Solana user:\", this.solanaUser.publicKey.toBase58());\n            }\n            console.log(\"\\uD83D\\uDCB0 Final balance address:\", ((_this_solanaUser_balanceAddress = this.solanaUser.balanceAddress) === null || _this_solanaUser_balanceAddress === void 0 ? void 0 : _this_solanaUser_balanceAddress.toBase58()) || \"Still not available\");\n            // Create contract instance\n            const readOnlyProvider = new ethers__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider(NEON_CORE_RPC_URL);\n            this.contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.Contract(CONTRACT_ADDRESS, SOLANA_TIPCARD_ABI, readOnlyProvider);\n            try {\n                // Check if this EVM address has been used before (has transaction history)\n                const txCount = await readOnlyProvider.getTransactionCount(this.solanaUser.neonWallet);\n                console.log(\"\\uD83D\\uDCCA EVM address transaction count:\", txCount);\n                if (txCount > 0) {\n                    console.log(\"‚úÖ This EVM address has transaction history - it exists on-chain!\");\n                } else {\n                    console.log(\"‚ÑπÔ∏è This EVM address is new (no transaction history yet)\");\n                    console.log(\"‚ÑπÔ∏è The address will be registered on-chain when first transaction is made\");\n                }\n            } catch (verifyError) {\n                console.log(\"‚ö†Ô∏è Could not verify EVM address:\", verifyError);\n            }\n            // Verify contract is deployed at this address\n            try {\n                const code = await readOnlyProvider.getCode(CONTRACT_ADDRESS);\n                if (code === \"0x\") {\n                    console.warn(\"‚ö†Ô∏è No contract code found at address:\", CONTRACT_ADDRESS);\n                    console.log(\"This might mean the contract is not deployed or address is incorrect\");\n                } else {\n                    console.log(\"‚úÖ Contract found at address\");\n                    console.log(\"‚úÖ Contract found and ready for transactions\");\n                }\n            } catch (verifyError) {\n                console.warn(\"Failed to verify contract:\", verifyError);\n            }\n        } catch (error) {\n            console.error(\"Failed to initialize Solana Native SDK:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Create a payment link using Solana Native SDK with proper nonce management\n   */ async createPaymentLink(suggestedAmountSOL, isFlexible, description) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        // Convert SOL to lamports (1 SOL = 1e9 lamports)\n        const amountLamports = Math.floor(suggestedAmountSOL * 1e9);\n        let signature = \"\";\n        try {\n            // üîß ENHANCED NONCE MANAGEMENT\n            console.log(\"\\uD83D\\uDD27 Getting current nonce with retry logic...\");\n            let nonce;\n            let retryCount = 0;\n            const maxRetries = 3;\n            while(retryCount < maxRetries){\n                try {\n                    // Get the current transaction count (nonce)\n                    nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n                    console.log(\"Attempt \".concat(retryCount + 1, \": Current nonce: \").concat(nonce));\n                    // Check if there are pending transactions with this nonce\n                    try {\n                        const pendingTx = await this.proxyApi.getTransactionBySenderNonce(this.solanaUser.neonWallet, nonce);\n                        if (pendingTx) {\n                            console.log(\"‚ö†Ô∏è Found existing transaction with nonce \".concat(nonce, \", incrementing...\"));\n                            nonce = nonce + 1;\n                            console.log(\"\\uD83D\\uDCC8 Using incremented nonce: \".concat(nonce));\n                        }\n                    } catch (pendingError) {\n                        // No pending transaction found, nonce is safe to use\n                        console.log(\"‚úÖ Nonce \".concat(nonce, \" is available\"));\n                    }\n                    break; // Success, exit retry loop\n                } catch (error) {\n                    retryCount++;\n                    console.log(\"‚ùå Nonce fetch attempt \".concat(retryCount, \" failed:\"), error.message);\n                    if (retryCount >= maxRetries) {\n                        throw new Error(\"Failed to get valid nonce after \".concat(maxRetries, \" attempts\"));\n                    }\n                    // Wait before retry\n                    await new Promise((resolve)=>setTimeout(resolve, 1000));\n                }\n            }\n            console.log(\"\\uD83C\\uDFAF Final nonce to use: \".concat(nonce));\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"createSolanaPaymentLink\", [\n                amountLamports,\n                isFlexible,\n                description\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            console.log(\"\\uD83D\\uDD27 Estimating gas...\");\n            // Estimate gas with retry logic\n            let transactionGas;\n            retryCount = 0;\n            while(retryCount < maxRetries){\n                try {\n                    transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                        solanaPayer: this.solanaUser.publicKey,\n                        transactions: [\n                            transactionData\n                        ]\n                    });\n                    break;\n                } catch (gasError) {\n                    retryCount++;\n                    console.log(\"Gas estimation attempt \".concat(retryCount, \" failed:\"), gasError.message);\n                    if (retryCount >= maxRetries) {\n                        throw new Error(\"Gas estimation failed after \".concat(maxRetries, \" attempts: \").concat(gasError.message));\n                    }\n                    await new Promise((resolve)=>setTimeout(resolve, 1000));\n                }\n            }\n            console.log(\"\\uD83D\\uDCDD Creating scheduled transaction...\");\n            // Create scheduled transaction with the confirmed nonce\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Check if balance account exists, if not create it\n            console.log(\"\\uD83D\\uDCB0 Checking balance account...\");\n            const account = await this.connection.getAccountInfo(this.solanaUser.balanceAddress);\n            if (account === null) {\n                console.log(\"\\uD83D\\uDCDD Adding balance account instruction...\");\n                scheduledTransaction.instructions.unshift((0,_neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__.createBalanceAccountInstruction)(this.solanaUser.neonEvmProgram, this.solanaUser.publicKey, this.solanaUser.neonWallet, this.chainId));\n            }\n            // üîß ENHANCED TRANSACTION SIGNING\n            console.log(\"‚úçÔ∏è Preparing transaction for signing...\");\n            // Get fresh blockhash\n            const { blockhash } = await this.connection.getLatestBlockhash(\"finalized\");\n            scheduledTransaction.recentBlockhash = blockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            console.log(\"\\uD83D\\uDD0F Requesting wallet signature...\");\n            console.log(\"   Transaction nonce: \".concat(nonce));\n            console.log(\"   Fee payer: \".concat(this.solanaUser.publicKey.toBase58()));\n            console.log(\"   Instructions count: \".concat(scheduledTransaction.instructions.length));\n            // Sign transaction\n            const signedTransaction = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            console.log(\"\\uD83D\\uDCE1 Submitting transaction...\");\n            signature = await this.connection.sendRawTransaction(signedTransaction.serialize(), {\n                skipPreflight: false,\n                preflightCommitment: \"confirmed\"\n            });\n            console.log(\"\\uD83D\\uDD17 Transaction submitted successfully!\");\n            console.log(\"   Signature: \".concat(signature));\n            console.log(\"   Nonce used: \".concat(nonce));\n            // Enhanced confirmation waiting\n            console.log(\"‚è≥ Waiting for transaction confirmation...\");\n            let confirmed = false;\n            let confirmRetries = 0;\n            const maxConfirmRetries = 10;\n            while(!confirmed && confirmRetries < maxConfirmRetries){\n                await new Promise((resolve)=>setTimeout(resolve, 2000));\n                try {\n                    var _confirmation_value;\n                    const confirmation = await this.connection.getSignatureStatus(signature);\n                    if ((_confirmation_value = confirmation.value) === null || _confirmation_value === void 0 ? void 0 : _confirmation_value.confirmationStatus) {\n                        console.log(\"\\uD83D\\uDCCA Transaction status: \".concat(confirmation.value.confirmationStatus));\n                        if (confirmation.value.confirmationStatus === \"confirmed\" || confirmation.value.confirmationStatus === \"finalized\") {\n                            confirmed = true;\n                            break;\n                        }\n                    }\n                } catch (confirmError) {\n                    console.log(\"‚ö†Ô∏è Confirmation check \".concat(confirmRetries + 1, \" failed: \").concat(confirmError.message));\n                }\n                confirmRetries++;\n            }\n            if (confirmed) {\n                console.log(\"‚úÖ Transaction confirmed!\");\n            } else {\n                console.log(\"‚ö†Ô∏è Transaction confirmation timeout, but transaction may still succeed\");\n            }\n            // Wait a bit more for Neon EVM processing\n            console.log(\"\\uD83D\\uDD04 Waiting for Neon EVM processing...\");\n            await new Promise((resolve)=>setTimeout(resolve, 3000));\n            // Get Neon EVM transaction details\n            console.log(\"\\uD83D\\uDD0D Getting Neon EVM transaction details...\");\n            try {\n                const neonTxResponse = await fetch(\"https://devnet.neonevm.org/sol\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        method: \"neon_getTransactionBySenderNonce\",\n                        params: [\n                            this.solanaUser.neonWallet,\n                            nonce\n                        ],\n                        id: 1,\n                        jsonrpc: \"2.0\"\n                    })\n                });\n                const neonTxResult = await neonTxResponse.json();\n                console.log(\"\\uD83D\\uDCCB Neon EVM transaction result:\", neonTxResult);\n                if (neonTxResult.result && neonTxResult.result.hash) {\n                    console.log(\"‚úÖ Neon EVM transaction hash: \".concat(neonTxResult.result.hash));\n                    return {\n                        linkId: neonTxResult.result.hash,\n                        txHash: neonTxResult.result.hash\n                    };\n                } else {\n                    console.log(\"‚ÑπÔ∏è Neon EVM transaction not found yet, using Solana signature\");\n                }\n            } catch (neonError) {\n                console.log(\"‚ö†Ô∏è Could not get Neon EVM transaction details: \".concat(neonError.message));\n            }\n            // Return Solana signature as fallback\n            return {\n                linkId: signature,\n                txHash: signature\n            };\n        } catch (error) {\n            var _error_message, _error_message1, _error_message2;\n            console.error(\"‚ùå Error creating payment link:\", error);\n            // Enhanced error handling\n            if ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"Transaction Tree - transaction with the same nonce already exists\")) {\n                throw new Error(\"Nonce conflict: A transaction with this nonce is already pending. Please try again in a few seconds.\");\n            } else if ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"insufficient funds\")) {\n                throw new Error(\"Insufficient SOL balance for transaction fees. Please add more SOL to your wallet.\");\n            } else if ((_error_message2 = error.message) === null || _error_message2 === void 0 ? void 0 : _error_message2.includes(\"User rejected\")) {\n                throw new Error(\"Transaction was rejected by the user.\");\n            } else {\n                throw error;\n            }\n        }\n    }\n    /**\n   * Initialize read-only contract access (without wallet)\n   */ async initReadOnlyContract() {\n        if (!this.contract) {\n            // Create a simple JSON RPC provider for read operations\n            const readOnlyProvider = new ethers__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider(NEON_CORE_RPC_URL);\n            this.contract = new ethers__WEBPACK_IMPORTED_MODULE_4__.Contract(CONTRACT_ADDRESS, SOLANA_TIPCARD_ABI, readOnlyProvider);\n        }\n    }\n    /**\n   * Get payment link details\n   */ async getPaymentLink(linkId) {\n        // Initialize contract if not already done\n        if (!this.contract) {\n            await this.initReadOnlyContract();\n        }\n        console.log(\"Getting payment link with ID:\", linkId);\n        console.log(\"Contract address:\", CONTRACT_ADDRESS);\n        try {\n            const result = await this.contract.getSolanaPaymentLink(linkId);\n            console.log(\"Raw contract result:\", result);\n            const paymentLink = {\n                evmCreator: result.evmCreator,\n                solanaCreator: result.solanaCreator,\n                amount: result.amount,\n                isFlexible: result.isFlexible,\n                isActive: result.isActive,\n                totalReceived: result.totalReceived,\n                paymentCount: Number(result.paymentCount),\n                description: result.description\n            };\n            // Check if this looks like an empty/non-existent link (transaction not processed yet)\n            if (result.evmCreator === \"0x0000000000000000000000000000000000000000\" && result.amount === BigInt(0) && !result.isActive) {\n                console.warn(\"Payment link appears to be empty/non-existent\");\n                // If this looks like a transaction hash (66 chars, starts with 0x), provide helpful info\n                if (linkId.length === 66 && linkId.startsWith(\"0x\")) {\n                    console.log(\"\\uD83D\\uDCA1 This appears to be a transaction hash - the payment link may still be processing\");\n                    console.log(\"\\uD83D\\uDCA1 Neon operators will eventually process this transaction and create the payment link\");\n                    console.log(\"\\uD83D\\uDCA1 You can bookmark this link and try again in a few minutes\");\n                    // For now, don't throw an error - let the UI handle the empty data gracefully\n                    console.log(\"Returning empty payment link data - transaction may still be processing\");\n                }\n            }\n            return paymentLink;\n        } catch (error) {\n            console.error(\"Contract call error:\", error);\n            throw new Error(\"Payment link not found or contract error\");\n        }\n    }\n    /**\n   * Get user's payment links\n   */ async getUserLinks(userEVMAddress) {\n        // Initialize contract if not already done\n        if (!this.contract) {\n            await this.initReadOnlyContract();\n        }\n        try {\n            return await this.contract.getUserSolanaLinks(userEVMAddress);\n        } catch (error) {\n            console.error(\"Error getting user links:\", error);\n            return [];\n        }\n    }\n    /**\n   * Pay a payment link using Solana Native SDK\n   */ async payLink(linkId, amountSOL) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        console.log(\"Starting payment process...\");\n        console.log(\"Link ID:\", linkId);\n        console.log(\"Amount SOL:\", amountSOL);\n        // First, get the payment link details to find the recipient\n        const linkData = await this.getPaymentLink(linkId);\n        console.log(\"Payment link data:\", linkData);\n        if (!linkData.isActive) {\n            throw new Error(\"Payment link is no longer active\");\n        }\n        // Convert SOL to lamports\n        const amountLamports = Math.floor(amountSOL * 1e9);\n        let transferSignature;\n        try {\n            var _hexString_match, _transactionStatus_, _transactionStatus_1;\n            // Step 1: Perform the actual SOL transfer first\n            console.log(\"Step 1: Performing SOL transfer...\");\n            console.log(\"From:\", this.solanaUser.publicKey.toBase58());\n            console.log(\"To recipient bytes32:\", linkData.solanaCreator);\n            console.log(\"Amount lamports:\", amountLamports);\n            // Convert recipient Solana address from bytes32 to PublicKey\n            // Remove '0x' prefix if present\n            const hexString = linkData.solanaCreator.startsWith(\"0x\") ? linkData.solanaCreator.slice(2) : linkData.solanaCreator;\n            // Convert hex string to byte array\n            const bytes = new Uint8Array(((_hexString_match = hexString.match(/.{2}/g)) === null || _hexString_match === void 0 ? void 0 : _hexString_match.map((byte)=>parseInt(byte, 16))) || []);\n            // For bytes32 from Solana addresses, we need to find the actual 32-byte public key\n            // The bytes32 should contain the 32-byte Solana public key, possibly with leading zeros\n            let recipientPubkey;\n            if (bytes.length === 32) {\n                // Direct conversion from 32 bytes\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(bytes);\n            } else if (bytes.length > 32) {\n                // Take the last 32 bytes if it's longer\n                const last32Bytes = bytes.slice(-32);\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(last32Bytes);\n            } else {\n                // Pad with leading zeros if shorter\n                const paddedBytes = new Uint8Array(32);\n                paddedBytes.set(bytes, 32 - bytes.length);\n                recipientPubkey = new (await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"))).PublicKey(paddedBytes);\n            }\n            console.log(\"Recipient PublicKey:\", recipientPubkey.toBase58());\n            // Create the SOL transfer transaction\n            const { SystemProgram, Transaction } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\"));\n            // Create transfer instruction\n            const transferIx = SystemProgram.transfer({\n                fromPubkey: this.solanaUser.publicKey,\n                toPubkey: recipientPubkey,\n                lamports: amountLamports\n            });\n            // Create transaction\n            const transferTx = new Transaction().add(transferIx);\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for SOL transfer...\");\n            const { blockhash, lastValidBlockHeight: transferBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh SOL transfer blockhash:\", blockhash);\n            console.log(\"Last valid block height:\", transferBlockHeight);\n            transferTx.recentBlockhash = blockhash;\n            transferTx.feePayer = this.solanaUser.publicKey;\n            // Sign and send the SOL transfer immediately\n            console.log(\"Signing and sending SOL transfer with fresh blockhash...\");\n            const signedTransferTx = await this.solanaUser.walletAdapter.signTransaction(transferTx);\n            transferSignature = await this.connection.sendRawTransaction(signedTransferTx.serialize());\n            console.log(\"SOL transfer sent:\", transferSignature);\n            // Wait for transfer confirmation using the modern API\n            await this.connection.confirmTransaction({\n                signature: transferSignature,\n                ...await this.connection.getLatestBlockhash()\n            });\n            console.log(\"SOL transfer confirmed\");\n            // Step 2: Record the payment in the contract\n            console.log(\"Step 2: Recording payment in contract...\");\n            // Convert Solana PublicKey to bytes32\n            const payerSolanaBytes32 = (0,ethers__WEBPACK_IMPORTED_MODULE_6__.zeroPadValue)((0,ethers__WEBPACK_IMPORTED_MODULE_6__.hexlify)(this.solanaUser.publicKey.toBytes()), 32);\n            // Get current nonce\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Current nonce:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"paySolanaLink\", [\n                linkId,\n                amountLamports,\n                payerSolanaBytes32\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for contract call...\");\n            const { blockhash: contractBlockhash, lastValidBlockHeight: contractBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh contract call blockhash:\", contractBlockhash);\n            console.log(\"Last valid block height:\", contractBlockHeight);\n            scheduledTransaction.recentBlockhash = contractBlockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            // Sign with wallet adapter (frontend approach)\n            console.log(\"Signing contract call with fresh blockhash...\");\n            const signedTx = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            // Send transaction immediately\n            console.log(\"Sending contract call transaction immediately...\");\n            await this.connection.sendRawTransaction(signedTx.serialize());\n            // Wait for transaction execution on Neon EVM\n            const transactionStatus = await this.proxyApi.waitTransactionTreeExecution(this.solanaUser.neonWallet, nonce, 60000);\n            if (transactionStatus.length === 0 || transactionStatus[0].status !== \"Success\") {\n                console.warn(\"Contract payment recording failed, but SOL transfer succeeded\");\n                console.log(\"Transfer signature:\", transferSignature);\n            // Don't throw error - the payment went through even if recording failed\n            }\n            console.log(\"Payment completed successfully!\");\n            console.log(\"SOL transfer:\", transferSignature);\n            console.log(\"Contract record:\", (_transactionStatus_ = transactionStatus[0]) === null || _transactionStatus_ === void 0 ? void 0 : _transactionStatus_.transactionHash);\n            return {\n                txHash: ((_transactionStatus_1 = transactionStatus[0]) === null || _transactionStatus_1 === void 0 ? void 0 : _transactionStatus_1.transactionHash) || \"contract-recording-failed\",\n                transferSignature\n            };\n        } catch (error) {\n            console.error(\"Error paying link:\", error);\n            if (transferSignature) {\n                console.log(\"Note: SOL transfer may have succeeded:\", transferSignature);\n            }\n            throw error;\n        }\n    }\n    /**\n   * Deactivate a payment link\n   */ async deactivateLink(linkId) {\n        if (!this.solanaUser || !this.contract) {\n            throw new Error(\"Please connect wallet first\");\n        }\n        try {\n            // Get current nonce\n            const nonce = Number(await this.proxyApi.getTransactionCount(this.solanaUser.neonWallet));\n            console.log(\"Current nonce:\", nonce);\n            // Prepare contract call data\n            const iface = new ethers__WEBPACK_IMPORTED_MODULE_5__.Interface(SOLANA_TIPCARD_ABI);\n            const data = iface.encodeFunctionData(\"deactivateSolanaLink\", [\n                linkId\n            ]);\n            // Create transaction data\n            const transactionData = {\n                from: this.solanaUser.neonWallet,\n                to: CONTRACT_ADDRESS,\n                data: data\n            };\n            // Estimate gas\n            const transactionGas = await this.proxyApi.estimateScheduledTransactionGas({\n                solanaPayer: this.solanaUser.publicKey,\n                transactions: [\n                    transactionData\n                ]\n            });\n            // Create scheduled transaction\n            let { scheduledTransaction } = await this.proxyApi.createScheduledTransaction({\n                transactionGas,\n                transactionData,\n                nonce\n            });\n            // Get fresh recent blockhash right before signing\n            console.log(\"Getting fresh blockhash for deactivate transaction...\");\n            const { blockhash, lastValidBlockHeight: deactivateBlockHeight } = await this.connection.getLatestBlockhash(\"confirmed\");\n            console.log(\"Fresh deactivate blockhash:\", blockhash);\n            console.log(\"Last valid block height:\", deactivateBlockHeight);\n            scheduledTransaction.recentBlockhash = blockhash;\n            scheduledTransaction.feePayer = this.solanaUser.publicKey;\n            // Sign with wallet adapter (frontend approach)\n            console.log(\"Signing deactivate transaction with fresh blockhash...\");\n            const signedTx = await this.solanaUser.walletAdapter.signTransaction(scheduledTransaction);\n            // Send transaction immediately\n            console.log(\"Sending deactivate transaction immediately...\");\n            await this.connection.sendRawTransaction(signedTx.serialize());\n            // Wait for transaction execution\n            const transactionStatus = await this.proxyApi.waitTransactionTreeExecution(this.solanaUser.neonWallet, nonce, 60000);\n            if (transactionStatus.length === 0 || transactionStatus[0].status !== \"Success\") {\n                throw new Error(\"Deactivation transaction failed to execute on Neon EVM\");\n            }\n            return {\n                txHash: transactionStatus[0].transactionHash\n            };\n        } catch (error) {\n            throw error;\n        }\n    }\n    /**\n   * Create a shareable URL for a payment link\n   */ createPaymentURL(linkId) {\n        return \"\".concat(window.location.origin, \"?pay=\").concat(linkId);\n    }\n    /**\n   * Extract link ID from URL\n   */ static extractLinkIdFromURL(url) {\n        try {\n            const urlObj = new URL(url);\n            return urlObj.searchParams.get(\"pay\");\n        } catch (e) {\n            return null;\n        }\n    }\n    /**\n   * Get the user's EVM address derived from Solana public key\n   */ getUserEVMAddress() {\n        var _this_solanaUser;\n        return ((_this_solanaUser = this.solanaUser) === null || _this_solanaUser === void 0 ? void 0 : _this_solanaUser.neonWallet) || null;\n    }\n    constructor(){\n        this.chainId = null;\n        this.contract = null;\n        this.connection = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Connection(SOLANA_RPC_URL, \"confirmed\");\n        this.proxyApi = new _neonevm_solana_sign__WEBPACK_IMPORTED_MODULE_1__.NeonProxyRpcApi(NEON_PROXY_RPC_URL);\n    }\n}\n// Export singleton instance\nconst solanaNativeContract = new SolanaNativeContract();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3NvbGFuYS1uYXRpdmUtY29udHJhY3QudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQWdFO0FBQzBDO0FBQ3BEO0FBQ1Y7QUFFNUMsdUNBQXVDO0FBQ3ZDLE1BQU1PLHFCQUFxQkQsOENBQVdBO0FBRXRDLE1BQU1FLG1CQUFtQkMsNENBQWdELElBQUk7QUFDN0UsTUFBTUcsb0JBQW9CSCw0QkFBb0MsSUFBSTtBQUNsRSxNQUFNSyxxQkFBcUIsR0FBcUIsT0FBbEJGLG1CQUFrQjtBQUNoRCxNQUFNRyxpQkFBaUI7QUFhaEIsTUFBTUM7SUFhWDs7R0FFQyxHQUNELE1BQU1DLHFCQUFxQkMsYUFBa0IsRUFBaUI7UUFDNUQsSUFBSSxDQUFDQSxjQUFjQyxTQUFTLEVBQUU7WUFDNUIsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBRUEsSUFBSTtnQkEyQ3VDO1lBMUN6Q0MsUUFBUUMsR0FBRyxDQUFDO1lBQ1pELFFBQVFDLEdBQUcsQ0FBQyxzQkFBc0JKLGNBQWNDLFNBQVMsQ0FBQ0ksUUFBUTtZQUVsRSx5REFBeUQ7WUFDekQsTUFBTSxFQUNKQyxRQUFRLEVBQ1JDLE9BQU8sRUFDUEMsVUFBVSxFQUNWQyxnQkFBZ0IsRUFDaEJDLGNBQWMsRUFDZixHQUFHLE1BQU0sSUFBSSxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ1osY0FBY0MsU0FBUztZQUVwREUsUUFBUUMsR0FBRyxDQUFDLGVBQWVHO1lBQzNCSixRQUFRQyxHQUFHLENBQUMsdUJBQXVCTSxlQUFlTCxRQUFRO1lBRTFELG1EQUFtRDtZQUNuRCxJQUFJLENBQUNFLE9BQU8sR0FBR0E7WUFDZixJQUFJLENBQUNDLFVBQVUsR0FBRztnQkFDaEIsR0FBR0EsVUFBVTtnQkFDYlIsZUFBZUEsY0FBYyxpQ0FBaUM7WUFDaEU7WUFFQSxnRkFBZ0Y7WUFDaEYsSUFBSSxDQUFDLElBQUksQ0FBQ1EsVUFBVSxDQUFDSyxjQUFjLEVBQUU7Z0JBQ25DLE1BQU0sRUFBRUMs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T0FBWTtZQUNuQixNQUFNQTtRQUNSO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEOEksaUJBQWlCNUQsTUFBYyxFQUFVO1FBQ3ZDLE9BQU8sR0FBaUNBLE9BQTlCNkQsT0FBT0MsUUFBUSxDQUFDQyxNQUFNLEVBQUMsU0FBYyxPQUFQL0Q7SUFDMUM7SUFFQTs7R0FFQyxHQUNELE9BQU9nRSxxQkFBcUJDLEdBQVcsRUFBaUI7UUFDdEQsSUFBSTtZQUNGLE1BQU1DLFNBQVMsSUFBSUMsSUFBSUY7WUFDdkIsT0FBT0MsT0FBT0UsWUFBWSxDQUFDQyxHQUFHLENBQUM7UUFDakMsRUFBRSxVQUFNO1lBQ04sT0FBTztRQUNUO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEQyxvQkFBbUM7WUFDMUI7UUFBUCxPQUFPLHlCQUFJLENBQUNsSyxVQUFVLGNBQWYsd0RBQWlCaUIsVUFBVSxLQUFJO0lBQ3hDO0lBbnNCQWtKLGFBQWM7YUFITnBLLFVBQXlCO2FBQ3pCYyxXQUFtQztRQUd6QyxJQUFJLENBQUMwQyxVQUFVLEdBQUcsSUFBSWpGLHVEQUFVQSxDQUFDZSxnQkFBZ0I7UUFDakQsSUFBSSxDQUFDYyxRQUFRLEdBQUcsSUFBSTVCLGlFQUFlQSxDQUFDYTtJQUN0QztBQWlzQkY7QUFFQSw0QkFBNEI7QUFDckIsTUFBTWdMLHVCQUF1QixJQUFJOUssdUJBQXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3V0aWxzL3NvbGFuYS1uYXRpdmUtY29udHJhY3QudHM/ZDRjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb25uZWN0aW9uLCBQdWJsaWNLZXksIEtleXBhaXIgfSBmcm9tICdAc29sYW5hL3dlYjMuanMnXG5pbXBvcnQgeyBOZW9uUHJveHlScGNBcGksIGNyZWF0ZUJhbGFuY2VBY2NvdW50SW5zdHJ1Y3Rpb24sIFNvbGFuYU5lb25BY2NvdW50IH0gZnJvbSAnQG5lb25ldm0vc29sYW5hLXNpZ24nXG5pbXBvcnQgeyBldGhlcnMsIGhleGxpZnksIHplcm9QYWRWYWx1ZSB9IGZyb20gJ2V0aGVycydcbmltcG9ydCBDb250cmFjdEFCSSBmcm9tICcuL2NvbnRyYWN0QUJJLmpzb24nXG5cbi8vIFVzZSB0aGUgYWN0dWFsIGRlcGxveWVkIGNvbnRyYWN0IEFCSVxuY29uc3QgU09MQU5BX1RJUENBUkRfQUJJID0gQ29udHJhY3RBQklcblxuY29uc3QgQ09OVFJBQ1RfQUREUkVTUyA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1RJUENBUkRfQ09OVFJBQ1RfQUREUkVTUyB8fCAnMHhDRkUwM2M3YzY3NDU2RDA5NEMwMTYyRjkwMzAzOTNGQzJjQ2M0MENiJ1xuY29uc3QgTkVPTl9DT1JFX1JQQ19VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19ORU9OX1JQQ19VUkwgfHwgJ2h0dHBzOi8vZGV2bmV0Lm5lb25ldm0ub3JnJ1xuY29uc3QgTkVPTl9QUk9YWV9SUENfVVJMID0gYCR7TkVPTl9DT1JFX1JQQ19VUkx9L3NvbGBcbmNvbnN0IFNPTEFOQV9SUENfVVJMID0gJ2h0dHBzOi8vYXBpLmRldm5ldC5zb2xhbmEuY29tJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFBheW1lbnRMaW5rIHtcbiAgZXZtQ3JlYXRvcjogc3RyaW5nXG4gIHNvbGFuYUNyZWF0b3I6IHN0cmluZ1xuICBhbW91bnQ6IGJpZ2ludFxuICBpc0ZsZXhpYmxlOiBib29sZWFuXG4gIGlzQWN0aXZlOiBib29sZWFuXG4gIHRvdGFsUmVjZWl2ZWQ6IGJpZ2ludFxuICBwYXltZW50Q291bnQ6IG51bWJlclxuICBkZXNjcmlwdGlvbjogc3RyaW5nXG59XG5cbmV4cG9ydCBjbGFzcyBTb2xhbmFOYXRpdmVDb250cmFjdCB7XG4gIHByaXZhdGUgY29ubmVjdGlvbjogQ29ubmVjdGlvblxuICBwcml2YXRlIHByb3h5QXBpOiBOZW9uUHJveHlScGNBcGlcbiAgcHJpdmF0ZSBzb2xhbmFVc2VyOiBhbnlcbiAgcHJpdmF0ZSBjaGFpbklkOiBudW1iZXIgfCBudWxsID0gbnVsbFxuICBwcml2YXRlIGNvbnRyYWN0OiBldGhlcnMuQ29udHJhY3QgfCBudWxsID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldyBDb25uZWN0aW9uKFNPTEFOQV9SUENfVVJMLCAnY29uZmlybWVkJylcbiAgICB0aGlzLnByb3h5QXBpID0gbmV3IE5lb25Qcm94eVJwY0FwaShORU9OX1BST1hZX1JQQ19VUkwpXG4gIH1cblxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHdpdGggU29sYW5hIHdhbGxldCB1c2luZyB0aGUgcmVjb21tZW5kZWQgU29sYW5hTmVvbkFjY291bnQgYXBwcm9hY2hcbiAgICovXG4gIGFzeW5jIGluaXRXaXRoU29sYW5hV2FsbGV0KHdhbGxldEFkYXB0ZXI6IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghd2FsbGV0QWRhcHRlci5wdWJsaWNLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBjb25uZWN0ZWQnKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+UpyBVc2luZyByZWNvbW1lbmRlZCBTb2xhbmFOZW9uQWNjb3VudCBhcHByb2FjaC4uLicpXG4gICAgICBjb25zb2xlLmxvZygnV2FsbGV0IHB1YmxpYyBrZXk6Jywgd2FsbGV0QWRhcHRlci5wdWJsaWNLZXkudG9CYXNlNTgoKSlcblxuICAgICAgLy8gVXNlIHByb3h5QXBpLmluaXQgd2l0aCBqdXN0IHRoZSBwdWJsaWMga2V5IChsaWtlIGRlbW8pXG4gICAgICBjb25zdCB7XG4gICAgICAgIHByb3ZpZGVyLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgICBzb2xhbmFVc2VyLFxuICAgICAgICB0b2tlbk1pbnRBZGRyZXNzLFxuICAgICAgICBwcm9ncmFtQWRkcmVzc1xuICAgICAgfSA9IGF3YWl0IHRoaXMucHJveHlBcGkuaW5pdCh3YWxsZXRBZGFwdGVyLnB1YmxpY0tleSlcblxuICAgICAgY29uc29sZS5sb2coJy0gQ2hhaW4gSUQ6JywgY2hhaW5JZClcbiAgICAgIGNvbnNvbGUubG9nKCctIE5lb24gRVZNIFByb2dyYW06JywgcHJvZ3JhbUFkZHJlc3MudG9CYXNlNTgoKSlcblxuICAgICAgLy8gU3RvcmUgdGhlIHJlc3VsdCB3aXRoIHdhbGxldCBhZGFwdGVyIGZvciBzaWduaW5nXG4gICAgICB0aGlzLmNoYWluSWQgPSBjaGFpbklkXG4gICAgICB0aGlzLnNvbGFuYVVzZXIgPSB7XG4gICAgICAgIC4uLnNvbGFuYVVzZXIsXG4gICAgICAgIHdhbGxldEFkYXB0ZXI6IHdhbGxldEFkYXB0ZXIgLy8gQWRkIHdhbGxldCBhZGFwdGVyIGZvciBzaWduaW5nXG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBiYWxhbmNlIGFkZHJlc3MgaWYgaXQgZG9lc24ndCBleGlzdCAodXNpbmcgU29sYW5hTmVvbkFjY291bnQgYXBwcm9hY2gpXG4gICAgICBpZiAoIXRoaXMuc29sYW5hVXNlci5iYWxhbmNlQWRkcmVzcykge1xuICAgICAgICBjb25zdCB7IFNvbGFuYU5lb25BY2NvdW50IH0gPSBhd2FpdCBpbXBvcnQoJ0BuZW9uZXZtL3NvbGFuYS1zaWduJylcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IG5ldyBTb2xhbmFOZW9uQWNjb3VudChcbiAgICAgICAgICB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LFxuICAgICAgICAgIHRoaXMuc29sYW5hVXNlci5uZW9uRXZtUHJvZ3JhbSxcbiAgICAgICAgICB0aGlzLnNvbGFuYVVzZXIudG9rZW5NaW50LFxuICAgICAgICAgIHRoaXMuc29sYW5hVXNlci5jaGFpbklkXG4gICAgICAgIClcbiAgICAgICAgdGhpcy5zb2xhbmFVc2VyLmJhbGFuY2VBZGRyZXNzID0gYWNjb3VudC5iYWxhbmNlQWRkcmVzc1xuICAgICAgfVxuXG4gICAgICAvLyBWZXJpZnkgdGhleSBtYXRjaFxuICAgICAgaWYgKHdhbGxldEFkYXB0ZXIucHVibGljS2V5LnRvQmFzZTU4KCkgPT09IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXkudG9CYXNlNTgoKSkge1xuICAgICAgICBjb25zb2xlLmxvZygn4pyFIFdhbGxldCBwdWJsaWMga2V5cyBtYXRjaCBjb3JyZWN0bHkhJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBNSVNNQVRDSDogV2FsbGV0IGFkYXB0ZXIgYW5kIHNvbGFuYSB1c2VyIGhhdmUgZGlmZmVyZW50IHB1YmxpYyBrZXlzIScpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1dhbGxldCBhZGFwdGVyOicsIHdhbGxldEFkYXB0ZXIucHVibGljS2V5LnRvQmFzZTU4KCkpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NvbGFuYSB1c2VyOicsIHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXkudG9CYXNlNTgoKSlcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKCfwn5KwIEZpbmFsIGJhbGFuY2UgYWRkcmVzczonLCB0aGlzLnNvbGFuYVVzZXIuYmFsYW5jZUFkZHJlc3M/LnRvQmFzZTU4KCkgfHwgJ1N0aWxsIG5vdCBhdmFpbGFibGUnKVxuXG4gICAgICAvLyBDcmVhdGUgY29udHJhY3QgaW5zdGFuY2VcbiAgICAgIGNvbnN0IHJlYWRPbmx5UHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihORU9OX0NPUkVfUlBDX1VSTClcbiAgICAgIHRoaXMuY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KENPTlRSQUNUX0FERFJFU1MsIFNPTEFOQV9USVBDQVJEX0FCSSwgcmVhZE9ubHlQcm92aWRlcilcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBFVk0gYWRkcmVzcyBoYXMgYmVlbiB1c2VkIGJlZm9yZSAoaGFzIHRyYW5zYWN0aW9uIGhpc3RvcnkpXG4gICAgICAgIGNvbnN0IHR4Q291bnQgPSBhd2FpdCByZWFkT25seVByb3ZpZGVyLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQpXG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OKIEVWTSBhZGRyZXNzIHRyYW5zYWN0aW9uIGNvdW50OicsIHR4Q291bnQpXG5cbiAgICAgICAgaWYgKHR4Q291bnQgPiAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ+KchSBUaGlzIEVWTSBhZGRyZXNzIGhhcyB0cmFuc2FjdGlvbiBoaXN0b3J5IC0gaXQgZXhpc3RzIG9uLWNoYWluIScpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ+KEue+4jyBUaGlzIEVWTSBhZGRyZXNzIGlzIG5ldyAobm8gdHJhbnNhY3Rpb24gaGlzdG9yeSB5ZXQpJylcbiAgICAgICAgICBjb25zb2xlLmxvZygn4oS577iPIFRoZSBhZGRyZXNzIHdpbGwgYmUgcmVnaXN0ZXJlZCBvbi1jaGFpbiB3aGVuIGZpcnN0IHRyYW5zYWN0aW9uIGlzIG1hZGUnKVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoICh2ZXJpZnlFcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZygn4pqg77iPIENvdWxkIG5vdCB2ZXJpZnkgRVZNIGFkZHJlc3M6JywgdmVyaWZ5RXJyb3IpXG4gICAgICB9XG5cbiAgICAgIC8vIFZlcmlmeSBjb250cmFjdCBpcyBkZXBsb3llZCBhdCB0aGlzIGFkZHJlc3NcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCByZWFkT25seVByb3ZpZGVyLmdldENvZGUoQ09OVFJBQ1RfQUREUkVTUylcbiAgICAgICAgaWYgKGNvZGUgPT09ICcweCcpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBObyBjb250cmFjdCBjb2RlIGZvdW5kIGF0IGFkZHJlc3M6JywgQ09OVFJBQ1RfQUREUkVTUylcbiAgICAgICAgICBjb25zb2xlLmxvZygnVGhpcyBtaWdodCBtZWFuIHRoZSBjb250cmFjdCBpcyBub3QgZGVwbG95ZWQgb3IgYWRkcmVzcyBpcyBpbmNvcnJlY3QnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfinIUgQ29udHJhY3QgZm91bmQgYXQgYWRkcmVzcycpXG5cbiAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIENvbnRyYWN0IGZvdW5kIGFuZCByZWFkeSBmb3IgdHJhbnNhY3Rpb25zJylcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAodmVyaWZ5RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gdmVyaWZ5IGNvbnRyYWN0OicsIHZlcmlmeUVycm9yKVxuICAgICAgfVxuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIFNvbGFuYSBOYXRpdmUgU0RLOicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgcGF5bWVudCBsaW5rIHVzaW5nIFNvbGFuYSBOYXRpdmUgU0RLIHdpdGggcHJvcGVyIG5vbmNlIG1hbmFnZW1lbnRcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVBheW1lbnRMaW5rKFxuICAgIHN1Z2dlc3RlZEFtb3VudFNPTDogbnVtYmVyLFxuICAgIGlzRmxleGlibGU6IGJvb2xlYW4sXG4gICAgZGVzY3JpcHRpb246IHN0cmluZ1xuICApOiBQcm9taXNlPHsgbGlua0lkOiBzdHJpbmc7IHR4SGFzaDogc3RyaW5nIH0+IHtcbiAgICBpZiAoIXRoaXMuc29sYW5hVXNlciB8fCAhdGhpcy5jb250cmFjdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgY29ubmVjdCB3YWxsZXQgZmlyc3QnKVxuICAgIH1cblxuICAgIC8vIENvbnZlcnQgU09MIHRvIGxhbXBvcnRzICgxIFNPTCA9IDFlOSBsYW1wb3J0cylcbiAgICBjb25zdCBhbW91bnRMYW1wb3J0cyA9IE1hdGguZmxvb3Ioc3VnZ2VzdGVkQW1vdW50U09MICogMWU5KVxuICAgIGxldCBzaWduYXR1cmU6IHN0cmluZyA9ICcnXG5cbiAgICB0cnkge1xuICAgICAgLy8g8J+UpyBFTkhBTkNFRCBOT05DRSBNQU5BR0VNRU5UXG4gICAgICBjb25zb2xlLmxvZygn8J+UpyBHZXR0aW5nIGN1cnJlbnQgbm9uY2Ugd2l0aCByZXRyeSBsb2dpYy4uLicpXG5cbiAgICAgIGxldCBub25jZTogbnVtYmVyXG4gICAgICBsZXQgcmV0cnlDb3VudCA9IDBcbiAgICAgIGNvbnN0IG1heFJldHJpZXMgPSAzXG5cbiAgICAgIHdoaWxlIChyZXRyeUNvdW50IDwgbWF4UmV0cmllcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCB0cmFuc2FjdGlvbiBjb3VudCAobm9uY2UpXG4gICAgICAgICAgbm9uY2UgPSBOdW1iZXIoYXdhaXQgdGhpcy5wcm94eUFwaS5nZXRUcmFuc2FjdGlvbkNvdW50KHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0KSlcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQXR0ZW1wdCAke3JldHJ5Q291bnQgKyAxfTogQ3VycmVudCBub25jZTogJHtub25jZX1gKVxuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIHBlbmRpbmcgdHJhbnNhY3Rpb25zIHdpdGggdGhpcyBub25jZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwZW5kaW5nVHggPSBhd2FpdCB0aGlzLnByb3h5QXBpLmdldFRyYW5zYWN0aW9uQnlTZW5kZXJOb25jZShcbiAgICAgICAgICAgICAgdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsXG4gICAgICAgICAgICAgIG5vbmNlXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIGlmIChwZW5kaW5nVHgpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBGb3VuZCBleGlzdGluZyB0cmFuc2FjdGlvbiB3aXRoIG5vbmNlICR7bm9uY2V9LCBpbmNyZW1lbnRpbmcuLi5gKVxuICAgICAgICAgICAgICBub25jZSA9IG5vbmNlICsgMVxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TiCBVc2luZyBpbmNyZW1lbnRlZCBub25jZTogJHtub25jZX1gKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKHBlbmRpbmdFcnJvcikge1xuICAgICAgICAgICAgLy8gTm8gcGVuZGluZyB0cmFuc2FjdGlvbiBmb3VuZCwgbm9uY2UgaXMgc2FmZSB0byB1c2VcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgTm9uY2UgJHtub25jZX0gaXMgYXZhaWxhYmxlYClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhayAvLyBTdWNjZXNzLCBleGl0IHJldHJ5IGxvb3BcblxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJldHJ5Q291bnQrK1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDinYwgTm9uY2UgZmV0Y2ggYXR0ZW1wdCAke3JldHJ5Q291bnR9IGZhaWxlZDpgLCBlcnJvci5tZXNzYWdlKVxuXG4gICAgICAgICAgaWYgKHJldHJ5Q291bnQgPj0gbWF4UmV0cmllcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2V0IHZhbGlkIG5vbmNlIGFmdGVyICR7bWF4UmV0cmllc30gYXR0ZW1wdHNgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFdhaXQgYmVmb3JlIHJldHJ5XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKGDwn46vIEZpbmFsIG5vbmNlIHRvIHVzZTogJHtub25jZX1gKVxuXG4gICAgICAvLyBQcmVwYXJlIGNvbnRyYWN0IGNhbGwgZGF0YVxuICAgICAgY29uc3QgaWZhY2UgPSBuZXcgZXRoZXJzLkludGVyZmFjZShTT0xBTkFfVElQQ0FSRF9BQkkpXG4gICAgICBjb25zdCBkYXRhID0gaWZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKCdjcmVhdGVTb2xhbmFQYXltZW50TGluaycsIFtcbiAgICAgICAgYW1vdW50TGFtcG9ydHMsXG4gICAgICAgIGlzRmxleGlibGUsXG4gICAgICAgIGRlc2NyaXB0aW9uXG4gICAgICBdKVxuXG4gICAgICAvLyBDcmVhdGUgdHJhbnNhY3Rpb24gZGF0YVxuICAgICAgY29uc3QgdHJhbnNhY3Rpb25EYXRhID0ge1xuICAgICAgICBmcm9tOiB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCxcbiAgICAgICAgdG86IENPTlRSQUNUX0FERFJFU1MsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ/CflKcgRXN0aW1hdGluZyBnYXMuLi4nKVxuXG4gICAgICAvLyBFc3RpbWF0ZSBnYXMgd2l0aCByZXRyeSBsb2dpY1xuICAgICAgbGV0IHRyYW5zYWN0aW9uR2FzXG4gICAgICByZXRyeUNvdW50ID0gMFxuXG4gICAgICB3aGlsZSAocmV0cnlDb3VudCA8IG1heFJldHJpZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0cmFuc2FjdGlvbkdhcyA9IGF3YWl0IHRoaXMucHJveHlBcGkuZXN0aW1hdGVTY2hlZHVsZWRUcmFuc2FjdGlvbkdhcyh7XG4gICAgICAgICAgICBzb2xhbmFQYXllcjogdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uczogW3RyYW5zYWN0aW9uRGF0YV0sXG4gICAgICAgICAgfSlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGNhdGNoIChnYXNFcnJvcikge1xuICAgICAgICAgIHJldHJ5Q291bnQrK1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBHYXMgZXN0aW1hdGlvbiBhdHRlbXB0ICR7cmV0cnlDb3VudH0gZmFpbGVkOmAsIGdhc0Vycm9yLm1lc3NhZ2UpXG5cbiAgICAgICAgICBpZiAocmV0cnlDb3VudCA+PSBtYXhSZXRyaWVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdhcyBlc3RpbWF0aW9uIGZhaWxlZCBhZnRlciAke21heFJldHJpZXN9IGF0dGVtcHRzOiAke2dhc0Vycm9yLm1lc3NhZ2V9YClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ/Cfk50gQ3JlYXRpbmcgc2NoZWR1bGVkIHRyYW5zYWN0aW9uLi4uJylcblxuICAgICAgLy8gQ3JlYXRlIHNjaGVkdWxlZCB0cmFuc2FjdGlvbiB3aXRoIHRoZSBjb25maXJtZWQgbm9uY2VcbiAgICAgIGxldCB7IHNjaGVkdWxlZFRyYW5zYWN0aW9uIH0gPSBhd2FpdCB0aGlzLnByb3h5QXBpLmNyZWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgdHJhbnNhY3Rpb25HYXMsXG4gICAgICAgIHRyYW5zYWN0aW9uRGF0YSxcbiAgICAgICAgbm9uY2UgLy8gVXNlIHRoZSB2YWxpZGF0ZWQgbm9uY2VcbiAgICAgIH0pXG5cbiAgICAgIC8vIENoZWNrIGlmIGJhbGFuY2UgYWNjb3VudCBleGlzdHMsIGlmIG5vdCBjcmVhdGUgaXRcbiAgICAgIGNvbnNvbGUubG9nKCfwn5KwIENoZWNraW5nIGJhbGFuY2UgYWNjb3VudC4uLicpXG4gICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldEFjY291bnRJbmZvKHRoaXMuc29sYW5hVXNlci5iYWxhbmNlQWRkcmVzcylcbiAgICAgIGlmIChhY2NvdW50ID09PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OdIEFkZGluZyBiYWxhbmNlIGFjY291bnQgaW5zdHJ1Y3Rpb24uLi4nKVxuICAgICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5pbnN0cnVjdGlvbnMudW5zaGlmdChcbiAgICAgICAgICBjcmVhdGVCYWxhbmNlQWNjb3VudEluc3RydWN0aW9uKFxuICAgICAgICAgICAgdGhpcy5zb2xhbmFVc2VyLm5lb25Fdm1Qcm9ncmFtLFxuICAgICAgICAgICAgdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleSxcbiAgICAgICAgICAgIHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0LFxuICAgICAgICAgICAgdGhpcy5jaGFpbklkIVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyDwn5SnIEVOSEFOQ0VEIFRSQU5TQUNUSU9OIFNJR05JTkdcbiAgICAgIGNvbnNvbGUubG9nKCfinI3vuI8gUHJlcGFyaW5nIHRyYW5zYWN0aW9uIGZvciBzaWduaW5nLi4uJylcblxuICAgICAgLy8gR2V0IGZyZXNoIGJsb2NraGFzaFxuICAgICAgY29uc3QgeyBibG9ja2hhc2ggfSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goJ2ZpbmFsaXplZCcpXG4gICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBibG9ja2hhc2hcbiAgICAgIHNjaGVkdWxlZFRyYW5zYWN0aW9uLmZlZVBheWVyID0gdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleVxuXG4gICAgICBjb25zb2xlLmxvZygn8J+UjyBSZXF1ZXN0aW5nIHdhbGxldCBzaWduYXR1cmUuLi4nKVxuICAgICAgY29uc29sZS5sb2coYCAgIFRyYW5zYWN0aW9uIG5vbmNlOiAke25vbmNlfWApXG4gICAgICBjb25zb2xlLmxvZyhgICAgRmVlIHBheWVyOiAke3RoaXMuc29sYW5hVXNlci5wdWJsaWNLZXkudG9CYXNlNTgoKX1gKVxuICAgICAgY29uc29sZS5sb2coYCAgIEluc3RydWN0aW9ucyBjb3VudDogJHtzY2hlZHVsZWRUcmFuc2FjdGlvbi5pbnN0cnVjdGlvbnMubGVuZ3RofWApXG5cbiAgICAgIC8vIFNpZ24gdHJhbnNhY3Rpb25cbiAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5zb2xhbmFVc2VyLndhbGxldEFkYXB0ZXIuc2lnblRyYW5zYWN0aW9uKHNjaGVkdWxlZFRyYW5zYWN0aW9uKVxuXG4gICAgICBjb25zb2xlLmxvZygn8J+ToSBTdWJtaXR0aW5nIHRyYW5zYWN0aW9uLi4uJylcbiAgICAgIHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24uc2VyaWFsaXplKCksIHtcbiAgICAgICAgc2tpcFByZWZsaWdodDogZmFsc2UsIC8vIEVuYWJsZSBwcmVmbGlnaHQgdG8gY2F0Y2ggZXJyb3JzIGVhcmx5XG4gICAgICAgIHByZWZsaWdodENvbW1pdG1lbnQ6ICdjb25maXJtZWQnXG4gICAgICB9KVxuXG4gICAgICBjb25zb2xlLmxvZygn8J+UlyBUcmFuc2FjdGlvbiBzdWJtaXR0ZWQgc3VjY2Vzc2Z1bGx5IScpXG4gICAgICBjb25zb2xlLmxvZyhgICAgU2lnbmF0dXJlOiAke3NpZ25hdHVyZX1gKVxuICAgICAgY29uc29sZS5sb2coYCAgIE5vbmNlIHVzZWQ6ICR7bm9uY2V9YClcblxuICAgICAgLy8gRW5oYW5jZWQgY29uZmlybWF0aW9uIHdhaXRpbmdcbiAgICAgIGNvbnNvbGUubG9nKGDij7MgV2FpdGluZyBmb3IgdHJhbnNhY3Rpb24gY29uZmlybWF0aW9uLi4uYClcblxuICAgICAgbGV0IGNvbmZpcm1lZCA9IGZhbHNlXG4gICAgICBsZXQgY29uZmlybVJldHJpZXMgPSAwXG4gICAgICBjb25zdCBtYXhDb25maXJtUmV0cmllcyA9IDEwXG5cbiAgICAgIHdoaWxlICghY29uZmlybWVkICYmIGNvbmZpcm1SZXRyaWVzIDwgbWF4Q29uZmlybVJldHJpZXMpIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMDApKVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgY29uZmlybWF0aW9uID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldFNpZ25hdHVyZVN0YXR1cyhzaWduYXR1cmUpXG4gICAgICAgICAgaWYgKGNvbmZpcm1hdGlvbi52YWx1ZT8uY29uZmlybWF0aW9uU3RhdHVzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiBUcmFuc2FjdGlvbiBzdGF0dXM6ICR7Y29uZmlybWF0aW9uLnZhbHVlLmNvbmZpcm1hdGlvblN0YXR1c31gKVxuXG4gICAgICAgICAgICBpZiAoY29uZmlybWF0aW9uLnZhbHVlLmNvbmZpcm1hdGlvblN0YXR1cyA9PT0gJ2NvbmZpcm1lZCcgfHxcbiAgICAgICAgICAgICAgY29uZmlybWF0aW9uLnZhbHVlLmNvbmZpcm1hdGlvblN0YXR1cyA9PT0gJ2ZpbmFsaXplZCcpIHtcbiAgICAgICAgICAgICAgY29uZmlybWVkID0gdHJ1ZVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoY29uZmlybUVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBDb25maXJtYXRpb24gY2hlY2sgJHtjb25maXJtUmV0cmllcyArIDF9IGZhaWxlZDogJHtjb25maXJtRXJyb3IubWVzc2FnZX1gKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlybVJldHJpZXMrK1xuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlybWVkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgVHJhbnNhY3Rpb24gY29uZmlybWVkIScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygn4pqg77iPIFRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvbiB0aW1lb3V0LCBidXQgdHJhbnNhY3Rpb24gbWF5IHN0aWxsIHN1Y2NlZWQnKVxuICAgICAgfVxuXG4gICAgICAvLyBXYWl0IGEgYml0IG1vcmUgZm9yIE5lb24gRVZNIHByb2Nlc3NpbmdcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SEIFdhaXRpbmcgZm9yIE5lb24gRVZNIHByb2Nlc3NpbmcuLi5gKVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMDApKVxuXG4gICAgICAvLyBHZXQgTmVvbiBFVk0gdHJhbnNhY3Rpb24gZGV0YWlsc1xuICAgICAgY29uc29sZS5sb2coYPCflI0gR2V0dGluZyBOZW9uIEVWTSB0cmFuc2FjdGlvbiBkZXRhaWxzLi4uYClcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbmVvblR4UmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9kZXZuZXQubmVvbmV2bS5vcmcvc29sJywge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJuZW9uX2dldFRyYW5zYWN0aW9uQnlTZW5kZXJOb25jZVwiLFxuICAgICAgICAgICAgcGFyYW1zOiBbdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsIG5vbmNlXSwgLy8gVXNlIHRoZSBFVk0gYWRkcmVzcyBhbmQgY29uZmlybWVkIG5vbmNlXG4gICAgICAgICAgICBpZDogMSxcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IG5lb25UeFJlc3VsdCA9IGF3YWl0IG5lb25UeFJlc3BvbnNlLmpzb24oKVxuICAgICAgICBjb25zb2xlLmxvZyhcIvCfk4sgTmVvbiBFVk0gdHJhbnNhY3Rpb24gcmVzdWx0OlwiLCBuZW9uVHhSZXN1bHQpXG5cbiAgICAgICAgaWYgKG5lb25UeFJlc3VsdC5yZXN1bHQgJiYgbmVvblR4UmVzdWx0LnJlc3VsdC5oYXNoKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKchSBOZW9uIEVWTSB0cmFuc2FjdGlvbiBoYXNoOiAke25lb25UeFJlc3VsdC5yZXN1bHQuaGFzaH1gKVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpbmtJZDogbmVvblR4UmVzdWx0LnJlc3VsdC5oYXNoLFxuICAgICAgICAgICAgdHhIYXNoOiBuZW9uVHhSZXN1bHQucmVzdWx0Lmhhc2hcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKEue+4jyBOZW9uIEVWTSB0cmFuc2FjdGlvbiBub3QgZm91bmQgeWV0LCB1c2luZyBTb2xhbmEgc2lnbmF0dXJlYClcbiAgICAgICAgfVxuXG4gICAgICB9IGNhdGNoIChuZW9uRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBDb3VsZCBub3QgZ2V0IE5lb24gRVZNIHRyYW5zYWN0aW9uIGRldGFpbHM6ICR7bmVvbkVycm9yLm1lc3NhZ2V9YClcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIFNvbGFuYSBzaWduYXR1cmUgYXMgZmFsbGJhY2tcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmtJZDogc2lnbmF0dXJlLFxuICAgICAgICB0eEhhc2g6IHNpZ25hdHVyZVxuICAgICAgfVxuXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGNyZWF0aW5nIHBheW1lbnQgbGluazonLCBlcnJvcilcblxuICAgICAgLy8gRW5oYW5jZWQgZXJyb3IgaGFuZGxpbmdcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnVHJhbnNhY3Rpb24gVHJlZSAtIHRyYW5zYWN0aW9uIHdpdGggdGhlIHNhbWUgbm9uY2UgYWxyZWFkeSBleGlzdHMnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbmNlIGNvbmZsaWN0OiBBIHRyYW5zYWN0aW9uIHdpdGggdGhpcyBub25jZSBpcyBhbHJlYWR5IHBlbmRpbmcuIFBsZWFzZSB0cnkgYWdhaW4gaW4gYSBmZXcgc2Vjb25kcy5gKVxuICAgICAgfSBlbHNlIGlmIChlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnaW5zdWZmaWNpZW50IGZ1bmRzJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN1ZmZpY2llbnQgU09MIGJhbGFuY2UgZm9yIHRyYW5zYWN0aW9uIGZlZXMuIFBsZWFzZSBhZGQgbW9yZSBTT0wgdG8geW91ciB3YWxsZXQuYClcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ1VzZXIgcmVqZWN0ZWQnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIHdhcyByZWplY3RlZCBieSB0aGUgdXNlci5gKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSByZWFkLW9ubHkgY29udHJhY3QgYWNjZXNzICh3aXRob3V0IHdhbGxldClcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW5pdFJlYWRPbmx5Q29udHJhY3QoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLmNvbnRyYWN0KSB7XG4gICAgICAvLyBDcmVhdGUgYSBzaW1wbGUgSlNPTiBSUEMgcHJvdmlkZXIgZm9yIHJlYWQgb3BlcmF0aW9uc1xuICAgICAgY29uc3QgcmVhZE9ubHlQcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKE5FT05fQ09SRV9SUENfVVJMKVxuICAgICAgdGhpcy5jb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoQ09OVFJBQ1RfQUREUkVTUywgU09MQU5BX1RJUENBUkRfQUJJLCByZWFkT25seVByb3ZpZGVyKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcGF5bWVudCBsaW5rIGRldGFpbHNcbiAgICovXG4gIGFzeW5jIGdldFBheW1lbnRMaW5rKGxpbmtJZDogc3RyaW5nKTogUHJvbWlzZTxQYXltZW50TGluaz4ge1xuICAgIC8vIEluaXRpYWxpemUgY29udHJhY3QgaWYgbm90IGFscmVhZHkgZG9uZVxuICAgIGlmICghdGhpcy5jb250cmFjdCkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0UmVhZE9ubHlDb250cmFjdCgpXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ0dldHRpbmcgcGF5bWVudCBsaW5rIHdpdGggSUQ6JywgbGlua0lkKVxuICAgIGNvbnNvbGUubG9nKCdDb250cmFjdCBhZGRyZXNzOicsIENPTlRSQUNUX0FERFJFU1MpXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jb250cmFjdCEuZ2V0U29sYW5hUGF5bWVudExpbmsobGlua0lkKVxuICAgICAgY29uc29sZS5sb2coJ1JhdyBjb250cmFjdCByZXN1bHQ6JywgcmVzdWx0KVxuXG4gICAgICBjb25zdCBwYXltZW50TGluayA9IHtcbiAgICAgICAgZXZtQ3JlYXRvcjogcmVzdWx0LmV2bUNyZWF0b3IsXG4gICAgICAgIHNvbGFuYUNyZWF0b3I6IHJlc3VsdC5zb2xhbmFDcmVhdG9yLFxuICAgICAgICBhbW91bnQ6IHJlc3VsdC5hbW91bnQsXG4gICAgICAgIGlzRmxleGlibGU6IHJlc3VsdC5pc0ZsZXhpYmxlLFxuICAgICAgICBpc0FjdGl2ZTogcmVzdWx0LmlzQWN0aXZlLFxuICAgICAgICB0b3RhbFJlY2VpdmVkOiByZXN1bHQudG90YWxSZWNlaXZlZCxcbiAgICAgICAgcGF5bWVudENvdW50OiBOdW1iZXIocmVzdWx0LnBheW1lbnRDb3VudCksXG4gICAgICAgIGRlc2NyaXB0aW9uOiByZXN1bHQuZGVzY3JpcHRpb25cbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBsb29rcyBsaWtlIGFuIGVtcHR5L25vbi1leGlzdGVudCBsaW5rICh0cmFuc2FjdGlvbiBub3QgcHJvY2Vzc2VkIHlldClcbiAgICAgIGlmIChyZXN1bHQuZXZtQ3JlYXRvciA9PT0gJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcgJiZcbiAgICAgICAgcmVzdWx0LmFtb3VudCA9PT0gQmlnSW50KDApICYmXG4gICAgICAgICFyZXN1bHQuaXNBY3RpdmUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdQYXltZW50IGxpbmsgYXBwZWFycyB0byBiZSBlbXB0eS9ub24tZXhpc3RlbnQnKVxuXG4gICAgICAgIC8vIElmIHRoaXMgbG9va3MgbGlrZSBhIHRyYW5zYWN0aW9uIGhhc2ggKDY2IGNoYXJzLCBzdGFydHMgd2l0aCAweCksIHByb3ZpZGUgaGVscGZ1bCBpbmZvXG4gICAgICAgIGlmIChsaW5rSWQubGVuZ3RoID09PSA2NiAmJiBsaW5rSWQuc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5KhIFRoaXMgYXBwZWFycyB0byBiZSBhIHRyYW5zYWN0aW9uIGhhc2ggLSB0aGUgcGF5bWVudCBsaW5rIG1heSBzdGlsbCBiZSBwcm9jZXNzaW5nJylcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+SoSBOZW9uIG9wZXJhdG9ycyB3aWxsIGV2ZW50dWFsbHkgcHJvY2VzcyB0aGlzIHRyYW5zYWN0aW9uIGFuZCBjcmVhdGUgdGhlIHBheW1lbnQgbGluaycpXG4gICAgICAgICAgY29uc29sZS5sb2coJ/CfkqEgWW91IGNhbiBib29rbWFyayB0aGlzIGxpbmsgYW5kIHRyeSBhZ2FpbiBpbiBhIGZldyBtaW51dGVzJylcblxuICAgICAgICAgIC8vIEZvciBub3csIGRvbid0IHRocm93IGFuIGVycm9yIC0gbGV0IHRoZSBVSSBoYW5kbGUgdGhlIGVtcHR5IGRhdGEgZ3JhY2VmdWxseVxuICAgICAgICAgIGNvbnNvbGUubG9nKCdSZXR1cm5pbmcgZW1wdHkgcGF5bWVudCBsaW5rIGRhdGEgLSB0cmFuc2FjdGlvbiBtYXkgc3RpbGwgYmUgcHJvY2Vzc2luZycpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBheW1lbnRMaW5rXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0NvbnRyYWN0IGNhbGwgZXJyb3I6JywgZXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BheW1lbnQgbGluayBub3QgZm91bmQgb3IgY29udHJhY3QgZXJyb3InKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdXNlcidzIHBheW1lbnQgbGlua3NcbiAgICovXG4gIGFzeW5jIGdldFVzZXJMaW5rcyh1c2VyRVZNQWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIC8vIEluaXRpYWxpemUgY29udHJhY3QgaWYgbm90IGFscmVhZHkgZG9uZVxuICAgIGlmICghdGhpcy5jb250cmFjdCkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0UmVhZE9ubHlDb250cmFjdCgpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbnRyYWN0IS5nZXRVc2VyU29sYW5hTGlua3ModXNlckVWTUFkZHJlc3MpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdXNlciBsaW5rczonLCBlcnJvcilcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXkgYSBwYXltZW50IGxpbmsgdXNpbmcgU29sYW5hIE5hdGl2ZSBTREtcbiAgICovXG4gIGFzeW5jIHBheUxpbmsoXG4gICAgbGlua0lkOiBzdHJpbmcsXG4gICAgYW1vdW50U09MOiBudW1iZXJcbiAgKTogUHJvbWlzZTx7IHR4SGFzaDogc3RyaW5nOyB0cmFuc2ZlclNpZ25hdHVyZT86IHN0cmluZyB9PiB7XG4gICAgaWYgKCF0aGlzLnNvbGFuYVVzZXIgfHwgIXRoaXMuY29udHJhY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIGNvbm5lY3Qgd2FsbGV0IGZpcnN0JylcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgcGF5bWVudCBwcm9jZXNzLi4uJylcbiAgICBjb25zb2xlLmxvZygnTGluayBJRDonLCBsaW5rSWQpXG4gICAgY29uc29sZS5sb2coJ0Ftb3VudCBTT0w6JywgYW1vdW50U09MKVxuXG4gICAgLy8gRmlyc3QsIGdldCB0aGUgcGF5bWVudCBsaW5rIGRldGFpbHMgdG8gZmluZCB0aGUgcmVjaXBpZW50XG4gICAgY29uc3QgbGlua0RhdGEgPSBhd2FpdCB0aGlzLmdldFBheW1lbnRMaW5rKGxpbmtJZClcbiAgICBjb25zb2xlLmxvZygnUGF5bWVudCBsaW5rIGRhdGE6JywgbGlua0RhdGEpXG5cbiAgICBpZiAoIWxpbmtEYXRhLmlzQWN0aXZlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BheW1lbnQgbGluayBpcyBubyBsb25nZXIgYWN0aXZlJylcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IFNPTCB0byBsYW1wb3J0c1xuICAgIGNvbnN0IGFtb3VudExhbXBvcnRzID0gTWF0aC5mbG9vcihhbW91bnRTT0wgKiAxZTkpXG5cbiAgICBsZXQgdHJhbnNmZXJTaWduYXR1cmU6IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFN0ZXAgMTogUGVyZm9ybSB0aGUgYWN0dWFsIFNPTCB0cmFuc2ZlciBmaXJzdFxuICAgICAgY29uc29sZS5sb2coJ1N0ZXAgMTogUGVyZm9ybWluZyBTT0wgdHJhbnNmZXIuLi4nKVxuICAgICAgY29uc29sZS5sb2coJ0Zyb206JywgdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleS50b0Jhc2U1OCgpKVxuICAgICAgY29uc29sZS5sb2coJ1RvIHJlY2lwaWVudCBieXRlczMyOicsIGxpbmtEYXRhLnNvbGFuYUNyZWF0b3IpXG4gICAgICBjb25zb2xlLmxvZygnQW1vdW50IGxhbXBvcnRzOicsIGFtb3VudExhbXBvcnRzKVxuXG4gICAgICAvLyBDb252ZXJ0IHJlY2lwaWVudCBTb2xhbmEgYWRkcmVzcyBmcm9tIGJ5dGVzMzIgdG8gUHVibGljS2V5XG4gICAgICAvLyBSZW1vdmUgJzB4JyBwcmVmaXggaWYgcHJlc2VudFxuICAgICAgY29uc3QgaGV4U3RyaW5nID0gbGlua0RhdGEuc29sYW5hQ3JlYXRvci5zdGFydHNXaXRoKCcweCcpXG4gICAgICAgID8gbGlua0RhdGEuc29sYW5hQ3JlYXRvci5zbGljZSgyKVxuICAgICAgICA6IGxpbmtEYXRhLnNvbGFuYUNyZWF0b3JcblxuICAgICAgLy8gQ29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbiAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoaGV4U3RyaW5nLm1hdGNoKC8uezJ9L2cpPy5tYXAoYnl0ZSA9PiBwYXJzZUludChieXRlLCAxNikpIHx8IFtdKVxuXG4gICAgICAvLyBGb3IgYnl0ZXMzMiBmcm9tIFNvbGFuYSBhZGRyZXNzZXMsIHdlIG5lZWQgdG8gZmluZCB0aGUgYWN0dWFsIDMyLWJ5dGUgcHVibGljIGtleVxuICAgICAgLy8gVGhlIGJ5dGVzMzIgc2hvdWxkIGNvbnRhaW4gdGhlIDMyLWJ5dGUgU29sYW5hIHB1YmxpYyBrZXksIHBvc3NpYmx5IHdpdGggbGVhZGluZyB6ZXJvc1xuICAgICAgbGV0IHJlY2lwaWVudFB1YmtleVxuXG4gICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAzMikge1xuICAgICAgICAvLyBEaXJlY3QgY29udmVyc2lvbiBmcm9tIDMyIGJ5dGVzXG4gICAgICAgIHJlY2lwaWVudFB1YmtleSA9IG5ldyAoYXdhaXQgaW1wb3J0KCdAc29sYW5hL3dlYjMuanMnKSkuUHVibGljS2V5KGJ5dGVzKVxuICAgICAgfSBlbHNlIGlmIChieXRlcy5sZW5ndGggPiAzMikge1xuICAgICAgICAvLyBUYWtlIHRoZSBsYXN0IDMyIGJ5dGVzIGlmIGl0J3MgbG9uZ2VyXG4gICAgICAgIGNvbnN0IGxhc3QzMkJ5dGVzID0gYnl0ZXMuc2xpY2UoLTMyKVxuICAgICAgICByZWNpcGllbnRQdWJrZXkgPSBuZXcgKGF3YWl0IGltcG9ydCgnQHNvbGFuYS93ZWIzLmpzJykpLlB1YmxpY0tleShsYXN0MzJCeXRlcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFBhZCB3aXRoIGxlYWRpbmcgemVyb3MgaWYgc2hvcnRlclxuICAgICAgICBjb25zdCBwYWRkZWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KDMyKVxuICAgICAgICBwYWRkZWRCeXRlcy5zZXQoYnl0ZXMsIDMyIC0gYnl0ZXMubGVuZ3RoKVxuICAgICAgICByZWNpcGllbnRQdWJrZXkgPSBuZXcgKGF3YWl0IGltcG9ydCgnQHNvbGFuYS93ZWIzLmpzJykpLlB1YmxpY0tleShwYWRkZWRCeXRlcylcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ1JlY2lwaWVudCBQdWJsaWNLZXk6JywgcmVjaXBpZW50UHVia2V5LnRvQmFzZTU4KCkpXG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgU09MIHRyYW5zZmVyIHRyYW5zYWN0aW9uXG4gICAgICBjb25zdCB7IFN5c3RlbVByb2dyYW0sIFRyYW5zYWN0aW9uIH0gPSBhd2FpdCBpbXBvcnQoJ0Bzb2xhbmEvd2ViMy5qcycpXG5cbiAgICAgIC8vIENyZWF0ZSB0cmFuc2ZlciBpbnN0cnVjdGlvblxuICAgICAgY29uc3QgdHJhbnNmZXJJeCA9IFN5c3RlbVByb2dyYW0udHJhbnNmZXIoe1xuICAgICAgICBmcm9tUHVia2V5OiB0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LFxuICAgICAgICB0b1B1YmtleTogcmVjaXBpZW50UHVia2V5LFxuICAgICAgICBsYW1wb3J0czogYW1vdW50TGFtcG9ydHNcbiAgICAgIH0pXG5cbiAgICAgIC8vIENyZWF0ZSB0cmFuc2FjdGlvblxuICAgICAgY29uc3QgdHJhbnNmZXJUeCA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZCh0cmFuc2Zlckl4KVxuXG4gICAgICAvLyBHZXQgZnJlc2ggcmVjZW50IGJsb2NraGFzaCByaWdodCBiZWZvcmUgc2lnbmluZ1xuICAgICAgY29uc29sZS5sb2coJ0dldHRpbmcgZnJlc2ggYmxvY2toYXNoIGZvciBTT0wgdHJhbnNmZXIuLi4nKVxuICAgICAgY29uc3QgeyBibG9ja2hhc2gsIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiB0cmFuc2ZlckJsb2NrSGVpZ2h0IH0gPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKCdjb25maXJtZWQnKVxuICAgICAgY29uc29sZS5sb2coJ0ZyZXNoIFNPTCB0cmFuc2ZlciBibG9ja2hhc2g6JywgYmxvY2toYXNoKVxuICAgICAgY29uc29sZS5sb2coJ0xhc3QgdmFsaWQgYmxvY2sgaGVpZ2h0OicsIHRyYW5zZmVyQmxvY2tIZWlnaHQpXG5cbiAgICAgIHRyYW5zZmVyVHgucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoXG4gICAgICB0cmFuc2ZlclR4LmZlZVBheWVyID0gdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleVxuXG4gICAgICAvLyBTaWduIGFuZCBzZW5kIHRoZSBTT0wgdHJhbnNmZXIgaW1tZWRpYXRlbHlcbiAgICAgIGNvbnNvbGUubG9nKCdTaWduaW5nIGFuZCBzZW5kaW5nIFNPTCB0cmFuc2ZlciB3aXRoIGZyZXNoIGJsb2NraGFzaC4uLicpXG4gICAgICBjb25zdCBzaWduZWRUcmFuc2ZlclR4ID0gYXdhaXQgdGhpcy5zb2xhbmFVc2VyLndhbGxldEFkYXB0ZXIuc2lnblRyYW5zYWN0aW9uKHRyYW5zZmVyVHgpXG4gICAgICB0cmFuc2ZlclNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNmZXJUeC5zZXJpYWxpemUoKSlcblxuICAgICAgY29uc29sZS5sb2coJ1NPTCB0cmFuc2ZlciBzZW50OicsIHRyYW5zZmVyU2lnbmF0dXJlKVxuXG4gICAgICAvLyBXYWl0IGZvciB0cmFuc2ZlciBjb25maXJtYXRpb24gdXNpbmcgdGhlIG1vZGVybiBBUElcbiAgICAgIGF3YWl0IHRoaXMuY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oe1xuICAgICAgICBzaWduYXR1cmU6IHRyYW5zZmVyU2lnbmF0dXJlLFxuICAgICAgICAuLi4oYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCgpKVxuICAgICAgfSlcbiAgICAgIGNvbnNvbGUubG9nKCdTT0wgdHJhbnNmZXIgY29uZmlybWVkJylcblxuICAgICAgLy8gU3RlcCAyOiBSZWNvcmQgdGhlIHBheW1lbnQgaW4gdGhlIGNvbnRyYWN0XG4gICAgICBjb25zb2xlLmxvZygnU3RlcCAyOiBSZWNvcmRpbmcgcGF5bWVudCBpbiBjb250cmFjdC4uLicpXG5cbiAgICAgIC8vIENvbnZlcnQgU29sYW5hIFB1YmxpY0tleSB0byBieXRlczMyXG4gICAgICBjb25zdCBwYXllclNvbGFuYUJ5dGVzMzIgPSB6ZXJvUGFkVmFsdWUoaGV4bGlmeSh0aGlzLnNvbGFuYVVzZXIucHVibGljS2V5LnRvQnl0ZXMoKSksIDMyKVxuXG4gICAgICAvLyBHZXQgY3VycmVudCBub25jZVxuICAgICAgY29uc3Qgbm9uY2UgPSBOdW1iZXIoYXdhaXQgdGhpcy5wcm94eUFwaS5nZXRUcmFuc2FjdGlvbkNvdW50KHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0KSlcbiAgICAgIGNvbnNvbGUubG9nKCdDdXJyZW50IG5vbmNlOicsIG5vbmNlKVxuXG4gICAgICAvLyBQcmVwYXJlIGNvbnRyYWN0IGNhbGwgZGF0YVxuICAgICAgY29uc3QgaWZhY2UgPSBuZXcgZXRoZXJzLkludGVyZmFjZShTT0xBTkFfVElQQ0FSRF9BQkkpXG4gICAgICBjb25zdCBkYXRhID0gaWZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKCdwYXlTb2xhbmFMaW5rJywgW1xuICAgICAgICBsaW5rSWQsXG4gICAgICAgIGFtb3VudExhbXBvcnRzLFxuICAgICAgICBwYXllclNvbGFuYUJ5dGVzMzJcbiAgICAgIF0pXG5cbiAgICAgIC8vIENyZWF0ZSB0cmFuc2FjdGlvbiBkYXRhXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbkRhdGEgPSB7XG4gICAgICAgIGZyb206IHRoaXMuc29sYW5hVXNlci5uZW9uV2FsbGV0LFxuICAgICAgICB0bzogQ09OVFJBQ1RfQUREUkVTUyxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfVxuXG4gICAgICAvLyBFc3RpbWF0ZSBnYXNcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uR2FzID0gYXdhaXQgdGhpcy5wcm94eUFwaS5lc3RpbWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uR2FzKHtcbiAgICAgICAgc29sYW5hUGF5ZXI6IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXksXG4gICAgICAgIHRyYW5zYWN0aW9uczogW3RyYW5zYWN0aW9uRGF0YV0sXG4gICAgICB9KVxuXG4gICAgICAvLyBDcmVhdGUgc2NoZWR1bGVkIHRyYW5zYWN0aW9uXG4gICAgICBsZXQgeyBzY2hlZHVsZWRUcmFuc2FjdGlvbiB9ID0gYXdhaXQgdGhpcy5wcm94eUFwaS5jcmVhdGVTY2hlZHVsZWRUcmFuc2FjdGlvbih7XG4gICAgICAgIHRyYW5zYWN0aW9uR2FzLFxuICAgICAgICB0cmFuc2FjdGlvbkRhdGEsXG4gICAgICAgIG5vbmNlXG4gICAgICB9KVxuXG4gICAgICAvLyBHZXQgZnJlc2ggcmVjZW50IGJsb2NraGFzaCByaWdodCBiZWZvcmUgc2lnbmluZ1xuICAgICAgY29uc29sZS5sb2coJ0dldHRpbmcgZnJlc2ggYmxvY2toYXNoIGZvciBjb250cmFjdCBjYWxsLi4uJylcbiAgICAgIGNvbnN0IHsgYmxvY2toYXNoOiBjb250cmFjdEJsb2NraGFzaCwgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IGNvbnRyYWN0QmxvY2tIZWlnaHQgfSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goJ2NvbmZpcm1lZCcpXG4gICAgICBjb25zb2xlLmxvZygnRnJlc2ggY29udHJhY3QgY2FsbCBibG9ja2hhc2g6JywgY29udHJhY3RCbG9ja2hhc2gpXG4gICAgICBjb25zb2xlLmxvZygnTGFzdCB2YWxpZCBibG9jayBoZWlnaHQ6JywgY29udHJhY3RCbG9ja0hlaWdodClcblxuICAgICAgc2NoZWR1bGVkVHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gY29udHJhY3RCbG9ja2hhc2hcbiAgICAgIHNjaGVkdWxlZFRyYW5zYWN0aW9uLmZlZVBheWVyID0gdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleVxuXG4gICAgICAvLyBTaWduIHdpdGggd2FsbGV0IGFkYXB0ZXIgKGZyb250ZW5kIGFwcHJvYWNoKVxuICAgICAgY29uc29sZS5sb2coJ1NpZ25pbmcgY29udHJhY3QgY2FsbCB3aXRoIGZyZXNoIGJsb2NraGFzaC4uLicpXG4gICAgICBjb25zdCBzaWduZWRUeCA9IGF3YWl0IHRoaXMuc29sYW5hVXNlci53YWxsZXRBZGFwdGVyLnNpZ25UcmFuc2FjdGlvbihzY2hlZHVsZWRUcmFuc2FjdGlvbilcblxuICAgICAgLy8gU2VuZCB0cmFuc2FjdGlvbiBpbW1lZGlhdGVseVxuICAgICAgY29uc29sZS5sb2coJ1NlbmRpbmcgY29udHJhY3QgY2FsbCB0cmFuc2FjdGlvbiBpbW1lZGlhdGVseS4uLicpXG4gICAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uc2VuZFJhd1RyYW5zYWN0aW9uKHNpZ25lZFR4LnNlcmlhbGl6ZSgpKVxuXG4gICAgICAvLyBXYWl0IGZvciB0cmFuc2FjdGlvbiBleGVjdXRpb24gb24gTmVvbiBFVk1cbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uU3RhdHVzID0gYXdhaXQgdGhpcy5wcm94eUFwaS53YWl0VHJhbnNhY3Rpb25UcmVlRXhlY3V0aW9uKFxuICAgICAgICB0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCxcbiAgICAgICAgbm9uY2UsXG4gICAgICAgIDYwMDAwXG4gICAgICApXG5cbiAgICAgIGlmICh0cmFuc2FjdGlvblN0YXR1cy5sZW5ndGggPT09IDAgfHwgdHJhbnNhY3Rpb25TdGF0dXNbMF0uc3RhdHVzICE9PSAnU3VjY2VzcycpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDb250cmFjdCBwYXltZW50IHJlY29yZGluZyBmYWlsZWQsIGJ1dCBTT0wgdHJhbnNmZXIgc3VjY2VlZGVkJylcbiAgICAgICAgY29uc29sZS5sb2coJ1RyYW5zZmVyIHNpZ25hdHVyZTonLCB0cmFuc2ZlclNpZ25hdHVyZSlcbiAgICAgICAgLy8gRG9uJ3QgdGhyb3cgZXJyb3IgLSB0aGUgcGF5bWVudCB3ZW50IHRocm91Z2ggZXZlbiBpZiByZWNvcmRpbmcgZmFpbGVkXG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdQYXltZW50IGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkhJylcbiAgICAgIGNvbnNvbGUubG9nKCdTT0wgdHJhbnNmZXI6JywgdHJhbnNmZXJTaWduYXR1cmUpXG4gICAgICBjb25zb2xlLmxvZygnQ29udHJhY3QgcmVjb3JkOicsIHRyYW5zYWN0aW9uU3RhdHVzWzBdPy50cmFuc2FjdGlvbkhhc2gpXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR4SGFzaDogdHJhbnNhY3Rpb25TdGF0dXNbMF0/LnRyYW5zYWN0aW9uSGFzaCB8fCAnY29udHJhY3QtcmVjb3JkaW5nLWZhaWxlZCcsXG4gICAgICAgIHRyYW5zZmVyU2lnbmF0dXJlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGF5aW5nIGxpbms6JywgZXJyb3IpXG4gICAgICBpZiAodHJhbnNmZXJTaWduYXR1cmUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ05vdGU6IFNPTCB0cmFuc2ZlciBtYXkgaGF2ZSBzdWNjZWVkZWQ6JywgdHJhbnNmZXJTaWduYXR1cmUpXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWFjdGl2YXRlIGEgcGF5bWVudCBsaW5rXG4gICAqL1xuICBhc3luYyBkZWFjdGl2YXRlTGluayhsaW5rSWQ6IHN0cmluZyk6IFByb21pc2U8eyB0eEhhc2g6IHN0cmluZyB9PiB7XG4gICAgaWYgKCF0aGlzLnNvbGFuYVVzZXIgfHwgIXRoaXMuY29udHJhY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIGNvbm5lY3Qgd2FsbGV0IGZpcnN0JylcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gR2V0IGN1cnJlbnQgbm9uY2VcbiAgICAgIGNvbnN0IG5vbmNlID0gTnVtYmVyKGF3YWl0IHRoaXMucHJveHlBcGkuZ2V0VHJhbnNhY3Rpb25Db3VudCh0aGlzLnNvbGFuYVVzZXIubmVvbldhbGxldCkpXG4gICAgICBjb25zb2xlLmxvZygnQ3VycmVudCBub25jZTonLCBub25jZSlcblxuICAgICAgLy8gUHJlcGFyZSBjb250cmFjdCBjYWxsIGRhdGFcbiAgICAgIGNvbnN0IGlmYWNlID0gbmV3IGV0aGVycy5JbnRlcmZhY2UoU09MQU5BX1RJUENBUkRfQUJJKVxuICAgICAgY29uc3QgZGF0YSA9IGlmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YSgnZGVhY3RpdmF0ZVNvbGFuYUxpbmsnLCBbbGlua0lkXSlcblxuICAgICAgLy8gQ3JlYXRlIHRyYW5zYWN0aW9uIGRhdGFcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uRGF0YSA9IHtcbiAgICAgICAgZnJvbTogdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsXG4gICAgICAgIHRvOiBDT05UUkFDVF9BRERSRVNTLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9XG5cbiAgICAgIC8vIEVzdGltYXRlIGdhc1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25HYXMgPSBhd2FpdCB0aGlzLnByb3h5QXBpLmVzdGltYXRlU2NoZWR1bGVkVHJhbnNhY3Rpb25HYXMoe1xuICAgICAgICBzb2xhbmFQYXllcjogdGhpcy5zb2xhbmFVc2VyLnB1YmxpY0tleSxcbiAgICAgICAgdHJhbnNhY3Rpb25zOiBbdHJhbnNhY3Rpb25EYXRhXSxcbiAgICAgIH0pXG5cbiAgICAgIC8vIENyZWF0ZSBzY2hlZHVsZWQgdHJhbnNhY3Rpb25cbiAgICAgIGxldCB7IHNjaGVkdWxlZFRyYW5zYWN0aW9uIH0gPSBhd2FpdCB0aGlzLnByb3h5QXBpLmNyZWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgdHJhbnNhY3Rpb25HYXMsXG4gICAgICAgIHRyYW5zYWN0aW9uRGF0YSxcbiAgICAgICAgbm9uY2VcbiAgICAgIH0pXG5cbiAgICAgIC8vIEdldCBmcmVzaCByZWNlbnQgYmxvY2toYXNoIHJpZ2h0IGJlZm9yZSBzaWduaW5nXG4gICAgICBjb25zb2xlLmxvZygnR2V0dGluZyBmcmVzaCBibG9ja2hhc2ggZm9yIGRlYWN0aXZhdGUgdHJhbnNhY3Rpb24uLi4nKVxuICAgICAgY29uc3QgeyBibG9ja2hhc2gsIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiBkZWFjdGl2YXRlQmxvY2tIZWlnaHQgfSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goJ2NvbmZpcm1lZCcpXG4gICAgICBjb25zb2xlLmxvZygnRnJlc2ggZGVhY3RpdmF0ZSBibG9ja2hhc2g6JywgYmxvY2toYXNoKVxuICAgICAgY29uc29sZS5sb2coJ0xhc3QgdmFsaWQgYmxvY2sgaGVpZ2h0OicsIGRlYWN0aXZhdGVCbG9ja0hlaWdodClcblxuICAgICAgc2NoZWR1bGVkVHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoXG4gICAgICBzY2hlZHVsZWRUcmFuc2FjdGlvbi5mZWVQYXllciA9IHRoaXMuc29sYW5hVXNlci5wdWJsaWNLZXlcblxuICAgICAgLy8gU2lnbiB3aXRoIHdhbGxldCBhZGFwdGVyIChmcm9udGVuZCBhcHByb2FjaClcbiAgICAgIGNvbnNvbGUubG9nKCdTaWduaW5nIGRlYWN0aXZhdGUgdHJhbnNhY3Rpb24gd2l0aCBmcmVzaCBibG9ja2hhc2guLi4nKVxuICAgICAgY29uc3Qgc2lnbmVkVHggPSBhd2FpdCB0aGlzLnNvbGFuYVVzZXIud2FsbGV0QWRhcHRlci5zaWduVHJhbnNhY3Rpb24oc2NoZWR1bGVkVHJhbnNhY3Rpb24pXG5cbiAgICAgIC8vIFNlbmQgdHJhbnNhY3Rpb24gaW1tZWRpYXRlbHlcbiAgICAgIGNvbnNvbGUubG9nKCdTZW5kaW5nIGRlYWN0aXZhdGUgdHJhbnNhY3Rpb24gaW1tZWRpYXRlbHkuLi4nKVxuICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihzaWduZWRUeC5zZXJpYWxpemUoKSlcblxuICAgICAgLy8gV2FpdCBmb3IgdHJhbnNhY3Rpb24gZXhlY3V0aW9uXG4gICAgICBjb25zdCB0cmFuc2FjdGlvblN0YXR1cyA9IGF3YWl0IHRoaXMucHJveHlBcGkud2FpdFRyYW5zYWN0aW9uVHJlZUV4ZWN1dGlvbihcbiAgICAgICAgdGhpcy5zb2xhbmFVc2VyLm5lb25XYWxsZXQsXG4gICAgICAgIG5vbmNlLFxuICAgICAgICA2MDAwMFxuICAgICAgKVxuXG4gICAgICBpZiAodHJhbnNhY3Rpb25TdGF0dXMubGVuZ3RoID09PSAwIHx8IHRyYW5zYWN0aW9uU3RhdHVzWzBdLnN0YXR1cyAhPT0gJ1N1Y2Nlc3MnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVhY3RpdmF0aW9uIHRyYW5zYWN0aW9uIGZhaWxlZCB0byBleGVjdXRlIG9uIE5lb24gRVZNJylcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHhIYXNoOiB0cmFuc2FjdGlvblN0YXR1c1swXS50cmFuc2FjdGlvbkhhc2hcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzaGFyZWFibGUgVVJMIGZvciBhIHBheW1lbnQgbGlua1xuICAgKi9cbiAgY3JlYXRlUGF5bWVudFVSTChsaW5rSWQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke3dpbmRvdy5sb2NhdGlvbi5vcmlnaW59P3BheT0ke2xpbmtJZH1gXG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdCBsaW5rIElEIGZyb20gVVJMXG4gICAqL1xuICBzdGF0aWMgZXh0cmFjdExpbmtJZEZyb21VUkwodXJsOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXJsT2JqID0gbmV3IFVSTCh1cmwpXG4gICAgICByZXR1cm4gdXJsT2JqLnNlYXJjaFBhcmFtcy5nZXQoJ3BheScpXG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzZXIncyBFVk0gYWRkcmVzcyBkZXJpdmVkIGZyb20gU29sYW5hIHB1YmxpYyBrZXlcbiAgICovXG4gIGdldFVzZXJFVk1BZGRyZXNzKCk6IHN0cmluZyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLnNvbGFuYVVzZXI/Lm5lb25XYWxsZXQgfHwgbnVsbFxuICB9XG59XG5cbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBzb2xhbmFOYXRpdmVDb250cmFjdCA9IG5ldyBTb2xhbmFOYXRpdmVDb250cmFjdCgpIl0sIm5hbWVzIjpbIkNvbm5lY3Rpb24iLCJOZW9uUHJveHlScGNBcGkiLCJjcmVhdGVCYWxhbmNlQWNjb3VudEluc3RydWN0aW9uIiwiZXRoZXJzIiwiaGV4bGlmeSIsInplcm9QYWRWYWx1ZSIsIkNvbnRyYWN0QUJJIiwiU09MQU5BX1RJUENBUkRfQUJJIiwiQ09OVFJBQ1RfQUREUkVTUyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19USVBDQVJEX0NPTlRSQUNUX0FERFJFU1MiLCJORU9OX0NPUkVfUlBDX1VSTCIsIk5FWFRfUFVCTElDX05FT05fUlBDX1VSTCIsIk5FT05fUFJPWFlfUlBDX1VSTCIsIlNPTEFOQV9SUENfVVJMIiwiU29sYW5hTmF0aXZlQ29udHJhY3QiLCJpbml0V2l0aFNvbGFuYVdhbGxldCIsIndhbGxldEFkYXB0ZXIiLCJwdWJsaWNLZXkiLCJFcnJvciIsImNvbnNvbGUiLCJsb2ciLCJ0b0Jhc2U1OCIsInByb3ZpZGVyIiwiY2hhaW5JZCIsInNvbGFuYVVzZXIiLCJ0b2tlbk1pbnRBZGRyZXNzIiwicHJvZ3JhbUFkZHJlc3MiLCJwcm94eUFwaSIsImluaXQiLCJiYWxhbmNlQWRkcmVzcyIsIlNvbGFuYU5lb25BY2NvdW50IiwiYWNjb3VudCIsIm5lb25Fdm1Qcm9ncmFtIiwidG9rZW5NaW50IiwiZXJyb3IiLCJyZWFkT25seVByb3ZpZGVyIiwiSnNvblJwY1Byb3ZpZGVyIiwiY29udHJhY3QiLCJDb250cmFjdCIsInR4Q291bnQiLCJnZXRUcmFuc2FjdGlvbkNvdW50IiwibmVvbldhbGxldCIsInZlcmlmeUVycm9yIiwiY29kZSIsImdldENvZGUiLCJ3YXJuIiwiY3JlYXRlUGF5bWVudExpbmsiLCJzdWdnZXN0ZWRBbW91bnRTT0wiLCJpc0ZsZXhpYmxlIiwiZGVzY3JpcHRpb24iLCJhbW91bnRMYW1wb3J0cyIsIk1hdGgiLCJmbG9vciIsInNpZ25hdHVyZSIsIm5vbmNlIiwicmV0cnlDb3VudCIsIm1heFJldHJpZXMiLCJOdW1iZXIiLCJwZW5kaW5nVHgiLCJnZXRUcmFuc2FjdGlvbkJ5U2VuZGVyTm9uY2UiLCJwZW5kaW5nRXJyb3IiLCJtZXNzYWdlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiaWZhY2UiLCJJbnRlcmZhY2UiLCJkYXRhIiwiZW5jb2RlRnVuY3Rpb25EYXRhIiwidHJhbnNhY3Rpb25EYXRhIiwiZnJvbSIsInRvIiwidHJhbnNhY3Rpb25HYXMiLCJlc3RpbWF0ZVNjaGVkdWxlZFRyYW5zYWN0aW9uR2FzIiwic29sYW5hUGF5ZXIiLCJ0cmFuc2FjdGlvbnMiLCJnYXNFcnJvciIsInNjaGVkdWxlZFRyYW5zYWN0aW9uIiwiY3JlYXRlU2NoZWR1bGVkVHJhbnNhY3Rpb24iLCJjb25uZWN0aW9uIiwiZ2V0QWNjb3VudEluZm8iLCJpbnN0cnVjdGlvbnMiLCJ1bnNoaWZ0IiwiYmxvY2toYXNoIiwiZ2V0TGF0ZXN0QmxvY2toYXNoIiwicmVjZW50QmxvY2toYXNoIiwiZmVlUGF5ZXIiLCJsZW5ndGgiLCJzaWduZWRUcmFuc2FjdGlvbiIsInNpZ25UcmFuc2FjdGlvbiIsInNlbmRSYXdUcmFuc2FjdGlvbiIsInNlcmlhbGl6ZSIsInNraXBQcmVmbGlnaHQiLCJwcmVmbGlnaHRDb21taXRtZW50IiwiY29uZmlybWVkIiwiY29uZmlybVJldHJpZXMiLCJtYXhDb25maXJtUmV0cmllcyIsImNvbmZpcm1hdGlvbiIsImdldFNpZ25hdHVyZVN0YXR1cyIsInZhbHVlIiwiY29uZmlybWF0aW9uU3RhdHVzIiwiY29uZmlybUVycm9yIiwibmVvblR4UmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInBhcmFtcyIsImlkIiwianNvbnJwYyIsIm5lb25UeFJlc3VsdCIsImpzb24iLCJyZXN1bHQiLCJoYXNoIiwibGlua0lkIiwidHhIYXNoIiwibmVvbkVycm9yIiwiaW5jbHVkZXMiLCJpbml0UmVhZE9ubHlDb250cmFjdCIsImdldFBheW1lbnRMaW5rIiwiZ2V0U29sYW5hUGF5bWVudExpbmsiLCJwYXltZW50TGluayIsImV2bUNyZWF0b3IiLCJzb2xhbmFDcmVhdG9yIiwiYW1vdW50IiwiaXNBY3RpdmUiLCJ0b3RhbFJlY2VpdmVkIiwicGF5bWVudENvdW50IiwiQmlnSW50Iiwic3RhcnRzV2l0aCIsImdldFVzZXJMaW5rcyIsInVzZXJFVk1BZGRyZXNzIiwiZ2V0VXNlclNvbGFuYUxpbmtzIiwicGF5TGluayIsImFtb3VudFNPTCIsImxpbmtEYXRhIiwidHJhbnNmZXJTaWduYXR1cmUiLCJoZXhTdHJpbmciLCJ0cmFuc2FjdGlvblN0YXR1cyIsInNsaWNlIiwiYnl0ZXMiLCJVaW50OEFycmF5IiwibWF0Y2giLCJtYXAiLCJieXRlIiwicGFyc2VJbnQiLCJyZWNpcGllbnRQdWJrZXkiLCJQdWJsaWNLZXkiLCJsYXN0MzJCeXRlcyIsInBhZGRlZEJ5dGVzIiwic2V0IiwiU3lzdGVtUHJvZ3JhbSIsIlRyYW5zYWN0aW9uIiwidHJhbnNmZXJJeCIsInRyYW5zZmVyIiwiZnJvbVB1YmtleSIsInRvUHVia2V5IiwibGFtcG9ydHMiLCJ0cmFuc2ZlclR4IiwiYWRkIiwibGFzdFZhbGlkQmxvY2tIZWlnaHQiLCJ0cmFuc2ZlckJsb2NrSGVpZ2h0Iiwic2lnbmVkVHJhbnNmZXJUeCIsImNvbmZpcm1UcmFuc2FjdGlvbiIsInBheWVyU29sYW5hQnl0ZXMzMiIsInRvQnl0ZXMiLCJjb250cmFjdEJsb2NraGFzaCIsImNvbnRyYWN0QmxvY2tIZWlnaHQiLCJzaWduZWRUeCIsIndhaXRUcmFuc2FjdGlvblRyZWVFeGVjdXRpb24iLCJzdGF0dXMiLCJ0cmFuc2FjdGlvbkhhc2giLCJkZWFjdGl2YXRlTGluayIsImRlYWN0aXZhdGVCbG9ja0hlaWdodCIsImNyZWF0ZVBheW1lbnRVUkwiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIm9yaWdpbiIsImV4dHJhY3RMaW5rSWRGcm9tVVJMIiwidXJsIiwidXJsT2JqIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwiZ2V0IiwiZ2V0VXNlckVWTUFkZHJlc3MiLCJjb25zdHJ1Y3RvciIsInNvbGFuYU5hdGl2ZUNvbnRyYWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/solana-native-contract.ts\n"));

/***/ })

});